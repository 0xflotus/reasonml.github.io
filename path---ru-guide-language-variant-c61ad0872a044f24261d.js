webpackJsonp([17],{"./node_modules/json-loader/index.js!./.cache/json/ru-guide-language-variant.json":function(a,e){a.exports={data:{allFile:{edges:[{node:{relativePath:"ru/guide/index.md",childMarkdownRemark:{frontmatter:{title:"Гайд по Reason",order:0}}}},{node:{relativePath:"ru/guide/examples.md",childMarkdownRemark:{frontmatter:{title:"Примеры",order:60}}}},{node:{relativePath:"ru/guide/ocaml.md",childMarkdownRemark:{frontmatter:{title:"Comparison to OCaml",order:50}}}},{node:{relativePath:"ru/guide/what-and-why.md",childMarkdownRemark:{frontmatter:{title:"Что и Зачем",order:0}}}},{node:{relativePath:"ru/guide/editor-tools/global-installation.md",childMarkdownRemark:{frontmatter:{title:"Глобальная установка",order:10}}}},{node:{relativePath:"ru/guide/editor-tools/editors-plugins.md",childMarkdownRemark:{frontmatter:{title:"Плагины редактора",order:20}}}},{node:{relativePath:"ru/guide/editor-tools/extra-goodies.md",childMarkdownRemark:{frontmatter:{title:"Дополнительные бонусы",order:30}}}},{node:{relativePath:"ru/guide/editor-tools/index.md",childMarkdownRemark:{frontmatter:{title:"Настройка редактора",order:10}}}},{node:{relativePath:"ru/guide/language/destructuring.md",childMarkdownRemark:{frontmatter:{title:"Деструктурирование",order:130}}}},{node:{relativePath:"ru/guide/language/boolean.md",childMarkdownRemark:{frontmatter:{title:"Булев",order:30}}}},{node:{relativePath:"ru/guide/language/external.md",childMarkdownRemark:{frontmatter:{title:"External",order:170}}}},{node:{relativePath:"ru/guide/language/exception.md",childMarkdownRemark:{frontmatter:{title:"Исключения",order:175}}}},{node:{relativePath:"ru/guide/language/index.md",childMarkdownRemark:{frontmatter:{title:"Основы языка",order:20}}}},{node:{relativePath:"ru/guide/language/if-else.md",childMarkdownRemark:{frontmatter:{title:"If-Else",order:110}}}},{node:{relativePath:"ru/guide/language/function.md",childMarkdownRemark:{frontmatter:{title:"Функция",order:100}}}},{node:{relativePath:"ru/guide/language/integer-and-float.md",childMarkdownRemark:{frontmatter:{title:"Числа",order:40}}}},{node:{relativePath:"ru/guide/language/imperative-loops.md",childMarkdownRemark:{frontmatter:{title:"Императивные циклы",order:150}}}},{node:{relativePath:"ru/guide/language/let-binding.md",childMarkdownRemark:{frontmatter:{title:"Let привязка",order:10}}}},{node:{relativePath:"ru/guide/language/jsx.md",childMarkdownRemark:{frontmatter:{title:"JSX",order:160}}}},{node:{relativePath:"ru/guide/language/list-and-array.md",childMarkdownRemark:{frontmatter:{title:"Список и Массив",order:80}}}},{node:{relativePath:"ru/guide/language/module.md",childMarkdownRemark:{frontmatter:{title:"Модуль",order:180}}}},{node:{relativePath:"ru/guide/language/more-on-type.md",childMarkdownRemark:{frontmatter:{title:"Больше о типах",order:120}}}},{node:{relativePath:"ru/guide/language/object.md",childMarkdownRemark:{frontmatter:{title:"Объект",order:175}}}},{node:{relativePath:"ru/guide/language/mutation.md",childMarkdownRemark:{frontmatter:{title:"Мутации",order:140}}}},{node:{relativePath:"ru/guide/language/overview.md",childMarkdownRemark:{frontmatter:{title:"Обзор",order:0}}}},{node:{relativePath:"ru/guide/language/pattern-matching.md",childMarkdownRemark:{frontmatter:{title:"Паттерн-матчинг",order:135}}}},{node:{relativePath:"ru/guide/language/string-and-char.md",childMarkdownRemark:{frontmatter:{title:"Строка и символ",order:20}}}},{node:{relativePath:"ru/guide/language/record.md",childMarkdownRemark:{frontmatter:{title:"Запись",order:60}}}},{node:{relativePath:"ru/guide/language/tuple.md",childMarkdownRemark:{frontmatter:{title:"Кортеж",order:50}}}},{node:{relativePath:"ru/guide/language/type.md",childMarkdownRemark:{frontmatter:{title:"Тип!",order:15}}}},{node:{relativePath:"ru/guide/language/variant.md",childMarkdownRemark:{frontmatter:{title:"Вариант!",order:70}}}},{node:{relativePath:"ru/guide/javascript/interop.md",childMarkdownRemark:{frontmatter:{title:"Взаимодействие",order:1}}}},{node:{relativePath:"ru/guide/javascript/converting.md",childMarkdownRemark:{frontmatter:{title:"Перенос JS кода",order:5}}}},{node:{relativePath:"ru/guide/javascript/index.md",childMarkdownRemark:{frontmatter:{title:"JavaScript",order:30}}}},{node:{relativePath:"ru/guide/javascript/quickstart.md",childMarkdownRemark:{frontmatter:{title:"Быстрый старт",order:0}}}},{node:{relativePath:"ru/guide/javascript/libraries.md",childMarkdownRemark:{frontmatter:{title:"Библиотеки",order:2}}}},{node:{relativePath:"ru/guide/native/convert-from-ocaml.md",childMarkdownRemark:{frontmatter:{title:"Converting from OCaml",order:4}}}},{node:{relativePath:"ru/guide/javascript/syntax-cheatsheet.md",childMarkdownRemark:{frontmatter:{title:"Шпаргалка по синтаксису",order:1}}}},{node:{relativePath:"ru/guide/native/index.md",childMarkdownRemark:{frontmatter:{title:"Native",order:40}}}},{node:{relativePath:"ru/guide/native/quickstart.md",childMarkdownRemark:{frontmatter:{title:"Quickstart",order:0}}}}]},file:{relativePath:"ru/guide/language/variant.md",childMarkdownRemark:{html:'<p>Трепещите! Драгоценность среди структур данных Reason!</p>\n<p>Большая часть структур данных в большинстве языков об этом <strong>и</strong> том. Вариант позволяет\nнам выразить это <strong>или</strong> то.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> myResponseVariant =\n| <span class="hljs-type">Yes</span>\n| <span class="hljs-type">No</span>\n| <span class="hljs-type">PrettyMuch</span>;\n\n<span class="hljs-keyword">let</span> areYouCrushingIt = <span class="hljs-type">Yes</span>;</code></pre>\n      </div>\n<p><code>Yes</code>, <code>No</code> и <code>PrettyMuch</code> не строки и не ссылки, а некий специальный тип. Они называются\n"конструкторами" (или "тегами"). Символ <code>|</code> разделяет каждый конструктор.</p>\n<p><strong>Важно</strong>: имена конструкторов должны начинаться с заглавной буквы.</p>\n<h3 id="Использование"><a href="#%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Использование</h3>\n<p>Вместе с вариантом идет одна из важнейших фич Reason — <code>switch</code> выражение.</p>\n<p><code>switch</code> в Reason визуально похож на тот, который можно встретить в других языках (что\nработает как большой <code>if/elseif/elseif...</code>). Оно позволяет проверять все возможные\nкомбинации варианта. Для использования перечислите все конструкторы варианта, который\nхотите использовать, указав после <code>=></code> и выражение для конкретного случая.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> message = <span class="hljs-keyword">switch</span> (areYouCrushingIt) {\n| <span class="hljs-type">No</span> =&gt; <span class="hljs-string">"No worries. Keep going!"</span>\n| <span class="hljs-type">Yes</span> =&gt; <span class="hljs-string">"Great!"</span>\n| <span class="hljs-type">PrettyMuch</span> =&gt; <span class="hljs-string">"Nice!"</span>\n};\n<span class="hljs-comment">/* message будет "Great!" */</span></code></pre>\n      </div>\n<p>Варианты имеют огромную поддержку со стороны системы типов. Например, она выдаст ошибку,\nесли вы забудете покрыть один из случаем варианта, или если два случая будут\nвзаимозаменяемы. Обязательно прочитайте об этой конструкции и паттер-матчинге\nв <a href="../../guide/language/pattern-matching">последующей секции</a>!</p>\n<h4 id="Вариантам-необходимо-явное-определение"><a href="#%D0%92%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D0%B0%D0%BC-%D0%BD%D0%B5%D0%BE%D0%B1%D1%85%D0%BE%D0%B4%D0%B8%D0%BC%D0%BE-%D1%8F%D0%B2%D0%BD%D0%BE%D0%B5-%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Вариантам необходимо явное определение</h4>\n<p>Если вы используете вариант из другого файла, то принесите его в область видимости\nкак вы делаете это <a href="../../guide/language/record#record-needs-an-explicit-definition">для записи</a>:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-comment">/* Zoo.re */</span>\n\n<span class="hljs-keyword">type</span> animal = <span class="hljs-type">Dog</span> | <span class="hljs-type">Cat</span> | <span class="hljs-type">Bird</span>;</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-comment">/* example.re */</span>\n\n<span class="hljs-keyword">let</span> pet: <span class="hljs-type">Zoo</span>.animal = <span class="hljs-type">Dog</span>; <span class="hljs-comment">/* предпочтительный способ */</span>\n<span class="hljs-comment">/* или */</span>\n<span class="hljs-keyword">let</span> pet = <span class="hljs-type">Zoo</span>.<span class="hljs-type">Dog</span>;</code></pre>\n      </div>\n<h4 id="Аргументы-конструктора"><a href="#%D0%90%D1%80%D0%B3%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B-%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80%D0%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Аргументы конструктора</h4>\n<p>Конструкторы вариантов могут содержать дополнительные данные, разделенные пробелом.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> account =\n| <span class="hljs-type">None</span>\n| <span class="hljs-type">Instagram</span> string\n| <span class="hljs-type">Facebook</span> string int;</code></pre>\n      </div>\n<p>Здесь <code>Instagram</code> содержит <code>string</code>, а <code>Facebook</code> содержит <code>string</code> и <code>int</code>. Использование:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> myAccount = <span class="hljs-type">Facebook</span> <span class="hljs-string">"Josh"</span> <span class="hljs-number">26</span>;\n<span class="hljs-keyword">let</span> friendAccount = <span class="hljs-type">Instagram</span> <span class="hljs-string">"Jenny"</span>;</code></pre>\n      </div>\n<p><strong>Заметили, что использование конструктора похоже на вызов функции</strong>? Как если бы\n<code>Facebook</code> был функцией, принимающей два аргумента. Это не случайность, есть основания\nпочему дополнительные данные называются "аргументами конструктора".</p>\n<p>Используя <code>switch</code>, вы можете сопоставлять шаблон значению:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> greeting = <span class="hljs-keyword">switch</span> (myAccount) {\n| <span class="hljs-type">None</span> =&gt; <span class="hljs-string">"Hi!"</span>\n| <span class="hljs-type">Facebook</span> name age =&gt;\n  <span class="hljs-string">"Hi "</span> ^ name ^ <span class="hljs-string">", you\'re "</span> ^ (string_of_int age) ^ <span class="hljs-string">"-year-old."</span>\n| <span class="hljs-type">Instagram</span> name =&gt; <span class="hljs-string">"Hello "</span> ^ name ^ <span class="hljs-string">"!"</span>\n}</code></pre>\n      </div>\n<h4 id="Важные-замечания"><a href="#%D0%92%D0%B0%D0%B6%D0%BD%D1%8B%D0%B5-%D0%B7%D0%B0%D0%BC%D0%B5%D1%87%D0%B0%D0%BD%D0%B8%D1%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Важные замечания</h4>\n<p><a href="/api/index.html">Стандартная библиотека</a> предоставляет два важных варианта, которые вы\nбудете часто встречать.</p>\n<h5 id="option"><a href="#option" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>option</code></h5>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> option \'a = <span class="hljs-type">None</span> | <span class="hljs-type">Some</span> \'a;</code></pre>\n      </div>\n<p>Это принятый способ симулировать "нулевой" (<code>undefined</code>, <code>null</code>) тип в других языках.\nБлагодаря этому в Reason нет может быть значений, которые могут оказаться нулевыми.\nТип <code>int</code> всегда будет целым и никогда "<code>int</code> <strong>или</strong> <code>null</code> <strong>или</strong> <code>undefined</code>".\nЕсли вам нужно выразить "nullable int", вы можете использовать <code>option int</code>,\nчье возможное значение <code>None</code> или <code>Some int</code>. <code>switch</code> принудит проверить оба случая,\n<strong>программа на Reason не имеет ошибок связанных с null</strong>.</p>\n<h5 id="Список-list"><a href="#%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA-list" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Список <code>list</code></h5>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> list \'a = <span class="hljs-type">Empty</span> | <span class="hljs-type">Head</span> \'a (list \'a);</code></pre>\n      </div>\n<p><em>Это не настоящий тип, просто иллюстрация</em></p>\n<p>Это значит: "список, который содержит значение типа <code>a</code> (неважно что это за тип)\nявляется или пустым списком или содержит значение + еще список".</p>\n<p>Reason имеет синтаксический сахар <code>list</code>. <code>[1, 2, 3]</code> это эквивалент\n<code>Head 1 (Head 2 (Head 3 Empty))</code>. И опять, <code>switch</code> принудит проверить все случаи,\nвключая <code>Empty</code> (то есть <code>[]</code>). <strong>Это устаняет другую большую категорию багов</strong>.</p>\n<h5 id="Другие-типы-похожие-на-варианты"><a href="#%D0%94%D1%80%D1%83%D0%B3%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B-%D0%BF%D0%BE%D1%85%D0%BE%D0%B6%D0%B8%D0%B5-%D0%BD%D0%B0-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Другие типы, похожие на варианты</h5>\n<p>А вы знаете, что можете использовать <code>switch</code> на числах, строках и большинстве структур\nданных? Попробуйте!</p>\n<!-- TODO playground link -->\n<h3 id="Советы-и-трюки"><a href="#%D0%A1%D0%BE%D0%B2%D0%B5%D1%82%D1%8B-%D0%B8-%D1%82%D1%80%D1%8E%D0%BA%D0%B8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Советы и трюки</h3>\n<p><strong>Будте внимательны</strong>: не путайте конструктор, который использует два аргумента с конструктором,\nкоторый использует кортеж из двух элементов:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> account =\n| <span class="hljs-type">Facebook</span> string int <span class="hljs-comment">/* два аргумента */</span>\n<span class="hljs-keyword">type</span> account2 =\n| <span class="hljs-type">Instagram</span> (string, int) <span class="hljs-comment">/* один аргумент — кортеж из двух элементов  */</span></code></pre>\n      </div>\n<h4 id="Варианты-обязаны-иметь-конструкторы"><a href="#%D0%92%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D0%BE%D0%B1%D1%8F%D0%B7%D0%B0%D0%BD%D1%8B-%D0%B8%D0%BC%D0%B5%D1%82%D1%8C-%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80%D1%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Варианты обязаны иметь конструкторы</h4>\n<p>Если вы пришли из нетипизированного языка, то у вас может возникнуть соблазн попробовать\n<code>type foo = int | string</code>. Это невозможно в Reason. Вы должны дать каждой ветке конструктор\n<code>type foo = Int int | String int</code>. Хотя обычно это считается анти-паттерном.</p>\n<h4 id="Взаимодействие-с-javascript"><a href="#%D0%92%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D0%B5-%D1%81-javascript" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Взаимодействие с JavaScript</h4>\n<p>Этот раздел подразумевает знание\n<a href="http://bucklescript.github.io/bucklescript/Manual.html#_ffi">FFI</a>.\nПропустите его если пока незнакомы.</p>\n<p>Многие JS библиотеки используют функции, которые могут принимать разные типы\nаргументов. В таких случаях заманчиво моделировать аргументы как варианты. Например,\nпредставим что есть функция <code>myLibrary.draw</code> в JS, которая принимает <code>number</code> или <code>string</code>.\nВы можете сделать так</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-none"><code>/* reserved <span class="hljs-keyword">for</span> internal usage */\n<span class="hljs-keyword">external</span> draw: <span class="hljs-symbol">\'a</span> =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"draw"</span> [@@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"myLibrary"</span>];\n\n<span class="hljs-keyword">type</span> animal =\n  | <span class="hljs-type">MyFloat</span> <span class="hljs-built_in">float</span>\n  | <span class="hljs-type">MyString</span> <span class="hljs-built_in">string</span>;\n\n<span class="hljs-keyword">let</span> betterDraw animal =&gt;\n  switch animal {\n  | <span class="hljs-type">MyFloat</span> f =&gt; draw f\n  | <span class="hljs-type">MyString</span> s =&gt; draw s\n  };</code></pre>\n      </div>\n<p>Но есть лучший способ! Например, просто два <code>external</code> которые компилируются в один\nJS вызов:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-none"><code><span class="hljs-keyword">external</span> drawFloat: <span class="hljs-built_in">float</span> =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"draw"</span> [@@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"myLibrary"</span>];\n<span class="hljs-keyword">external</span> drawString: <span class="hljs-built_in">string</span> =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"draw"</span> [@@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"myLibrary"</span>];</code></pre>\n      </div>\n<p>Или используйте продвинутую фичу, называемую GADT <a href="http://bucklescript.github.io/bucklescript/Manual.html#_phantom_arguments_and_ad_hoc_polymorphism">с фантомным аргументом FFI BuckleScript</a>. Если эти слова ничего для вас не говорят, не волнуйтесь, просто используйте\nпредыдущий способ.</p>\n<h4 id="Типы-вариантов-выводятся-из-имен-полей"><a href="#%D0%A2%D0%B8%D0%BF%D1%8B-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D0%BE%D0%B2-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D1%8F%D1%82%D1%81%D1%8F-%D0%B8%D0%B7-%D0%B8%D0%BC%D0%B5%D0%BD-%D0%BF%D0%BE%D0%BB%D0%B5%D0%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Типы вариантов выводятся из имен полей</h4>\n<p>Please refer to this <a href="../../guide/language/record#record-types-are-found-by-field-name">record section</a>. Variants are the same: a function can\'t accept an arbitrary constructor shared by two different variants. Again, such feature exists, it\'s called a polymorphic variant. We\'ll talk about this in the future =).</p>\n<h3 id="Проектные-решения"><a href="#%D0%9F%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%BD%D1%8B%D0%B5-%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D1%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Проектные решения</h3>\n<p>Варианты в различных формах (полиморфные, открытые, GADT, и так далее), возможно, основная\nфича таких систем типов как в Reason. Вышеупомянутый вариант <code>option</code>, например убирает\nнеобходимость использовать nullable типы. Философски говоря, проблема состоит и множества\nветок и условий. Ошибки в формировании этих условиях являются основным источником багов в\nдругих языках. <strong>Система типов не устраняет баги магическим образом. Она указвывает на\nнеобработанные случаи и просить закрыть их</strong>*. Способность языка моделировать идею\n"это или то" имеет решающее значение для этого.</p>\n<p>Например, как сделать так, чтобы система типом могла устранить просачивание плохих данных,\nполученных из инвалидного JSON? Это можно сделать если парсер будет возвращать тип\n<code>option</code>, то есть <code>None | Some actualData</code>, тогда все что нужно — это обработать случай\nс <code>None</code>.</p>\n<p>К тому же вариант может значительно ускорить логику вашей программы. Возьмем кусок JS кода:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-js"><code><span class="hljs-built_in">let</span> data = <span class="hljs-string">\'dog\'</span>;\n<span class="hljs-keyword">if</span> (data === <span class="hljs-string">\'dog\'</span>) {\n  ...\n} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data === <span class="hljs-string">\'cat\'</span>) {\n  ...\n} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data === <span class="hljs-string">\'bird\'</span>) {\n  ...\n}</code></pre>\n      </div>\n<p>Тут существует линейное количество проверок (<code>O(n)</code>). Сравните с подобным кодом на Reason:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> animal = <span class="hljs-type">Dog</span> | <span class="hljs-type">Cat</span> | <span class="hljs-type">Bird</span>;\n<span class="hljs-keyword">let</span> data = <span class="hljs-type">Dog</span>;\n<span class="hljs-keyword">switch</span> data {\n| <span class="hljs-type">Dog</span> =&gt; ...\n| <span class="hljs-type">Cat</span> =&gt; ...\n| <span class="hljs-type">Bird</span> =&gt; ...\n}</code></pre>\n      </div>\n<p>Компилятор видит вариант и потом:</p>\n<ol>\n<li>\n<p>Превращает его в <code>type animal = 0 | 1 | 2</code></p>\n</li>\n<li>\n<p>Компилирует <code>switch</code> в формат с константным временем (<code>O(1)</code>).</p>\n</li>\n</ol>\n<p>Вы можете задаться вопросом, почему типизированные функциональные языки используются так часто для синтаксического анализа. Переключение большого дерева эффективно и безопасно - это в значительной степени лучший сценарий для использования вариантов.</p>\n<!-- TODO: playground link -->\n<p>Ваш мозг уже кипит? Варианты имеют глубокую связь с другими областями математики;\n<a href="https://codewords.recurse.com/issues/three/algebra-and-calculus-of-algebraic-data-types">Посмотрите тут</a> если интересно.</p>\n<p>* Всегда лучше проектировать систему так, чтобы избежать подводных камней, а не надеяться\nна систему типов. Однако, в реальности, сложно сделать это для каждой проблемы. Более того\nне всегда удается понять проблему полностью, чтобы спроектировать решение сразу. Система\nтипов позволяет внести разнообразные изменения в кодовую базу без необходимости понимать\nвсе целиком. В связи с эти типы позволяют не затрачивать много времени на дизайн API чтобы\nобойти простые ошибки, вызванные вызывающей стороной. Они уменьшают уровень абстракций,\nнеобходимый для достижения цели, что уменьшает когнитивную нагрузку.</p>',frontmatter:{title:"Вариант!"}}}},pathContext:{section:"ru",relativePath:"ru/guide/language/variant.md",relatedFiles:"/^ru\\/.*\\.md$/"}}}});
//# sourceMappingURL=path---ru-guide-language-variant-c61ad0872a044f24261d.js.map