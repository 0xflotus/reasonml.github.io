webpackJsonp([14],{"./node_modules/json-loader/index.js!./.cache/json/guide-ocaml.json":function(e,t){e.exports={data:{allFile:{edges:[{node:{relativePath:"guide/examples.md",childMarkdownRemark:{frontmatter:{title:"Examples",order:60}}}},{node:{relativePath:"guide/index.md",childMarkdownRemark:{frontmatter:{title:"The Reason Guide",order:0}}}},{node:{relativePath:"guide/ocaml.md",childMarkdownRemark:{frontmatter:{title:"Comparison to OCaml",order:50}}}},{node:{relativePath:"guide/what-and-why.md",childMarkdownRemark:{frontmatter:{title:"What & Why",order:0}}}},{node:{relativePath:"guide/javascript/converting.md",childMarkdownRemark:{frontmatter:{title:"Converting from JS",order:5}}}},{node:{relativePath:"guide/javascript/interop.md",childMarkdownRemark:{frontmatter:{title:"Interop",order:1}}}},{node:{relativePath:"guide/javascript/index.md",childMarkdownRemark:{frontmatter:{title:"JavaScript",order:30}}}},{node:{relativePath:"guide/javascript/quickstart.md",childMarkdownRemark:{frontmatter:{title:"Quickstart",order:0}}}},{node:{relativePath:"guide/javascript/libraries.md",childMarkdownRemark:{frontmatter:{title:"Libraries",order:2}}}},{node:{relativePath:"guide/editor-tools/editors-plugins.md",childMarkdownRemark:{frontmatter:{title:"Editors Plugins",order:20}}}},{node:{relativePath:"guide/editor-tools/extra-goodies.md",childMarkdownRemark:{frontmatter:{title:"Extra Goodies",order:30}}}},{node:{relativePath:"guide/editor-tools/index.md",childMarkdownRemark:{frontmatter:{title:"Editor Setup",order:10}}}},{node:{relativePath:"guide/native/convert-from-ocaml.md",childMarkdownRemark:{frontmatter:{title:"Converting from OCaml",order:4}}}},{node:{relativePath:"guide/native/quickstart.md",childMarkdownRemark:{frontmatter:{title:"Quickstart",order:0}}}},{node:{relativePath:"guide/language/boolean.md",childMarkdownRemark:{frontmatter:{title:"Boolean",order:30}}}},{node:{relativePath:"guide/language/destructuring.md",childMarkdownRemark:{frontmatter:{title:"Destructuring",order:130}}}},{node:{relativePath:"guide/javascript/syntax-cheatsheet.md",childMarkdownRemark:{frontmatter:{title:"Syntax Cheatsheet",order:1}}}},{node:{relativePath:"guide/language/external.md",childMarkdownRemark:{frontmatter:{title:"External",order:170}}}},{node:{relativePath:"guide/editor-tools/global-installation.md",childMarkdownRemark:{frontmatter:{title:"Global Installation",order:10}}}},{node:{relativePath:"guide/language/if-else.md",childMarkdownRemark:{frontmatter:{title:"If-Else",order:110}}}},{node:{relativePath:"guide/language/imperative-loops.md",childMarkdownRemark:{frontmatter:{title:"Imperative Loops",order:150}}}},{node:{relativePath:"guide/native/index.md",childMarkdownRemark:{frontmatter:{title:"Native",order:40}}}},{node:{relativePath:"guide/language/index.md",childMarkdownRemark:{frontmatter:{title:"Language basics",order:20}}}},{node:{relativePath:"guide/language/exception.md",childMarkdownRemark:{frontmatter:{title:"Exception",order:175}}}},{node:{relativePath:"guide/language/let-binding.md",childMarkdownRemark:{frontmatter:{title:"Let Binding",order:10}}}},{node:{relativePath:"guide/language/function.md",childMarkdownRemark:{frontmatter:{title:"Function",order:100}}}},{node:{relativePath:"guide/language/integer-and-float.md",childMarkdownRemark:{frontmatter:{title:"Integer & Float",order:40}}}},{node:{relativePath:"guide/language/jsx.md",childMarkdownRemark:{frontmatter:{title:"JSX",order:160}}}},{node:{relativePath:"guide/language/module.md",childMarkdownRemark:{frontmatter:{title:"Module",order:180}}}},{node:{relativePath:"guide/language/list-and-array.md",childMarkdownRemark:{frontmatter:{title:"List & Array",order:80}}}},{node:{relativePath:"guide/language/object.md",childMarkdownRemark:{frontmatter:{title:"Object",order:175}}}},{node:{relativePath:"guide/language/overview.md",childMarkdownRemark:{frontmatter:{title:"Overview",order:0}}}},{node:{relativePath:"guide/language/more-on-type.md",childMarkdownRemark:{frontmatter:{title:"More on Type",order:120}}}},{node:{relativePath:"guide/language/mutation.md",childMarkdownRemark:{frontmatter:{title:"Mutation",order:140}}}},{node:{relativePath:"guide/language/pattern-matching.md",childMarkdownRemark:{frontmatter:{title:"Pattern Matching!",order:135}}}},{node:{relativePath:"guide/language/record.md",childMarkdownRemark:{frontmatter:{title:"Record",order:60}}}},{node:{relativePath:"guide/language/type.md",childMarkdownRemark:{frontmatter:{title:"Type!",order:15}}}},{node:{relativePath:"guide/language/string-and-char.md",childMarkdownRemark:{frontmatter:{title:"String & Char",order:20}}}},{node:{relativePath:"guide/language/variant.md",childMarkdownRemark:{frontmatter:{title:"Variant!",order:70}}}},{node:{relativePath:"guide/language/tuple.md",childMarkdownRemark:{frontmatter:{title:"Tuple",order:50}}}}]},file:{relativePath:"guide/ocaml.md",childMarkdownRemark:{html:'<p>If you come from OCaml or are a newcomer reading a tutorial written on OCaml, this guide\'s for you! But don\'t forget that <a href="https://github.com/reasonml/reason-tools">reason-tools</a> can convert between OCaml and Reason syntax on the fly.</p>\n<h3 id="comments"><a href="#comments" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Comments</h3>\n<table>\n<thead>\n<tr>\n<th>OCaml</th>\n<th>Reason</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>(* OCaml (*nest*) *)</code></td>\n<td><code>/* Reason /*nest*/ */</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id="operator-renaming"><a href="#operator-renaming" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Operator Renaming</h3>\n<p>Reason has all of OCaml\'s infix operators, but a couple of operators are expressed differently. In Reason, structural equality is written as <code>==</code>, and reference (physical) equality is written as <code>===</code>. In Reason, to achieve the corresponding inequality, simply swap the first character with a <code>!</code> character. (<code>!=</code> for structural inequality, and <code>!==</code> for reference inequality).</p>\n<table>\n<thead>\n<tr>\n<th>Equality</th>\n<th>OCaml</th>\n<th>Reason</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Structural</td>\n<td><code>x = y</code></td>\n<td><code>x == y</code></td>\n</tr>\n<tr>\n<td>Reference</td>\n<td><code>x == y</code></td>\n<td><code>x === y</code></td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>Inequality</th>\n<th>OCaml</th>\n<th>Reason</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Structural</td>\n<td><code>x &#x3C;> y</code></td>\n<td><code>x != y</code></td>\n</tr>\n<tr>\n<td>Reference</td>\n<td><code>x != y</code></td>\n<td><code>x !== y</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id="local-scope"><a href="#local-scope" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Local Scope</h3>\n<p>Reason\'s lexical scoping is exactly the same as OCaml\'s, but let bindings syntactically resemble "block scope" which is more familiar to many developers. In Reason, they are created with <code>{}</code> braces, which may contain both <code>let</code> bindings and imperative commands, separated by <code>;</code>. All blocks evaluate to the last line and the semicolon on the last line is optional. <code>{}</code> braces are only needed if you have more than one item to chain together via <code>;</code>.</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet _ =\n  let msg = "Hello" in\n  print_string msg;\n  let msg2 = "Goodbye" in\n  print_string msg2</pre>\n    </td>\n    <td>\n      <pre>\n{\n  let msg = "Hello";\n  print_string msg;\n  let msg2 = "Goodbye";\n  print_string msg2\n};</pre>\n    </td>\n  </tr>\n</table>\n<p>Reason\'s <code>{}</code> syntax removes many commonly reported pain points in OCaml\'s syntax:</p>\n<ul>\n<li>Double semicolons are removed entirely.</li>\n<li><code>begin</code>/<code>end</code> is removed entirely.</li>\n<li>Infamous imperative parsing <a href="https://github.com/ocaml/ocaml/pull/278">issues</a> are gone.</li>\n<li>Module bodies and local scope are unified.</li>\n</ul>\n<h3 id="local-scope-vs-module-body"><a href="#local-scope-vs-module-body" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Local Scope Vs. Module Body</h3>\n<p>In Reason, everything that can go between the <code>{}</code> in <a href="#local-scope">Local Scopes</a> and in module bodies. You can usually even cut/paste code between the two contexts. In OCaml, the syntaxes for the two contexts are very different. Local scope requires trailing <code>in</code>, but module bodies do not and some imperative statements must be assigned to <code>_</code> or <code>()</code>, or else use double <code>;;</code>.</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml Module Body</p></th><th scope="col"><p>Reason Module Body</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet ten = 10\nlet () = imperativeFunc ten ten\nlet () = imperativeFunc 0 0</pre>\n    </td>\n    <td>\n      <pre>\nlet ten = 10;\nimperativeFunc ten ten;\nimperativeFunc 0 0;</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nlet ten = 10;;\nimperativeFunc ten ten;;\nimperativeFunc 0 0;;</pre>\n    </td>\n    <td>Same as above</td>\n  </tr>\n  <thead><tr> <th scope="col"><p>OCaml Local Scope</p></th><th scope="col"><p>Reason Local Scope</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet ten = 10 in\nlet _ = imperativeFunc ten ten in\nimperativeFunc 0 0</pre>\n    </td>\n    <td>\n       same as above\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nlet ten = 10 in begin\n  imperativeFunc ten ten;\n  imperativeFunc 0 0\nend</pre>\n    </td>\n    <td>\n       same as above\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nlet ten = 10 in (\n  imperativeFunc ten ten;\n  imperativeFunc 0 0\n)</pre>\n    </td>\n    <td>\n       same as above\n    </td>\n  </tr>\n</table>\n<h3 id="tuple-and-record"><a href="#tuple-and-record" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tuple and Record</h3>\n<p>In Reason, tuples always require parentheses.</p>\n<table>\n<thead>\n<tr>\n<th>OCaml</th>\n<th>Reason</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>let tup = 4, 5</code></td>\n<td><code>let tup = (4, 5);</code></td>\n</tr>\n<tr>\n<td><code>let tup = ((1: int), (2:int))</code></td>\n<td><code>let tup = (1: int, 2:int);</code></td>\n</tr>\n<tr>\n<td><code>fun ((a: int), (b: int)) -> a</code></td>\n<td><code>fun (a: int, b: int) => a;</code></td>\n</tr>\n</tbody>\n</table>\n<p>In Reason, record values resemble JavaScript, using <code>:</code> instead of <code>=</code>. Because Reason tuples always require wrapping parens, records may contain lambdas as values without needing extra parens.</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet myRec = {x = 0; y = 10}</pre>\n    </td>\n    <td>\n      <pre>\nlet myRec = {x: 0, y: 10};</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nlet myFuncs = {\n  myFun = (fun x -> x + 1);\n  your = (fun a b -> a + b);\n}</pre>\n    </td>\n    <td>\n      <pre>\nlet myFuncs = {\n  myFun: fun x => x + 1,\n  your: fun a b => a + b\n};</pre>\n    </td>\n</table>\n<h3 id="lists"><a href="#lists" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lists</h3>\n<table>\n<thead>\n<tr>\n<th>OCaml</th>\n<th>Reason</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>let list = [1; 2; 3]</code></td>\n<td><code>let list = [1, 2, 3]</code></td>\n</tr>\n<tr>\n<td><code>let list = hd :: tl</code></td>\n<td><code>let list = [hd, ...tl];</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id="type-definitions"><a href="#type-definitions" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Type Definitions</h3>\n<table>\n<thead>\n<tr>\n<th>OCaml Tuple</th>\n<th>Reason Tuple</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>type tuple = int * int</code></td>\n<td><code>type tuple = (int, int);</code></td>\n</tr>\n<tr>\n<td><code>let tup: tuple = (10, 30)</code></td>\n<td><code>let tup: tuple = (10, 30);</code></td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>OCaml Record</th>\n<th>Reason Record</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>type r = {x: int; y: int}</code></td>\n<td><code>type r = {x: int, y: int};</code></td>\n</tr>\n<tr>\n<td><code>let myRec: r = {x = 0; y = 10}</code></td>\n<td><code>let myRec: r = {x: 0, y: 10};</code></td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>OCaml Function</th>\n<th>Reason Function</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>type func = int -> int</code></td>\n<td><code>type func = int => int;</code></td>\n</tr>\n<tr>\n<td><code>let x: func = fun a -> a + 1</code></td>\n<td><code>let x: func = fun a => a + 1;</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id="functions"><a href="#functions" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Functions</h3>\n<table>\n<thead>\n<tr>\n<th>OCaml</th>\n<th>Reason</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>let x a b = e</code></td>\n<td><code>let x a b => e;</code></td>\n</tr>\n<tr>\n<td><code>let x = fun a b -> e</code></td>\n<td><code>let x = fun a b => e;</code></td>\n</tr>\n<tr>\n<td><code>let x = fun a -> fun b -> e</code></td>\n<td><code>let x = fun a => fun b => e;</code></td>\n</tr>\n</tbody>\n</table>\n<h4 id="single-argument-match-functions"><a href="#single-argument-match-functions" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Single argument match functions</h4>\n<p>OCaml has a function definition (<code>function |</code>) which is considered to be\nequivalent of <code>function a -> match a with ...</code>. Reason has the same, but\nthe syntax makes it clear how it is actually an extension of a single argument\nfunction. The single case match is a natural extension of the simple lambda,\nand the multicase lambda is a natural extension of the single case lambda.</p>\n<table>\n  <thead><tr> <th scope="col"><p>Form</p></th><th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      lambda\n    </td>\n    <td>\n      <pre>\nfun pat -> e</pre>\n    </td>\n    <td>\n      <pre>\nfun pat => e</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      one match case\n    </td>\n    <td>\n      <pre>\nfunction | pat -> e</pre>\n    </td>\n    <td>\n      <pre>\nfun | pat => e</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      many cases\n    </td>\n    <td>\n      <pre>\nfunction | pat -> e\n         | pat2 -> e</pre>\n    </td>\n    <td>\n      <pre>\nfun | pat => e\n    | pat2 => e</pre>\n    </td>\n  </tr>\n</table>\n<h4 id="annotating-arguments"><a href="#annotating-arguments" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Annotating Arguments</h4>\n<p>In both Reason and OCaml, arguments are annotated with types by (as with\neverything else), wrapping them in parenthesis after appending\n<code>:typeAnnotation</code>.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> (arg<span class="hljs-params"> :<span class="hljs-params"> argType)<span class="hljs-params"> </span></span></span></span></span>=&gt; returnValue;</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> (arg<span class="hljs-params"> :<span class="hljs-params"> argType)<span class="hljs-params"> </span></span></span></span></span>=&gt; <span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> (arg2<span class="hljs-params"> :<span class="hljs-params"> arg2Type)<span class="hljs-params"> </span></span></span></span></span>=&gt; returnValue;</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> (arg<span class="hljs-params"> :<span class="hljs-params"> argType)<span class="hljs-params"> (arg2<span class="hljs-params"> :<span class="hljs-params"> arg2Type)<span class="hljs-params"> </span></span></span></span></span></span></span></span>=&gt; returnValue;</code></pre>\n      </div>\n<p>Both Reason and OCaml allow annotating the return type, when using the\n"super sugared let binding" form.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-ocaml"><code><span class="hljs-comment">(* OCaml *)</span>\n<span class="hljs-keyword">let</span> myFunc (a:<span class="hljs-built_in">int</span>) (b:<span class="hljs-built_in">int</span>) :<span class="hljs-built_in">int</span> * <span class="hljs-built_in">int</span> = (a, b)\n<span class="hljs-keyword">let</span> myFunc (a:<span class="hljs-built_in">int</span>) (b:<span class="hljs-built_in">int</span>) :<span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span> = [<span class="hljs-number">1</span>]\n<span class="hljs-keyword">let</span> myFunc (a:<span class="hljs-built_in">int</span>) (b:<span class="hljs-built_in">int</span>) :<span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> = <span class="hljs-keyword">fun</span> x -&gt; x + a + b</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-comment">/* Reason */</span>\n<span class="hljs-keyword">let</span> myFunc (a:int) (b:int) :(int, int) =&gt; (a, b);\n<span class="hljs-keyword">let</span> myFunc (a:int) (b:int) :list int =&gt; [<span class="hljs-number">1</span>];\n<span class="hljs-keyword">let</span> myFunc (a:int) (b:int) :(int =&gt; int) =&gt; <span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> x<span class="hljs-params"> </span></span></span>=&gt; x + a + b;</code></pre>\n      </div>\n<p>Because we\'re using <code>=></code> for all functions everywhere in Reason, there\'s\none case where we need to add extra parens around a return type that is\nitself a function type.</p>\n<h4 id="type-parameters"><a href="#type-parameters" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Type Parameters</h4>\n<h5 id="ocaml"><a href="#ocaml" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>OCaml</h5>\n<p>OCaml\'s type applications (think "generics"), are applied in reverse order.</p>\n<p>With OCaml, there are some unintuitive consequences of this.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-ocaml"><code><span class="hljs-keyword">let</span> x: <span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span> = [<span class="hljs-number">2</span>]\n\n<span class="hljs-keyword">type</span> listOfListOfInts = <span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span> <span class="hljs-built_in">list</span>\n\n<span class="hljs-comment">(* Parsed as: *)</span>\n<span class="hljs-keyword">type</span> listOfListOfInts = (<span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span>) <span class="hljs-built_in">list</span></code></pre>\n      </div>\n<p>Things get even more strange when type constructors accept multiple parameters.\nMultiple arguments require parenthesis and commas to separate type parameters,\nbut those parentheses don\'t represent tuples. The parentheses/comma form must\nalso be given when constructing type instances such as <code>(int, string) tuple</code>.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-ocaml"><code><span class="hljs-keyword">type</span> (<span class="hljs-symbol">\'a</span>, <span class="hljs-symbol">\'b</span>) tuple = <span class="hljs-symbol">\'a</span> * <span class="hljs-symbol">\'b</span>\n\n<span class="hljs-keyword">type</span> listOfTuplesOfStringAndInt = (<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>) tuple <span class="hljs-built_in">list</span>\n\n<span class="hljs-comment">(* Which is parsed as: *)</span>\n<span class="hljs-keyword">type</span> listOfTuplesOfStringAndInt = ((<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>) tuple) <span class="hljs-built_in">list</span>\n\n<span class="hljs-comment">(* Which allows a list of (tuples of (string and int)) *)</span>\n<span class="hljs-keyword">let</span> tuples: listOfTuplesOfStringAndInt = [(<span class="hljs-string">"asdf"</span>, <span class="hljs-number">3</span>)]</code></pre>\n      </div>\n<h5 id="reason"><a href="#reason" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reason</h5>\n<p>In summary, Reason unifies almost all of the syntax into simple "function\napplication" style meaning that type parameters follow the same space-separated\nlist pattern seen everywhere else in the syntax. As with everything else,\nparentheses may be used to enforce precedence. This results in fewer syntactic\npatterns to learn.</p>\n<p>For example, you can imagine <code>list</code> being a "function" for types that accepts a\ntype and returns a new type.</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet x: int list = [2]\ntype listOfListOfInts = int list list\ntype (\'a, \'b) tup = (\'a * \'b)\ntype pairs = (int, int) tup list\nlet tuples: pairs = [(2, 3)]</pre>\n    </td>\n    <td>\n      <pre>\nlet x: list int = [2];\ntype listOfListOfInts = list (list int);\ntype tup \'a \'b = (\'a, \'b);\ntype pairs = list (tup int int);\nlet tuples: pairs = [(2, 3)];</pre>\n    </td>\n  </tr>\n</table>\n<h3 id="tuples-as-type-parameters"><a href="#tuples-as-type-parameters" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tuples as Type Parameters</h3>\n<p>Because OCaml uses parens and commas to represent multiple arguments to type\nconstructors, it\'s confusing when one of the arguments to a type constructor is\nitself a tuple. In OCaml, it\'s difficult to remember the difference between a\ntype constructor accepting multiple arguments and a type constructor accepting\na single argument which happens to be a tuple.</p>\n<p>The following examples shows the difference between passing <em>two</em> type\nparameters to <code>pair</code>, and a <em>single</em> type parameter that happens to be a tuple.</p>\n<table>\n<thead>\n<tr>\n<th>OCaml</th>\n<th>Reason</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>type intPair = (int, int) pair</code></td>\n<td><code>type intPair = pair int int;</code></td>\n</tr>\n<tr>\n<td><code>type pairList = (int * int) list</code></td>\n<td><code>type pairList = list (int, int);</code></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>In Reason, syntax that represent tuple or tuple types, always looks like\ntuples.</li>\n<li>In Reason, syntax that represent records or record types, always look like\nrecords.</li>\n<li>Just about everything else uses the syntactic pattern of function application\n(space separated arguments).</li>\n</ul>\n<h3 id="variants"><a href="#variants" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Variants</h3>\n<h6 id="ocaml-1"><a href="#ocaml-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>OCaml</h6>\n<ul>\n<li>OCaml already expects constructor argument types to be specified in tuple\nform, so it\'s confusing when a single constructor expects a single argument\nthat <em>happens</em> to be a tuple type.</li>\n<li>What\'s even more confusing is that the constructors don\'t <em>actually</em> accept\ntuples, yet the syntax appear to resemble tuples.</li>\n<li>Sometimes the syntax for instantiating a constructor with multiple arguments\noverlaps the syntax for constructing a variant with a single argument that\nhappens to be a tuple - so it looks <em>exactly</em> like you <em>are</em> supplying a\ntuple when you are not actually supplying a tuple.</li>\n</ul>\n<h6 id="reason-1"><a href="#reason-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reason</h6>\n<ul>\n<li>Variant constructor types are expected to be listed as space separated lists,\nusing parenthesis to group precedence (as with <strong>everything</strong> else).</li>\n<li>Constructing instances of the variant (as you would have guessed) follows\nfunction application style (space separated lists).</li>\n<li>Tuples <strong>always</strong> <em>look</em> like tuples, and anything that looks like a tuple\n<em>is</em> a tuple.</li>\n</ul>\n<table>\n  <thead>\n    <tr>\n      <th scope="col">\n        <p>OCaml</p>\n      </th>\n      <th scope="col">\n        <p>Reason</p>\n      </th>\n    </tr>\n  </thead>\n  <tr>\n    <td>\n      <pre>\ntype myVariant =\n  | HasNothing\n  | HasSingleInt of int\n  | HasSingleTuple of (int * int)\n  | HasMultipleInts of int * int\n  | HasMultipleTuples of (int * int) * (int * int)\n      </pre>\n    </td>\n    <td>\n      <pre>\ntype myVariant =\n  | HasNothing\n  | HasSingleInt int\n  | HasSingleTuple (int, int)\n  | HasMultipleInts int int\n  | HasMultipleTuples (int, int) (int, int);\n      </pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nlet a = HasSingleInt 10\nlet a = HasSingleTuple (10, 10)\nlet a = HasMultipleInts (10, 10)\nlet a = HasMultipleTuples ((10, 10), (10, 10))\n      </pre>\n    </td>\n    <td>\n      <pre>\nlet a = HasSingleInt 10;\nlet a = HasSingleTuple (10, 10);\nlet a = HasMultipleInts 10 10;\nlet a = HasMultipleTuples (10, 10) (10, 10);\n      </pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nlet res = match x with\n  | HasNothing -> 0\n  | HasSingleInt x -> 0\n  | HasSingleTuple (x, y) -> 0\n  | HasMultipleInts (x, y) -> 0\n  | HasMultipleTuples ((x, y), (q, r)) -> 0\n      </pre>\n    </td>\n    <td>\n      <pre>\nlet res = switch x {\n| HasNothing => 0\n| HasSingleInt x => 0\n| HasSingleTuple (x, y) => 0\n| HasMultipleInts x y => 0\n| HasMultipleTuples (x, y) (q, r) => 0\n};\n      </pre>\n    </td>\n  </tr>\n</table>\n<h3 id="pattern-matching"><a href="#pattern-matching" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pattern Matching</h3>\n<p>Can you spot the error in the OCaml example? This is one of the most common mistakes among OCaml programmers. The second <code>match</code> <em>must</em> be wrapped in parentheses, otherwise the <code>Some</code> case is parsed as belonging to the outer <code>match</code>. Reason\'s required <code>{}</code> blocks around match cases prevent this issue.</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml (BROKEN)</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet res = match x with\n  | A (x, y) -> match y with\n    | None -> 0\n    | Some i -> 10\n  | B (x, y) -> 0</pre>\n    </td>\n    <td>\n      <pre>\nlet res = switch x {\n  | A (x, y) => switch y {\n    | None => 0\n    | Some i => 10\n  }\n  | B x y => 0\n};</pre>\n    </td>\n  </tr>\n</table>\n<h3 id="modules-and-signatures"><a href="#modules-and-signatures" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Modules and Signatures</h3>\n<h4 id="definition"><a href="#definition" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Definition</h4>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nmodule type MySig = sig\n  type t = int\n  val x: int\nend\nmodule MyModule: MySig = struct\n  type t = int\n  let x = 10\nend\nmodule MyModule = struct\n  module NestedModule = struct\n     let msg = "hello";\n  end\nend\n      </pre>\n    </td>\n    <td>\n      <pre>\nmodule type MySig = {\n  type t = int;\n  let x: int;\n};\nmodule MyModule: MySig = {\n  type t = int;\n  let x = 10;\n};\nmodule MyModule = {\n  module NestedModule = {\n     let msg = "hello";\n  };\n};\n      </pre>\n    </td>\n  </tr>\n</table>\n<h4 id="functors-types"><a href="#functors-types" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Functors Types</h4>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nmodule type FType =\n  functor (A: ASig) ->\n  functor (B: BSig) -> Result\n      </pre>\n    </td>\n    <td>\n      <pre>\nmodule type FType =\n  (A: ASig) =>\n  (B: BSig) => Result;\n      </pre>\n    </td>\n  </tr>\n</table>\n<h3 id="functors"><a href="#functors" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Functors</h3>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nmodule F =\n  functor (A: ASig) ->\n  functor (B: BSig) -> struct end</pre>\n    </td>\n    <td>\n      <pre>\nmodule F =\n  fun (A: ASig) =>\n  fun (B: BSig) => {};</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nmodule F = functor (A: ASig) (B: BSig) -> struct end</pre>\n    </td>\n    <td>\n      <pre>\nmodule F = fun (A: ASig) (B: BSig) => {};</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nmodule F (A: ASig) (B: BSig) = struct end</pre>\n    </td>\n    <td>\n      <pre>\nmodule F (A: ASig) (B: BSig) => {};</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nmodule Res = F(A)(B)</pre>\n    </td>\n    <td>\n      <pre>\nmodule Res = F A B;</pre>\n    </td>\n  </tr>\n</table>\n<p><strong>Note: There is currently a known inconsistency where functors do not\nconform to function application syntax when in type annotation position - see\n<a href="https://github.com/facebook/reason">the Reason repo\'s</a> <code>formatTest/modules.re</code>.</strong></p>\n<h3 id="various-improvements"><a href="#various-improvements" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Various Improvements</h3>\n<p>OCaml doesn\'t require parens around sequences <code>(a;b;c;d)</code> or tuples <code>(x,y)</code>, so\nthat ends up ruling out a bunch of other very convenient syntax rules.  Since\nReason always uses <code>{}</code> to enclose sequences or let bindings, and Reason\nalways requires <code>()</code> around tuples, many other syntax constructs are expressed\nmore intuitively, without requiring extra wrapping in parenthesis.</p>\n<h4 id="lambdas-as-record-fields-no-longer-need-extra-parens"><a href="#lambdas-as-record-fields-no-longer-need-extra-parens" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lambdas as record fields no longer need extra parens</h4>\n<p>This is a welcomed improvement because the OCaml type errors the user would\nsee were very confusing when it would believe the function\'s return value\nwas a tuple with infix <code>,</code> comma.</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet myFuncs = {\n  myFun = (fun x -> x + 1);\n  your = (fun a b -> a + b);\n}</pre>\n    </td>\n    <td>\n      <pre>\nlet myFuncs = {\n  myFun: fun x => x + 1,\n  your: fun a b => a + b\n}</pre>\n    </td>\n  </tr>\n</table>\n<h4 id="lambdas-as-match-results-no-longer-need-extra-parens"><a href="#lambdas-as-match-results-no-longer-need-extra-parens" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lambdas as match results no longer need extra parens</h4>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet x = match prnt with\n  | None -> fun a -> blah\n  (* Extra () required ! *)\n  | Some "_" -> (fun a -> ())\n  | Some "ml" -> blah\n      </pre>\n    </td>\n    <td>\n      <pre>\nlet x = switch prnt {\n| None => fun a => blah\n| Some "_" => fun a => ()\n| Some "ml" => blah\n};</pre>\n    </td>\n  </tr>\n</table>\n<h4 id="lambdas-and-type-annotations-in-tuples-no-longer-require-extra-parens"><a href="#lambdas-and-type-annotations-in-tuples-no-longer-require-extra-parens" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lambdas and type annotations in tuples no longer require extra parens</h4>\n<table>\n<thead>\n<tr>\n<th>OCaml</th>\n<th>Reason</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>let tuple = ((fun x -> x), 20)</code></td>\n<td><code>let tuple = (fun x => x, 20);</code></td>\n</tr>\n<tr>\n<td><code>let tuple = (("hi": string), (20: int))</code></td>\n<td><code>let tuple = ("hi": string, 20: int);</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id="various-differences"><a href="#various-differences" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Various Differences</h3>\n<h4 id="as-precedence"><a href="#as-precedence" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>as</code> precedence</h4>\n<p>With Reason, <code>as</code> has a higher precedence than <code>|</code> bar. This allows creating <code>as</code> aliases\nfor entire rows in pattern matching.</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet ppp = match MyThing 20 with\n  | (MyThing x as ppp)\n  | (YourThing x as ppp) -> ppp;\n      </pre>\n    </td>\n    <td>\n      <pre>\nlet ppp = switch (MyThing 20) {\n| MyThing x as ppp\n| YourThing x as ppp => ppp;\n};\n      </pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nlet | (MyThing _ as ppp)\n    | (YourThing _ as ppp) = ppp;</pre>\n    </td>\n    <td>\n      <pre>\nlet | MyThing _ as ppp\n    | YourThing _ as ppp = ppp;</pre>\n    </td>\n  </tr>\n</table>\n<h4 id="mutable-record-field-updates"><a href="#mutable-record-field-updates" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mutable Record Field Updates</h4>\n<p>Because equalities and their negations have been made more consistent in Reason,\nthe <code>=</code> operator is available for mutable field update.</p>\n<table>\n<thead>\n<tr>\n<th>OCaml</th>\n<th>Reason</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>myRec.field &#x3C;- "next"</code></td>\n<td><code>myRec.field = "next"</code></td>\n</tr>\n</tbody>\n</table>\n<h4 id="prefix-operators"><a href="#prefix-operators" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Prefix operators</h4>\n<p>In Reason, <code>!</code> and other prefix operators have lower precedence than dot <code>.</code> or send <code>#</code>.\nThis is more consistent with what other languages do, and is more practical\nwhen (or if) the <code>!</code> symbol is used to represent boolean <code>not</code>.</p>\n<table>\n<thead>\n<tr>\n<th>OCaml</th>\n<th>Reason</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>let x = !(foo.bar)</code></td>\n<td><code>let x = !foo.bar;</code></td>\n</tr>\n<tr>\n<td><code>let x = !(foo#bar)</code></td>\n<td><code>let x = !foo#bar;</code></td>\n</tr>\n<tr>\n<td><code>let x = !(!foo.bar)</code></td>\n<td><code>let x = !(!foo).bar;</code></td>\n</tr>\n<tr>\n<td><code>let x = !(!foo#bar)</code></td>\n<td><code>let x = !(!foo)#bar;</code></td>\n</tr>\n<tr>\n<td><code>let x = !(!(foo.bar))</code></td>\n<td><code>let x = !(!foo.bar);</code></td>\n</tr>\n<tr>\n<td><code>let x = !(!(foo#bar))</code></td>\n<td><code>let x = !(!foo#bar);</code></td>\n</tr>\n<tr>\n<td><code>let x = !!(foo.bar)</code></td>\n<td><code>let x = !!foo.bar;</code></td>\n</tr>\n<tr>\n<td><code>let x = !!(foo#bar)</code></td>\n<td><code>let x = !!foo#bar;</code></td>\n</tr>\n<tr>\n<td><code>let x = !~(foo.bar)</code></td>\n<td><code>let x = !~foo.bar;</code></td>\n</tr>\n<tr>\n<td><code>let x = !~(foo#bar)</code></td>\n<td><code>let x = !~foo#bar;</code></td>\n</tr>\n</tbody>\n</table>\n<h4 id="comment-escaping"><a href="#comment-escaping" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Comment Escaping</h4>\n<p>Because Reason uses C-style comments, some obscure custom prefix/infix\noperators must be written differently.  The rules for prefix/infix operators\nare the same as in OCaml syntax, but with the following exceptions:</p>\n<p>Specifically, if any character except the first in an prefix/infix operator is\na star or forward slash, that must be first escaped with a backslash. These will\nbe parsed <em>without</em> the backslash when added to the AST. When reprinted, the\nescape backslashes are added back in automatically.</p>\n<table>\n<thead>\n<tr>\n<th>OCaml</th>\n<th>Reason</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>let (/*) a b = a + b</code></td>\n<td><code>let (/\\*) a b => a + b;</code></td>\n</tr>\n<tr>\n<td><code>let x = 12 /-* 23 /-* 12</code></td>\n<td><code>let x = 12 /-\\* 23 /-\\* 12;</code></td>\n</tr>\n<tr>\n<td><code>let y = (/*) a b</code></td>\n<td><code>let y = (/\\*) a b;</code></td>\n</tr>\n<tr>\n<td><code>let (!=*) q r => q + r</code></td>\n<td><code>let (!=\\*) q r => q + r;</code></td>\n</tr>\n<tr>\n<td><code>let res = q (!=*) r</code></td>\n<td><code>let res = q (!=\\*) r;</code></td>\n</tr>\n<tr>\n<td><code>let (!=/*) q r = q + r</code></td>\n<td><code>let (!=\\/\\*) q r => q + r;</code></td>\n</tr>\n<tr>\n<td><code>let res = q (!=/*) r</code></td>\n<td><code>let res = q (!=\\/\\*) r;</code></td>\n</tr>\n</tbody>\n</table>\n<h4 id="operator-renaming-1"><a href="#operator-renaming-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Operator Renaming</h4>\n<p>If Reason uses <code>==</code> to represent OCaml\'s <code>=</code>, and\nuses <code>===</code> to represent OCaml\'s <code>==</code>, then how would Reason represent OCaml\'s\n<code>===</code> symbol (if it were defined)? Reason provides a way! "Escape" the triple\nequals symbol!</p>\n<table>\n<thead>\n<tr>\n<th>Identifier</th>\n<th>Meaning</th>\n<th>OCaml</th>\n<th>Reason</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>"==="</code></td>\n<td>Custom value</td>\n<td><code>x === y</code></td>\n<td><code>x \\=== y</code></td>\n</tr>\n</tbody>\n</table>\n<h4 id="repl"><a href="#repl" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>REPL</h4>\n<p>In Reason\'s repl <a href="/guide/editor-tools/extra-goodies#repl"><code>rtop</code></a> (a customized <a href="https://github.com/diml/utop"><code>utop</code></a>), each input is submitted via a single <code>;</code> semicolon. OCaml\'s repl requires two semicolons <code>;;</code>.</p>\n<table>\n<thead>\n<tr>\n<th>OCaml</th>\n<th>Reason</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>;;</code></td>\n<td><code>;</code></td>\n</tr>\n</tbody>\n</table>',
frontmatter:{title:"Comparison to OCaml"}}}},pathContext:{section:"guide",sectionTitle:"Guide",relativePath:"guide/ocaml.md",relatedFiles:"/^guide\\/.*\\.md$/"}}}});
//# sourceMappingURL=path---guide-ocaml-9f4b704be1645132a8ab.js.map