webpackJsonp([29],{"./node_modules/json-loader/index.js!./.cache/json/ru-guide-language-module.json":function(s,e){s.exports={data:{allFile:{edges:[{node:{relativePath:"ru/guide/examples.md",childMarkdownRemark:{frontmatter:{title:"Примеры",order:60}}}},{node:{relativePath:"ru/guide/index.md",childMarkdownRemark:{frontmatter:{title:"Гайд по Reason",order:0}}}},{node:{relativePath:"ru/guide/ocaml.md",childMarkdownRemark:{frontmatter:{title:"Comparison to OCaml",order:50}}}},{node:{relativePath:"ru/guide/what-and-why.md",childMarkdownRemark:{frontmatter:{title:"Что и Зачем",order:0}}}},{node:{relativePath:"ru/guide/editor-tools/editors-plugins.md",childMarkdownRemark:{frontmatter:{title:"Плагины редактора",order:20}}}},{node:{relativePath:"ru/guide/editor-tools/extra-goodies.md",childMarkdownRemark:{frontmatter:{title:"Дополнительные бонусы",order:30}}}},{node:{relativePath:"ru/guide/editor-tools/index.md",childMarkdownRemark:{frontmatter:{title:"Настройка редактора",order:10}}}},{node:{relativePath:"ru/guide/editor-tools/global-installation.md",childMarkdownRemark:{frontmatter:{title:"Глобальная установка",order:10}}}},{node:{relativePath:"ru/guide/javascript/converting.md",childMarkdownRemark:{frontmatter:{title:"Перенос JS кода",order:5}}}},{node:{relativePath:"ru/guide/javascript/quickstart.md",childMarkdownRemark:{frontmatter:{title:"Быстрый старт",order:0}}}},{node:{relativePath:"ru/guide/javascript/index.md",childMarkdownRemark:{frontmatter:{title:"JavaScript",order:30}}}},{node:{relativePath:"ru/guide/javascript/libraries.md",childMarkdownRemark:{frontmatter:{title:"Библиотеки",order:2}}}},{node:{relativePath:"ru/guide/javascript/interop.md",childMarkdownRemark:{frontmatter:{title:"Взаимодействие",order:1}}}},{node:{relativePath:"ru/guide/language/exception.md",childMarkdownRemark:{frontmatter:{title:"Исключения",order:175}}}},{node:{relativePath:"ru/guide/language/boolean.md",childMarkdownRemark:{frontmatter:{title:"Булев",order:30}}}},{node:{relativePath:"ru/guide/javascript/syntax-cheatsheet.md",childMarkdownRemark:{frontmatter:{title:"Шпаргалка по синтаксису",order:1}}}},{node:{relativePath:"ru/guide/language/destructuring.md",childMarkdownRemark:{frontmatter:{title:"Деструктурирование",order:130}}}},{node:{relativePath:"ru/guide/language/imperative-loops.md",childMarkdownRemark:{frontmatter:{title:"Императивные циклы",order:150}}}},{node:{relativePath:"ru/guide/language/if-else.md",childMarkdownRemark:{frontmatter:{title:"If-Else",order:110}}}},{node:{relativePath:"ru/guide/language/external.md",childMarkdownRemark:{frontmatter:{title:"External",order:170}}}},{node:{relativePath:"ru/guide/language/index.md",childMarkdownRemark:{frontmatter:{title:"Основы языка",order:20}}}},{node:{relativePath:"ru/guide/language/function.md",childMarkdownRemark:{frontmatter:{title:"Функция",order:100}}}},{node:{relativePath:"ru/guide/language/integer-and-float.md",childMarkdownRemark:{frontmatter:{title:"Числа",order:40}}}},{node:{relativePath:"ru/guide/language/let-binding.md",childMarkdownRemark:{frontmatter:{title:"Let привязка",order:10}}}},{node:{relativePath:"ru/guide/language/list-and-array.md",childMarkdownRemark:{frontmatter:{title:"Список и Массив",order:80}}}},{node:{relativePath:"ru/guide/language/jsx.md",childMarkdownRemark:{frontmatter:{title:"JSX",order:160}}}},{node:{relativePath:"ru/guide/language/module.md",childMarkdownRemark:{frontmatter:{title:"Модуль",order:180}}}},{node:{relativePath:"ru/guide/language/mutation.md",childMarkdownRemark:{frontmatter:{title:"Мутации",order:140}}}},{node:{relativePath:"ru/guide/language/object.md",childMarkdownRemark:{frontmatter:{title:"Объект",order:175}}}},{node:{relativePath:"ru/guide/language/overview.md",childMarkdownRemark:{frontmatter:{title:"Обзор",order:0}}}},{node:{relativePath:"ru/guide/language/more-on-type.md",childMarkdownRemark:{frontmatter:{title:"Больше о типах",order:120}}}},{node:{relativePath:"ru/guide/language/string-and-char.md",childMarkdownRemark:{frontmatter:{title:"Строка и символ",order:20}}}},{node:{relativePath:"ru/guide/language/record.md",childMarkdownRemark:{frontmatter:{title:"Запись",order:60}}}},{node:{relativePath:"ru/guide/language/pattern-matching.md",childMarkdownRemark:{frontmatter:{title:"Паттерн-матчинг",order:135}}}},{node:{relativePath:"ru/guide/language/tuple.md",childMarkdownRemark:{frontmatter:{title:"Кортеж",order:50}}}},{node:{relativePath:"ru/guide/language/type.md",childMarkdownRemark:{frontmatter:{title:"Тип!",order:15}}}},{node:{relativePath:"ru/guide/native/convert-from-ocaml.md",childMarkdownRemark:{frontmatter:{title:"Converting from OCaml",order:4}}}},{node:{relativePath:"ru/guide/language/variant.md",childMarkdownRemark:{frontmatter:{title:"Вариант!",order:70}}}},{node:{relativePath:"ru/guide/native/index.md",childMarkdownRemark:{frontmatter:{title:"Native",order:40}}}},{node:{relativePath:"ru/guide/native/quickstart.md",childMarkdownRemark:{frontmatter:{title:"Quickstart",order:0}}}}]},file:{relativePath:"ru/guide/language/module.md",childMarkdownRemark:{html:'<h3 id="Базовые-сведения"><a href="#%D0%91%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B5-%D1%81%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Базовые сведения</h3>\n<p><strong>Модели похожи на мини файлы</strong>! Они могут содержать объявления типов, <code>let</code> привязки,\nвложенные модули и так далее.</p>\n<h4 id="Создание"><a href="#%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Создание</h4>\n<p>Для создания используйте ключевое слово <code>module</code>. Имя модуля должно начинаться с заглавной\nбуквы. Все что вы обычно можете поместить в файл <code>.re</code>, вы можете поместить и в тело\nмодуля внутри фигурных скобок.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">School</span> = </span>{\n  <span class="hljs-keyword">type</span> profession = <span class="hljs-type">Teacher</span> | <span class="hljs-type">Director</span>;\n\n  <span class="hljs-keyword">let</span> person1 = <span class="hljs-type">Teacher</span>;\n  <span class="hljs-keyword">let</span> getProfession person =&gt;\n    <span class="hljs-keyword">switch</span> person {\n    | <span class="hljs-type">Teacher</span> =&gt; <span class="hljs-string">"A teacher"</span>\n    | <span class="hljs-type">Director</span> =&gt; <span class="hljs-string">"A director"</span>\n    };\n};</code></pre>\n      </div>\n<p>Содержимое модуля (включая типы) может быть доступно с использованием точки. Это делает\nмодули удобным инструментом для создания пространства имен.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> anotherPerson: <span class="hljs-type">School</span>.profession = <span class="hljs-type">School</span>.<span class="hljs-type">Teacher</span>;\nprint_endline (<span class="hljs-type">School</span>.getProfession anotherPerson); <span class="hljs-comment">/* "A teacher" */</span></code></pre>\n      </div>\n<p>Вложенные модули работают так же:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">MyModule</span> = </span>{\n  <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">NestedModule</span> = </span>{\n     <span class="hljs-keyword">let</span> message = <span class="hljs-string">"hello"</span>;\n  };\n};\n\n<span class="hljs-keyword">let</span> message = <span class="hljs-type">MyModule</span>.<span class="hljs-type">NestedModule</span>.message;</code></pre>\n      </div>\n<h4 id="Открытие-open-модуля"><a href="#%D0%9E%D1%82%D0%BA%D1%80%D1%8B%D1%82%D0%B8%D0%B5-open-%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Открытие (<code>open</code>) модуля</h4>\n<p>Иногда неудобно постоянно ссылаться на имя модуля при обращении к типу/переменной.\nМы можем открыть модуль и начать ссылаться на содержимое напрямую. Есть два способа это\nсделать.</p>\n<p>Локальное открытие:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> message =\n  <span class="hljs-type">School</span>.(\n    <span class="hljs-keyword">switch</span> person1 {\n    | <span class="hljs-type">Teacher</span> =&gt; <span class="hljs-string">"Hello teacher!"</span>\n    | <span class="hljs-type">Director</span> =&gt; <span class="hljs-string">"Hello director!"</span>\n    }\n  );</code></pre>\n      </div>\n<p>Глобальное открытие. <strong>Используйте аккуратно, потому как это уменьшает удобство чтения</strong>:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code>open <span class="hljs-type">School</span>;\n<span class="hljs-keyword">let</span> anotherPerson: profession = <span class="hljs-type">Teacher</span>;\nprintProfession anotherPerson;</code></pre>\n      </div>\n<h4 id="Расширение-моделей"><a href="#%D0%A0%D0%B0%D1%81%D1%88%D0%B8%D1%80%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D0%B5%D0%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Расширение моделей</h4>\n<p>Используя <code>include</code> можно добавить содержимое одного модуля к другому. Это часто играет роль\nнаследования или миксинов.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">BaseComponent</span> = </span>{\n  <span class="hljs-keyword">let</span> defaultGreeting = <span class="hljs-string">"Hello"</span>;\n  <span class="hljs-keyword">let</span> getAudience ::excited =&gt; excited ? <span class="hljs-string">"world!"</span> : <span class="hljs-string">"world"</span>;\n};\n\n<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">ActualComponent</span> = </span>{\n  <span class="hljs-comment">/* the content is copied over */</span>\n  <span class="hljs-keyword">include</span> <span class="hljs-type">BaseComponent</span>;\n  <span class="hljs-comment">/* overrides BaseComponent.defaultGreeting */</span>\n  <span class="hljs-keyword">let</span> defaultGreeting = <span class="hljs-string">"Hey"</span>;\n  <span class="hljs-keyword">let</span> render () =&gt; defaultGreeting ^ <span class="hljs-string">" "</span> ^ getAudience excited::<span class="hljs-literal">true</span>;\n};</code></pre>\n      </div>\n<p><strong>Важно</strong>: <code>include</code> и <code>open</code> совершенно различны. Первый буквально копирует содержимое внутрь\nнового модуля, а второй позволяет ссылаться на содержимое открываемого модуля без указания\nимени (то есть <code>foo</code> вместо <code>MyModule.foo</code>).</p>\n<h4 id="Каждый-re-файл-является-модулем"><a href="#%D0%9A%D0%B0%D0%B6%D0%B4%D1%8B%D0%B9-re-%D1%84%D0%B0%D0%B9%D0%BB-%D1%8F%D0%B2%D0%BB%D1%8F%D0%B5%D1%82%D1%81%D1%8F-%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D0%B5%D0%BC" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Каждый <code>.re</code> файл является модулем</h4>\n<p>В OCaml/Reason файл является модулем, что дает интересную выразительность, которая требовала\nбы генерации кода в других языках. Файл <code>react.re</code> неявно формирует модуль <code>React</code>, который\nможет использоваться в других файлах.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-comment">/* fileA.re. This typically compiles to module FileA below */</span>\n<span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;\n<span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>;\n\n<span class="hljs-comment">/* fileB.re */</span>\n<span class="hljs-comment">/* Maps fileA\'s implementation to a new API */</span>\n<span class="hljs-keyword">let</span> alpha = <span class="hljs-type">FileA</span>.a;\n<span class="hljs-keyword">let</span> beta = <span class="hljs-type">FileA</span>.b;</code></pre>\n      </div>\n<p>Пример "копирования файла":</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-comment">/* fileA.re. This typically compiles to module FileA below */</span>\n<span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;\n<span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>;\n\n<span class="hljs-comment">/* fileB.re */</span>\n<span class="hljs-comment">/* compiles to exactly fileA.re\'s content with no runtime overhead! */</span>\n<span class="hljs-keyword">include</span> <span class="hljs-type">FileA</span>;</code></pre>\n      </div>\n<h2 id="Сигнатуры"><a href="#%D0%A1%D0%B8%D0%B3%D0%BD%D0%B0%D1%82%D1%83%D1%80%D1%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Сигнатуры</h2>\n<p>Тип модуля называет сигнатурой и может быть записан явно.</p>\n<h4 id="Создание-1"><a href="#%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Создание</h4>\n<p>Для создания сигнатуры используйте ключевое слово <code>module type</code>. Имя сигнатуры должно начинаться\nс заглавной буквы.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-comment">/* Picking up previous section\'s example */</span>\n<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">type</span> <span class="hljs-title">EstablishmentType</span> = </span>{\n  <span class="hljs-keyword">type</span> profession;\n  <span class="hljs-keyword">let</span> getProfession: profession =&gt; string;\n};</code></pre>\n      </div>\n<p>Сигнатура определяет список требований, которым модуль должен соответствовать для того, чтобы\nподходить под сигнатуру. Эти требования бывают следующих видов:</p>\n<ul>\n<li>\n<p><code>let x: int;</code> требует <code>let</code> привязку с именем <code>x</code> типа <code>int</code>.</p>\n</li>\n<li>\n<p><code>type t = someType;</code> требует, чтобы тип <code>t</code> был равен типу <code>someType</code>.</p>\n</li>\n<li>\n<p><code>type t;</code> требует наличия типа <code>t</code>, но без указания что это за тип конкретно.\nМы используем <code>t</code> для того, чтобы описать взаимодействия, например<code>let makePair: t -> (t, t)</code>. Но мы не предполагаем, что <code>t</code> это <code>int</code>. Это дает нам хорошие возможности для абстракции.</p>\n</li>\n</ul>\n<p>Для демонстрации различных элементов сигнатуры, возьмем следующую сигнатуру\n<code>EstablishmentType</code> которая требует от модуля:</p>\n<ul>\n<li>Объявить тип <code>profession</code></li>\n<li>Иметь функцию, которая принимает тип <code>profession</code> и возвращает строку</li>\n</ul>\n<p><strong>Важно</strong>:</p>\n<p>Модули типа <code>EstablishmentType</code> могут содержать больше полей, чем указано в\nсигнатуре, как в случае с модулем <code>School</code> в предыдущей секции (если бы мы\nуказали ему тип <code>EstablishmentType</code>, в обратном случае модуль <code>School</code>\nделал все поля доступными снаружи). Это эффективно делает поле <code>person1</code>\nдеталью реализации. Внешний код не имеет у к нему доступ, так как его описания\nнет в сигнатуре. Сигнатура <strong>ограничивает</strong> доступ из вне.</p>\n<p>Тип <code>EstablishmentType.profession</code> является <strong>абстрактным</strong>: он не является\nконкретным типом. Он говорит "мне не важно какой это тип, но именно он используется\nкак входной параметр в <code>getProfession</code>". Это удобно для реализации нескольких\nмодулей под одним интерфейсом.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Company</span>: <span class="hljs-title">EstablishmentType</span> = </span>{\n  <span class="hljs-keyword">type</span> profession = <span class="hljs-type">CEO</span> | <span class="hljs-type">Designer</span> | <span class="hljs-type">Engineer</span> | ...;\n\n  <span class="hljs-keyword">let</span> getProfession person =&gt; ...\n  <span class="hljs-keyword">let</span> person1 = ...;\n  <span class="hljs-keyword">let</span> person2 = ...;\n};</code></pre>\n      </div>\n<p>Это также полезно для того, чтобы спрятать внутренний тип как делать реализации\nот внешнего кода. Если вы спросите систему типов, что за тип у\n<code>Company.profession</code> то вместо того, чтобы показать вариант, она скажет только\n"это <code>Company.profession</code>".</p>\n<h4 id="Каждый-rei-файл-является-сигнатурой"><a href="#%D0%9A%D0%B0%D0%B6%D0%B4%D1%8B%D0%B9-rei-%D1%84%D0%B0%D0%B9%D0%BB-%D1%8F%D0%B2%D0%BB%D1%8F%D0%B5%D1%82%D1%81%D1%8F-%D1%81%D0%B8%D0%B3%D0%BD%D0%B0%D1%82%D1%83%D1%80%D0%BE%D0%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Каждый <code>.rei</code> файл является сигнатурой</h4>\n<p>Так же как <code>react.re</code> неявно объявляет модуль <code>React</code>, файл\n<code>react.rei</code> неявно объявляет сигнатуру для <code>React</code>. Если <code>react.rei</code> не\nпредоставлен, то сигнатура <code>react.re</code> по умолчанию делает видимыми все поля\nмодуля. Так как они не содержат деталей реализации, то файлы <code>.rei</code>\nиспользуются как документация к публичным API соответствующих модулей.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-comment">/* файл react.re (реализация. Комрилируется в модуль React) */</span>\n<span class="hljs-keyword">type</span> state = int;\n<span class="hljs-keyword">let</span> render = <span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> str<span class="hljs-params"> </span></span></span>=&gt; str;</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-comment">/* file react.rei (интерфейс. Компилируется в сигнатуру модуля React) */</span>\n<span class="hljs-keyword">type</span> state = int;\n<span class="hljs-keyword">let</span> render: str =&gt; str;</code></pre>\n      </div>\n<h2 id="Функции-модулей-функторы"><a href="#%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D0%B5%D0%B9-%D1%84%D1%83%D0%BD%D0%BA%D1%82%D0%BE%D1%80%D1%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Функции модулей (функторы)</h2>\n<p>Модули могут быть переданы в функции! Однако модули представляют собой\nотдельный "слой" языка, поэтому мы не можем передавать их в <em>обычные</em>\nфункции. И вместо этого мы передаем их в специальные функции, называемые\n"функторами".</p>\n<p>Синтаксис для объявления и использования функторов поход на синтаксис\nобычных функций. Основные отличия:</p>\n<ul>\n<li>Функторы используют ключевое слово<code>module</code> вместо <code>let</code> и <code>fun</code>\n(в данном случае fun можно читать как functor)</li>\n<li>Функтор принимает модуль как аргумент и возвращает модуль</li>\n<li>Функторы <em>требуют</em> аннотации аргументов</li>\n<li>Имя функтора должно начинаться с заглавной буквы</li>\n</ul>\n<p>Фот пример функтора <code>MakeSet</code> который получаем модуль типа <code>Comparable</code>\nи возвращает набор (set) который может содержать элементы типа-аргумента.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">type</span> <span class="hljs-title">Comparable</span> = </span>{\n  <span class="hljs-keyword">type</span> t;\n  <span class="hljs-keyword">let</span> <span class="hljs-built_in">equal</span>: t =&gt; t =&gt; bool;\n};\n\n<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">MakeSet</span> = <span class="hljs-title">fun</span> (<span class="hljs-title">Item</span>: <span class="hljs-title">Comparable</span>) =&gt; </span>{\n  <span class="hljs-comment">/* список используется как структура для хранения */</span>\n  <span class="hljs-keyword">type</span> backingType = list <span class="hljs-type">Item</span>.t;\n  <span class="hljs-keyword">let</span> empty = [];\n  <span class="hljs-keyword">let</span> add (currentSet: backingType) (newItem: <span class="hljs-type">Item</span>.t) :backingType =&gt;\n    <span class="hljs-comment">/* если элемент существует */</span>\n    <span class="hljs-keyword">if</span> (<span class="hljs-type">List</span>.exists (<span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> x<span class="hljs-params"> </span></span></span>=&gt; <span class="hljs-type">Item</span>.<span class="hljs-built_in">equal</span> x newItem) currentSet) {\n      currentSet <span class="hljs-comment">/* возвращаем тот же список */</span>\n    } <span class="hljs-keyword">else</span> {\n      [newItem, ...currentSet]; <span class="hljs-comment">/* добавляем в начало и возвращаем */</span>\n    }\n};</code></pre>\n      </div>\n<p>Функторы применяются с помощью с помощью синтаксиса похожего на применение\nфункции.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">IntPair</span> = </span>{\n  <span class="hljs-keyword">type</span> t = (int, int);\n  <span class="hljs-keyword">let</span> <span class="hljs-built_in">equal</span> (x1, y1) (x2, y2) =&gt; x1 == x2 &amp;&amp; y1 == y2;\n  <span class="hljs-keyword">let</span> create x y =&gt; (x, y);\n};\n\n<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">SetOfIntPairs</span> = <span class="hljs-title">MakeSet</span> <span class="hljs-title">IntPair</span>;</span></code></pre>\n      </div>\n<h4 id="Типы-функторов"><a href="#%D0%A2%D0%B8%D0%BF%D1%8B-%D1%84%D1%83%D0%BD%D0%BA%D1%82%D0%BE%D1%80%D0%BE%D0%B2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Типы функторов</h4>\n<p>Как и с типами модулей, типы функторов так же нужны для ограничения\nтого, что мы можем знать о внутренностях функтора. Тип похож на типы\nфункций, только с заглавными именами, представляющими сигнатуры модулей,\nкоторый функтор принимает и возвращаемого модуля. В предыдущем примере\nмы выставляли на показ внутренний тип (List). Дав <code>MakeSet</code> сигнатуру,\nмы можем спрятать внутреннюю структуру.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">type</span> <span class="hljs-title">Comparable</span> = ...\n\n<span class="hljs-title">module</span> <span class="hljs-title">type</span> <span class="hljs-title">MakeSetType</span> = (<span class="hljs-title">Item</span>: <span class="hljs-title">Comparable</span>) =&gt; </span>{\n  <span class="hljs-keyword">type</span> backingType;\n  <span class="hljs-keyword">let</span> empty: backingType;\n  <span class="hljs-keyword">let</span> add: backingType =&gt; <span class="hljs-type">Item</span>.t =&gt; backingType;\n};\n\n<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">MakeSet</span>: <span class="hljs-title">MakeSetType</span> = <span class="hljs-title">fun</span> (<span class="hljs-title">Item</span>: <span class="hljs-title">Comparable</span>) =&gt; </span>{\n  ...\n};</code></pre>\n      </div>\n<h2 id="Недостатки"><a href="#%D0%9D%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D1%82%D0%BA%D0%B8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Недостатки</h2>\n<p>Модули и функторы являются отдельным "слоем" языка, в отличии от остальных\nчастей (функций, биндингов, структур данных, и так далее). Например, вы\nне можете передать их в кортеж или запись. Используйте их с умом. В\nбольшинстве случаев просто записи или функции будет достаточно.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">School</span> = </span>{...};\n\n<span class="hljs-comment">/* Ошибка синтаксиса! */</span>\n<span class="hljs-keyword">let</span> schools = (<span class="hljs-type">School</span>, <span class="hljs-type">School</span>);</code></pre>\n      </div>',frontmatter:{title:"Модуль"}}}},pathContext:{section:"ru/guide",sectionTitle:"Guide",relativePath:"ru/guide/language/module.md",relatedFiles:"/^ru\\/guide\\/.*\\.md$/"}}}});
//# sourceMappingURL=path---ru-guide-language-module-6d485bf5e544caf85613.js.map