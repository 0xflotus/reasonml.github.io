webpackJsonp([28],{"./node_modules/json-loader/index.js!./.cache/json/ru-guide-language-more-on-type.json":function(e,a){e.exports={data:{allFile:{edges:[{node:{relativePath:"ru/guide/examples.md",childMarkdownRemark:{frontmatter:{title:"Примеры",order:60}}}},{node:{relativePath:"ru/guide/index.md",childMarkdownRemark:{frontmatter:{title:"Гайд по Reason",order:0}}}},{node:{relativePath:"ru/guide/ocaml.md",childMarkdownRemark:{frontmatter:{title:"Comparison to OCaml",order:50}}}},{node:{relativePath:"ru/guide/what-and-why.md",childMarkdownRemark:{frontmatter:{title:"Что и Зачем",order:0}}}},{node:{relativePath:"ru/guide/editor-tools/editors-plugins.md",childMarkdownRemark:{frontmatter:{title:"Плагины редактора",order:20}}}},{node:{relativePath:"ru/guide/editor-tools/extra-goodies.md",childMarkdownRemark:{frontmatter:{title:"Дополнительные бонусы",order:30}}}},{node:{relativePath:"ru/guide/editor-tools/index.md",childMarkdownRemark:{frontmatter:{title:"Настройка редактора",order:10}}}},{node:{relativePath:"ru/guide/editor-tools/global-installation.md",childMarkdownRemark:{frontmatter:{title:"Глобальная установка",order:10}}}},{node:{relativePath:"ru/guide/javascript/converting.md",childMarkdownRemark:{frontmatter:{title:"Перенос JS кода",order:5}}}},{node:{relativePath:"ru/guide/javascript/quickstart.md",childMarkdownRemark:{frontmatter:{title:"Быстрый старт",order:0}}}},{node:{relativePath:"ru/guide/javascript/index.md",childMarkdownRemark:{frontmatter:{title:"JavaScript",order:30}}}},{node:{relativePath:"ru/guide/javascript/libraries.md",childMarkdownRemark:{frontmatter:{title:"Библиотеки",order:2}}}},{node:{relativePath:"ru/guide/javascript/interop.md",childMarkdownRemark:{frontmatter:{title:"Взаимодействие",order:1}}}},{node:{relativePath:"ru/guide/language/exception.md",childMarkdownRemark:{frontmatter:{title:"Исключения",order:175}}}},{node:{relativePath:"ru/guide/language/boolean.md",childMarkdownRemark:{frontmatter:{title:"Булев",order:30}}}},{node:{relativePath:"ru/guide/javascript/syntax-cheatsheet.md",childMarkdownRemark:{frontmatter:{title:"Шпаргалка по синтаксису",order:1}}}},{node:{relativePath:"ru/guide/language/destructuring.md",childMarkdownRemark:{frontmatter:{title:"Деструктурирование",order:130}}}},{node:{relativePath:"ru/guide/language/imperative-loops.md",childMarkdownRemark:{frontmatter:{title:"Императивные циклы",order:150}}}},{node:{relativePath:"ru/guide/language/if-else.md",childMarkdownRemark:{frontmatter:{title:"If-Else",order:110}}}},{node:{relativePath:"ru/guide/language/external.md",childMarkdownRemark:{frontmatter:{title:"External",order:170}}}},{node:{relativePath:"ru/guide/language/index.md",childMarkdownRemark:{frontmatter:{title:"Основы языка",order:20}}}},{node:{relativePath:"ru/guide/language/function.md",childMarkdownRemark:{frontmatter:{title:"Функция",order:100}}}},{node:{relativePath:"ru/guide/language/integer-and-float.md",childMarkdownRemark:{frontmatter:{title:"Числа",order:40}}}},{node:{relativePath:"ru/guide/language/let-binding.md",childMarkdownRemark:{frontmatter:{title:"Let привязка",order:10}}}},{node:{relativePath:"ru/guide/language/list-and-array.md",childMarkdownRemark:{frontmatter:{title:"Список и Массив",order:80}}}},{node:{relativePath:"ru/guide/language/jsx.md",childMarkdownRemark:{frontmatter:{title:"JSX",order:160}}}},{node:{relativePath:"ru/guide/language/module.md",childMarkdownRemark:{frontmatter:{title:"Модуль",order:180}}}},{node:{relativePath:"ru/guide/language/mutation.md",childMarkdownRemark:{frontmatter:{title:"Мутации",order:140}}}},{node:{relativePath:"ru/guide/language/object.md",childMarkdownRemark:{frontmatter:{title:"Объект",order:175}}}},{node:{relativePath:"ru/guide/language/overview.md",childMarkdownRemark:{frontmatter:{title:"Обзор",order:0}}}},{node:{relativePath:"ru/guide/language/more-on-type.md",childMarkdownRemark:{frontmatter:{title:"Больше о типах",order:120}}}},{node:{relativePath:"ru/guide/language/string-and-char.md",childMarkdownRemark:{frontmatter:{title:"Строка и символ",order:20}}}},{node:{relativePath:"ru/guide/language/record.md",childMarkdownRemark:{frontmatter:{title:"Запись",order:60}}}},{node:{relativePath:"ru/guide/language/pattern-matching.md",childMarkdownRemark:{frontmatter:{title:"Паттерн-матчинг",order:135}}}},{node:{relativePath:"ru/guide/language/tuple.md",childMarkdownRemark:{frontmatter:{title:"Кортеж",order:50}}}},{node:{relativePath:"ru/guide/language/type.md",childMarkdownRemark:{frontmatter:{title:"Тип!",order:15}}}},{node:{relativePath:"ru/guide/native/convert-from-ocaml.md",childMarkdownRemark:{frontmatter:{title:"Converting from OCaml",order:4}}}},{node:{relativePath:"ru/guide/language/variant.md",childMarkdownRemark:{frontmatter:{title:"Вариант!",order:70}}}},{node:{relativePath:"ru/guide/native/index.md",childMarkdownRemark:{frontmatter:{title:"Native",order:40}}}},{node:{relativePath:"ru/guide/native/quickstart.md",childMarkdownRemark:{frontmatter:{title:"Quickstart",order:0}}}}]},file:{relativePath:"ru/guide/language/more-on-type.md",childMarkdownRemark:{html:'<h3 id="Аргументы-типа"><a href="#%D0%90%D1%80%D0%B3%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B-%D1%82%D0%B8%D0%BF%D0%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Аргументы типа</h3>\n<p>Типы могут принимать параметры, как шаблоны в других языках. Это как если бы тип был функцией,\nкоторая принимает аргументы и возвращает новый тип. Параметр <strong>обязан</strong> начинаться с  <code>\'</code>.</p>\n<p>Такие типы используются для уменьшения дублирования кода. Без них:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-comment">/* Кортеж из трех элементов */</span>\n<span class="hljs-keyword">type</span> intCoordinates = (int, int, int);\n<span class="hljs-keyword">type</span> floatCoordinates = (float, float, float);\n\n<span class="hljs-keyword">let</span> buddy: intCoordinates = (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>);</code></pre>\n      </div>\n<p>С ними:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> coordinates \'a = (\'a, \'a, \'a);\n\n<span class="hljs-comment">/* применить "функцию-тип" и вернуть тип (int, int, int) */</span>\n<span class="hljs-keyword">type</span> intCoordinatesAlias = coordinates int;\n<span class="hljs-keyword">let</span> buddy: intCoordinatesAlias = (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>);\n\n<span class="hljs-comment">/* можно записать одной строкой */</span>\n<span class="hljs-keyword">let</span> buddy: coordinates float = (<span class="hljs-number">10.5</span>, <span class="hljs-number">20.5</span>, <span class="hljs-number">20.5</span>);</code></pre>\n      </div>\n<p>На практике типы будут выведены. Потому более простая версия:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> buddy = (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>);</code></pre>\n      </div>\n<p>Система типов поймет, что это <code>(int, int, int)</code>. Ничего более писать не нужно.</p>\n<p>Типы с аргументами используются повсеместно.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-comment">/* выводится как `list string` */</span>\n<span class="hljs-keyword">let</span> greetings = [<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>, <span class="hljs-string">"how are you"</span>];</code></pre>\n      </div>\n<p>Если бы типы не могли принимать параметры, то стандартной библиотеке пришлось бы определять\nотдельные методы для типов  <code>listOfString</code>, <code>listOfInt</code>, <code>listOfTuplesOfInt</code>, и так далее</p>\n<p>Типы могут принимать несколько аргументов и комбинироваться:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> result \'a \'b =\n| <span class="hljs-type">Ok</span> \'a\n| <span class="hljs-type">Error</span> \'b;\n\n<span class="hljs-keyword">type</span> myPayload = {data: string};\n\n<span class="hljs-keyword">type</span> myPayloadResults \'errorType = list (result myPayload \'errorType);\n\n<span class="hljs-keyword">let</span> payloadResults: myPayloadResults string = [\n  <span class="hljs-type">Ok</span> {data: <span class="hljs-string">"hi"</span>},\n  <span class="hljs-type">Ok</span> {data: <span class="hljs-string">"bye"</span>},\n  <span class="hljs-type">Error</span> <span class="hljs-string">"Something wrong happened!"</span>\n];</code></pre>\n      </div>\n<h3 id="Взаимно-рекурсивные-типы"><a href="#%D0%92%D0%B7%D0%B0%D0%B8%D0%BC%D0%BD%D0%BE-%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D0%B2%D0%BD%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Взаимно рекурсивные типы</h3>\n<p>Как и функции типы могут быть рекурсивными при помощи <code>and</code>:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> student = {taughtBy: teacher}\nand teacher = {students: list student};</code></pre>\n      </div>\n<p><strong>Важно</strong> отсутствие точки запятой на первой строке.</p>\n<h3 id="Проектные-решения"><a href="#%D0%9F%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%BD%D1%8B%D0%B5-%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D1%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Проектные решения</h3>\n<p>Система типов позволяющая типы с аргументами, по сути предоставляет функции для оперирования\nтипами. <code>list int</code> это функция уровня типов <code>list</code>, которая принимает <code>int</code> тип, и возвращает\nновый тип, который можно использовать в других местах. В других языках такое называется\n"генериками (generics)". Например, <code>ArrayList&#x3C;Integer></code> в Java.</p>\n<p><a href="https://en.wikipedia.org/wiki/Rule_of_least_power">Принцип наименьшей можности</a> применяются,\nкогда вы просто "пытаетесь заставить все работать".\nЕсли проблемная область позволяет, определенно выберите наименее абстрактное (наиболее\nконкретное) решение, чтобы решение было быстрее достигнуто и у него было меньше неустойчивых\nнаправлений, которые вам нужно было бы пройти. Например, предпочитайте типы над данными\nсвободной формы, предпочитайте конфигурацию, управляемую данными, за счет завершения функций\nвызовов, предпочитайте вызовы функций над макросами, предпочитаете макросы над копированием\nкода. Когда вы ограничиваете свой домен и возможности, становится легче анализировать</p>\n<p>Когда система типов является всеобъемлющим аспектом вашей программы, мы должны убедиться,\nчто оставляем достаточно возможностей, чтобы не ограничивать вашу выразительность.\nБез "функций типа", у вас будет довольно много повторений. Например, <code>listOfInt</code>,\n<code>listOfString</code>, <code>listOfArrayOfFloat</code>, плюс функции для работы с ними. Однако, убедитесь, что\nне злоупотребляете этой фичей. Иногда это нормально — написать <em>немного</em> дублирующего кода,\nубирая необходимость в абстракциях.</p>',frontmatter:{title:"Больше о типах"}}}},pathContext:{section:"ru/guide",sectionTitle:"Guide",relativePath:"ru/guide/language/more-on-type.md",relatedFiles:"/^ru\\/guide\\/.*\\.md$/"}}}});
//# sourceMappingURL=path---ru-guide-language-more-on-type-5664f69a84e04c422b91.js.map