<!DOCTYPE html><html lang="zh-TW"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>模組 · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## 基礎"/><meta name="docsearch:language" content="zh-TW"/><meta property="og:title" content="模組 · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/index.html"/><meta property="og:description" content="## 基礎"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/zh-TW"><img class="logo" src="/img/dummy.svg" alt="Reason"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/zh-TW/quickstart-javascript" target="_self">文件</a></li><li class=""><a href="/zh-TW/try" target="_self">試用</a></li><li class=""><a href="/api/index" target="_self">API</a></li><li class=""><a href="/docs/zh-TW/community" target="_self">社群</a></li><li class=""><a href="/blog" target="_self">部落格</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg"/>繁體中文</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/ja/module">日本語</a></li><li><a href="/docs/en/module">English</a></li><li><a href="/docs/de/module">Deutsch</a></li><li><a href="/docs/es-ES/module">Español</a></li><li><a href="/docs/fr/module">Français</a></li><li><a href="/docs/ko/module">한국어</a></li><li><a href="/docs/pt-BR/module">Português (Brasil)</a></li><li><a href="/docs/ru/module">Русский</a></li><li><a href="/docs/uk/module">Українська</a></li><li><a href="/docs/zh-CN/module">中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank" rel="noreferrer noopener">協助翻譯</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>語言基礎</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">簡介</h3><ul><li class="navListItem"><a class="navItem" href="/docs/zh-TW/what-and-why">什麼 &amp; 為何</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">編輯器設置</h3><ul><li class="navListItem"><a class="navItem" href="/docs/zh-TW/editor-plugins">編輯器外掛</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/extra-goodies">更多好物</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">語言基礎</h3><ul><li class="navListItem"><a class="navItem" href="/docs/zh-TW/overview">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/let-binding">Let 繫結</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/type">型別！</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/string-and-char">字串 &amp; 字元</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/boolean">布林值</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/integer-and-float">整數 &amp; 浮點數</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/tuple">Tuple</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/record">Record</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/variant">變異！</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/list-and-array">List &amp; 陣列</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/function">函式</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/if-else">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/more-on-type">更多有關型別</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/destructuring">解構</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/pattern-matching">樣式匹配</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/mutation">可突變</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/imperative-loops">命令式迴圈</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/jsx">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/external">外部</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/exception">例外</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/object">物件</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/zh-TW/module">模組</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/promise">Promise</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">JavaScript</h3><ul><li class="navListItem"><a class="navItem" href="/docs/zh-TW/quickstart-javascript">快速上手</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/interop">交互作用</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/syntax-cheatsheet">句法簡潔手冊</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/libraries">函式庫</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/converting-from-js">轉換 JS</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">原生</h3><ul><li class="navListItem"><a class="navItem" href="/docs/zh-TW/native">原生</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/quickstart-ocaml">快速上手</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/convert-from-ocaml">轉換 OCaml</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">附加選項</h3><ul><li class="navListItem"><a class="navItem" href="/docs/zh-TW/faq">常見問題</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/comparison-to-ocaml">與 OCaml 比較</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/newcomer-examples">新手示範</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/project-structure">專案結構</a></li></ul></div></div></section></div><script>
            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/zh-TW" target="_blank" rel="noreferrer noopener">Translate</a><h1 class="postHeaderTitle">模組</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="基礎"></a><a href="#基礎" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>基礎</h2>
<p><strong>模組像是個迷你檔案</strong>！可以包含型別定義，<code>let</code> 繫結，巢狀模組等。</p>
<h3><a class="anchor" aria-hidden="true" id="新增"></a><a href="#新增" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>新增</h3>
<p>使用 <code>module</code> 關鍵字來新增模組。 模組名稱必須是<strong>大寫字母</strong>開頭。 任何可以放在 <code>.re</code> 檔案裡面的東西，放在模組定義的 <code>{}</code> 區塊裡。</p>
<pre><code class="hljs css languages- reason"><span class="hljs-keyword">module</span> School = {
  <span class="hljs-keyword">type</span> profession = Teacher | Director;

  <span class="hljs-keyword">let</span> person1 = Teacher;
  <span class="hljs-keyword">let</span> getProfession = <span class="hljs-function">(<span class="hljs-params">person</span>) =&gt;</span>
    <span class="hljs-keyword">switch</span> (person) {
    | <span class="hljs-function"><span class="hljs-params">Teacher</span> =&gt;</span> <span class="hljs-string">"老師"</span>
    | <span class="hljs-function"><span class="hljs-params">Director</span> =&gt;</span> <span class="hljs-string">"校長"</span>
    };
};
</code></pre>
<p>模組內容（包含型別！）可以用像是 record 的方式存取，使用 <code>.</code> 標記法。這裡示範模組作為命名空間的效用。</p>
<pre><code class="hljs css languages- reason">let anotherPerson: <span class="hljs-keyword">School.profession </span>= <span class="hljs-keyword">School.Teacher;
</span>print_endline(<span class="hljs-keyword">School.getProfession(anotherPerson)); </span><span class="hljs-comment">/* "老師" */</span>
</code></pre>
<p>巢狀模組也是一樣運作。</p>
<pre><code class="hljs css languages- reason">module <span class="hljs-attr">MyModule</span> = {
  module <span class="hljs-attr">NestedModule</span> = {
    <span class="hljs-keyword">let</span> <span class="hljs-attr">message</span> = <span class="hljs-string">"哈嘍"</span>;
  };
};

<span class="hljs-keyword">let</span> <span class="hljs-attr">message</span> = MyModule.NestedModule.message;
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="open-模組"></a><a href="#open-模組" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>open</code> 模組</h3>
<p>不斷地提及特定模組的值/型別可能會冗長且乏味。我們可以開啟模組定義，提及其內容就不需要前面加上模組名稱。兩個方式：</p>
<p>區域開啟。</p>
<pre><code class="hljs css languages- reason"><span class="hljs-keyword">let</span> message =
  School.(
    <span class="hljs-keyword">switch</span> (person1) {
    | <span class="hljs-function"><span class="hljs-params">Teacher</span> =&gt;</span> <span class="hljs-string">"哈嘍老師！"</span>
    | <span class="hljs-function"><span class="hljs-params">Director</span> =&gt;</span> <span class="hljs-string">"哈嘍校長！"</span>
    }
  );
</code></pre>
<p>全域開放。<strong>謹慎使用，方便但帶來額外代價</strong>：</p>
<pre><code class="hljs css languages- reason">open <span class="hljs-keyword">School;
</span>let anotherPerson: profession = Teacher<span class="hljs-comment">;</span>
printProfession(anotherPerson)<span class="hljs-comment">;</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="擴展模組"></a><a href="#擴展模組" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>擴展模組</h3>
<p>模組內使用 <code>include</code> 靜態地&quot;展開&quot;模組內容成為新的一個，因此經常滿足&quot;繼承&quot;或&quot;mixin&quot; 的角色。</p>
<pre><code class="hljs css languages- reason"><span class="hljs-keyword">module</span> BaseComponent = {
  <span class="hljs-keyword">let</span> defaultGreeting = <span class="hljs-string">"Hello"</span>;
  <span class="hljs-keyword">let</span> getAudience = <span class="hljs-function">(<span class="hljs-params">~excited</span>) =&gt;</span> excited ? <span class="hljs-string">"world!"</span> : <span class="hljs-string">"world"</span>;
};

<span class="hljs-keyword">module</span> ActualComponent = {
  <span class="hljs-comment">/* 複製所有內容 */</span>
  include BaseComponent;
  <span class="hljs-comment">/* 重載 BaseComponent.defaultGreeting */</span>
  <span class="hljs-keyword">let</span> defaultGreeting = <span class="hljs-string">"嘿"</span>;
  <span class="hljs-keyword">let</span> render = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> defaultGreeting ++ <span class="hljs-string">" "</span> ++ getAudience(~excited=<span class="hljs-literal">true</span>);
};
</code></pre>
<p><strong>注意</strong>：<code>open</code> 和 <code>include</code> 非常不同！ 前者將模組內容帶入目前範疇，因此不需要每次前面加上模組名稱來提及該模組值。 後者靜態地<strong>拷貝所有</strong>模組定義，接著 <code>open</code> 模組。</p>
<h3><a class="anchor" aria-hidden="true" id="每個-re-檔案都是個模組"></a><a href="#每個-re-檔案都是個模組" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>每個 <code>.re</code> 檔案都是個模組</h3>
<p>一個 OCaml/Reason 檔案對應到一個模組；解開某些有趣的表達性，其他語言必須先要求產生程式碼。 檔案 <code>React.re</code> 隱喻地形成一個 <code>React</code> 模組，可以給其他檔案使用。</p>
<pre><code class="hljs css languages- reason"><span class="hljs-comment">/* FileA.re。典型地編譯成下列 FileA 模組 */</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">a</span> = <span class="hljs-number">1</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">b</span> = <span class="hljs-number">2</span>;

<span class="hljs-comment">/* FileB.re */</span>
<span class="hljs-comment">/* 對應 FileA 的實作到新的 API */</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">alpha</span> = FileA.a;
<span class="hljs-keyword">let</span> <span class="hljs-attr">beta</span> = FileA.b;
</code></pre>
<p>這個假的片段表達&quot;複製&quot;檔案：</p>
<pre><code class="hljs css languages- reason"><span class="hljs-comment">/* FileA.re。典型地編譯成下列 FileA 模組 */</span>
let a = <span class="hljs-number">1</span><span class="hljs-comment">;</span>
let <span class="hljs-keyword">b </span>= <span class="hljs-number">2</span><span class="hljs-comment">;</span>

<span class="hljs-comment">/* FileB.re */</span>
<span class="hljs-comment">/* 編譯成跟 fileA.re 一樣的內容，沒有執行期的開銷！ */</span>
include FileA<span class="hljs-comment">;</span>
</code></pre>
<p><strong>注意</strong>：由於檔案也是模組，習慣上檔案名稱會是第一個字母大寫，以符合其模組名稱。 第一個字母非大寫的檔案名稱是合法的，但會轉變成第一個字母大寫的模組名稱。 例如，<code>file.re</code> 編譯成 <code>File</code> 模組。 為了簡易且簡化這個分化，所以慣例上也會是第一個字母大寫。</p>
<h2><a class="anchor" aria-hidden="true" id="標記式"></a><a href="#標記式" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>標記式</h2>
<p>模組型別稱之為&quot;標記式（signature）&quot;，可以明確地寫出來。 如果是 <code>.re</code> （實作）的模組，則標記式則是 <code>.rei</code> （界面）檔。</p>
<h3><a class="anchor" aria-hidden="true" id="新增-1"></a><a href="#新增-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>新增</h3>
<p>使用 <code>module type</code> 關鍵字來新增標記式。 標記式名稱必須是<strong>大寫字母</strong>開頭。 任何可以放在 <code>.rei</code> 檔案裡面的東西，可以放在標記式定義的 <code>{}</code> 區塊裡。</p>
<pre><code class="hljs css languages- reason"><span class="hljs-comment">/* 取用上個章節範例 */</span>
<span class="hljs-keyword">module</span> type EstablishmentType = {
  <span class="hljs-keyword">type</span> profession;
  <span class="hljs-keyword">let</span> getProfession: <span class="hljs-function"><span class="hljs-params">profession</span> =&gt;</span> <span class="hljs-built_in">string</span>;
};
</code></pre>
<p>標記式預定義需求清單，表示模組必須滿足，為了讓模組符合標記式。這些需求形式如下：</p>
<ul>
<li><code>let x: int;</code> 要求 <code>let</code> 繫結名稱必須是 <code>x</code>，型別是 <code>int</code>。</li>
<li><code>type t = someType;</code> 要求型別欄位 <code>t</code> 必須與 <code>someType</code> 相同。</li>
<li><code>type t;</code> 要求型別欄位 <code>t</code>，但並不強迫任何要求於 <code>t</code> 的實際、具體型別。 標記式內我們使用 <code>t</code> 於其他項目以描述關係，例如 <code>let makePair: t =&gt; (t, t)</code> 但我們不能，例如，假定 <code>t</code> 是個 <code>int</code>。 賦予我們強大，強迫的抽象能力。</li>
</ul>
<p>為了表明各種型別項目，考慮上述標記式 <code>EstablishmentType</code> 要求模組：</p>
<ul>
<li>宣告一個名稱為 <code>profession</code> 的型別。</li>
<li>必須包含一個函式，接受 <code>profession</code> 型別的值並傳回字串。</li>
</ul>
<p><strong>注意</strong>：</p>
<p>模組的型別 <code>EstablishmentType</code> 可包含更多欄位，不在標記式宣告裡，就像前個章節的 <code>School</code> 模組（如果我們選擇指派 <code>EstablishmentType</code> 型別。 否則，<code>School</code> 暴露每一個欄位）。 這有力地強迫讓 <code>person1</code> 欄位實作細節！ 外部無法存取，由於並非出現於標記式；標記式<strong>限制</strong>其他人可以存取的東西。</p>
<p><code>EstablishmentType.profession</code> 型別是<strong>抽象的</strong>：沒有具體型別；表示&quot;我不在意實際型別是什麼，但是是用來作為 <code>getProfession</code> 的輸入&quot;。 這個十分有用，讓許多模組滿足同個介面：</p>
<pre><code class="hljs css languages- reason">module Company: EstablishmentType = {
 <span class="hljs-built_in"> type </span>profession = CEO | Designer | Engineer | <span class="hljs-built_in">..</span>.;

  let getProfession = (person) =&gt; <span class="hljs-built_in">..</span>.;
  let person1 = <span class="hljs-built_in">..</span>.;
  let person2 = <span class="hljs-built_in">..</span>.;
};
</code></pre>
<p>對於隱藏底部型別，作為其他人無法依賴的實作細節十分有用。 如果你問 <code>Company.profession</code> 型別是什麼，它會告訴你&quot;這是個 <code>Company.profession</code>&quot; 而不是暴露變異。</p>
<h3><a class="anchor" aria-hidden="true" id="擴展模組標記式"></a><a href="#擴展模組標記式" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>擴展模組標記式</h3>
<p>就像模組本身，模組標記式也可以透過 <code>include module type of Foo</code> 來擴展：</p>
<pre><code class="hljs css languages- reason"><span class="hljs-keyword">module</span> <span class="hljs-keyword">type</span> <span class="hljs-type">BaseComponent</span> = {
  <span class="hljs-keyword">let</span> defaultGreeting: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">let</span> getAudience: (~excited: <span class="hljs-built_in">bool</span>) =&gt; <span class="hljs-built_in">string</span>;
};

<span class="hljs-keyword">module</span> <span class="hljs-keyword">type</span> <span class="hljs-type">ActualComponent</span> = {
  /* 複製所有標記式 */
  <span class="hljs-keyword">include</span> (<span class="hljs-keyword">module</span> <span class="hljs-keyword">type</span> <span class="hljs-keyword">of</span> <span class="hljs-type">BaseComponent</span>);
  <span class="hljs-keyword">let</span> render: <span class="hljs-built_in">unit</span> =&gt; <span class="hljs-built_in">string</span>;
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="每個-rei-檔案都是一個標記式"></a><a href="#每個-rei-檔案都是一個標記式" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>每個 <code>.rei</code> 檔案都是一個標記式</h3>
<p>類似於 <code>React.re</code> 隱喻地定義 <code>React</code> 模組，<code>React.rei</code> 檔案隱喻地定義<code>React</code> 標記式。 如果沒有提供 <code>React.rei</code>，<code>React.re</code> 的標記式預設是暴露所有模組內欄位。 因為沒有包含實作檔案，<code>.rei</code> 在生態圈也用來作為相對應模組的文件，紀錄開放的 API。</p>
<pre><code class="hljs css languages- reason"><span class="hljs-comment">/* React.re 檔（實作，編譯成 React 模組） */</span>
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">state</span></span> = int;
<span class="hljs-keyword">let</span> render = (<span class="hljs-built_in">str</span>) =&gt; <span class="hljs-built_in">str</span>;
</code></pre>
<pre><code class="hljs css languages- reason"><span class="hljs-comment">/* React.rei 檔（介面。編譯成 React 模組的標記式）*/</span>
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">state</span></span> = int;
<span class="hljs-keyword">let</span> render: <span class="hljs-built_in">str</span> =&gt; <span class="hljs-built_in">str</span>;
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="模組函式-functors"></a><a href="#模組函式-functors" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>模組函式（functors）</h2>
<p>模組可以傳遞給函式！ 相當於傳遞檔案作為頭等（first-class）項目。 然而，語言中模組與其他常見概念處於不同的&quot;層面&quot;，所以無法傳遞給<em>普通</em>函式。 作為替代，傳遞到特殊函式稱之為 &quot;functors&quot;。</p>
<p>定義及使用 functors 的語法非常類似普通函式。主要差異有：</p>
<ul>
<li>Functors 使用 <code>module</code> 關鍵字而非 <code>let</code>。</li>
<li>Functors 接受一個或多個模組作為參數並傳回一個模組。</li>
<li>Functors <em>要求</em>註釋參數。</li>
<li>Functors 必須大寫字母開頭（就像是模組/標記式）。</li>
</ul>
<p>下列為 <code>MakeSet</code> functor，接受 <code>Comparable</code> 型別的模組並傳回新的 set 可以包含如可比對項目。</p>
<pre><code class="hljs css languages- reason"><span class="hljs-keyword">module</span> type Comparable = {
  <span class="hljs-keyword">type</span> t;
  <span class="hljs-keyword">let</span> equal: <span class="hljs-function">(<span class="hljs-params">t, t</span>) =&gt;</span> bool;
};

<span class="hljs-keyword">module</span> MakeSet = (Item: Comparable) =&gt; {
  <span class="hljs-comment">/* 使用 list 作為天真背後的資料結構 */</span>
  <span class="hljs-keyword">type</span> backingType = list(Item.t);
  <span class="hljs-keyword">let</span> empty = [];
  <span class="hljs-keyword">let</span> add = (currentSet: backingType, newItem: Item.t) : <span class="hljs-function"><span class="hljs-params">backingType</span> =&gt;</span>
    <span class="hljs-comment">/* 如果項目存在 */</span>
    <span class="hljs-keyword">if</span> (List.exists(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> Item.equal(x, newItem), currentSet)) {
      currentSet <span class="hljs-comment">/* 傳回同樣（immutable）set（其實是個 list） */</span>
    } <span class="hljs-keyword">else</span> {
      [
        newItem,
        ...currentSet <span class="hljs-comment">/* 前面加入 set 並傳回 */</span>
      ]
    };
};
</code></pre>
<p>使用函式應用語法來套用 Functors 。這個例子，我們新增一個 set，每個項目是一對整數。</p>
<pre><code class="hljs css languages- reason"><span class="hljs-keyword">module</span> IntPair = {
  <span class="hljs-keyword">type</span> t = (int, int);
  <span class="hljs-keyword">let</span> equal = <span class="hljs-function">(<span class="hljs-params">(<span class="hljs-params">x1, y1</span>), (<span class="hljs-params">x2, y2</span>)</span>) =&gt;</span> x1 == x2 &amp;&amp; y1 == y2;
  <span class="hljs-keyword">let</span> create = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> (x, y);
};

<span class="hljs-comment">/* IntPair 遵守 Comparable 標記式，由 MakeSet 要求 */</span>
<span class="hljs-keyword">module</span> SetOfIntPairs = MakeSet(IntPair);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="模組函式型別"></a><a href="#模組函式型別" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>模組函式型別</h3>
<p>像是模組型別，functor 型別也遵循限制並隱藏了有關 functors 的假設。 Functor 型別語法與那些函式型別一致，除了型別是使用大寫字幕開頭代表模組的標記式，functors 接收的參數及傳回值。 前述範例中，我們暴露後面的 set 型別；透過 <code>MakeSet</code> 的 functor 標記式，可以隱藏底層資料結構！</p>
<pre><code class="hljs css languages- reason">module<span class="hljs-built_in"> type </span>Comparable = <span class="hljs-built_in">..</span>.

module<span class="hljs-built_in"> type </span>MakeSetType = (Item: Comparable) =&gt; {
 <span class="hljs-built_in"> type </span>backingType;
  let empty: backingType;
  let add: (backingType, Item.t) =&gt; backingType;
};

module MakeSet: MakeSetType = (Item: Comparable) =&gt; {
  <span class="hljs-built_in">..</span>.
};
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="缺點"></a><a href="#缺點" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缺點</h2>
<p>語言中，模組與 functors 與其他（函式、let 繫結、資料結構等）處於不同的&quot;層面&quot;。 例如，你無法輕易地將它們傳遞到 tuple 或 record。 明智地使用它們！ 許多時候，單純 record 或 function 便已足夠。</p>
<pre><code class="hljs css languages- reason">module <span class="hljs-type">School</span> = <span class="hljs-meta">{...}</span>;

/* 這會直接給你語法錯誤！ */
<span class="hljs-keyword">let</span> schools = (<span class="hljs-type">School</span>, <span class="hljs-type">School</span>);
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/zh-TW/object">← 物件</a><a class="docs-next button" href="/docs/zh-TW/promise">Promise →</a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#基礎">基礎</a><ul class="toc-headings"><li><a href="#新增">新增</a></li><li><a href="#open-模組"><code>open</code> 模組</a></li><li><a href="#擴展模組">擴展模組</a></li><li><a href="#每個-re-檔案都是個模組">每個 <code>.re</code> 檔案都是個模組</a></li></ul></li><li><a href="#標記式">標記式</a><ul class="toc-headings"><li><a href="#新增-1">新增</a></li><li><a href="#擴展模組標記式">擴展模組標記式</a></li><li><a href="#每個-rei-檔案都是一個標記式">每個 <code>.rei</code> 檔案都是一個標記式</a></li></ul></li><li><a href="#模組函式-functors">模組函式（functors）</a><ul class="toc-headings"><li><a href="#模組函式型別">模組函式型別</a></li></ul></li><li><a href="#缺點">缺點</a></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.min.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper, .onPageNav',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:zh-TW"]}
              });
            </script></body></html>