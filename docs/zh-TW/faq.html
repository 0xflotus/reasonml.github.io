<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>常見問題 · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="常見問題 · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/index.html"/><meta property="og:description" content="### 我應該先學 Reason 還是 OCaml？"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/arduino-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/dummy.svg"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/docs/zh-TW/quickstart-javascript.html" target="_self">文件</a></li><li><a href="/zh-TW/try.html" target="_self">試用</a></li><li><a href="/api/index.html" target="_self">API</a></li><li><a href="/docs/zh-TW/community.html" target="_self">社群</a></li><li><a href="/blog" target="_self">部落格</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg"/>繁體中文</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/ja">日本語</a></li><li><a href="/en">English</a></li><li><a href="/es-ES">Español</a></li><li><a href="/fr">Français</a></li><li><a href="/ko">한국어</a></li><li><a href="/pt-BR">Português (Brasil)</a></li><li><a href="/ru">Русский</a></li><li><a href="/uk">Українська</a></li><li><a href="/zh-CN">中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank">協助翻譯</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Extra</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>簡介</h3><ul><li class="navListItem"><a class="navItem" href="/docs/zh-TW/what-and-why.html">什麼 &amp; 為何</a></li></ul></div><div class="navGroup navGroupActive"><h3>編輯器設置</h3><ul><li class="navListItem"><a class="navItem" href="/docs/zh-TW/global-installation.html">全域安裝</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/editor-plugins.html">編輯器外掛</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/extra-goodies.html">更多好物</a></li></ul></div><div class="navGroup navGroupActive"><h3>語言基礎</h3><ul><li class="navListItem"><a class="navItem" href="/docs/zh-TW/overview.html">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/let-binding.html">Let 繫結</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/type.html">型別！</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/string-and-char.html">字串 &amp; 字元</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/boolean.html">布林值</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/integer-and-float.html">整數 &amp; 浮點數</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/tuple.html">Tuple</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/record.html">Record</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/variant.html">變異！</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/list-and-array.html">List &amp; 陣列</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/function.html">函式</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/if-else.html">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/more-on-type.html">更多有關型別</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/destructuring.html">解構</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/pattern-matching.html">樣式匹配</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/mutation.html">可突變</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/imperative-loops.html">命令式迴圈</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/jsx.html">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/external.html">外部</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/exception.html">例外</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/object.html">物件</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/module.html">模組</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/promise.html">Promise</a></li></ul></div><div class="navGroup navGroupActive"><h3>JavaScript</h3><ul><li class="navListItem"><a class="navItem" href="/docs/zh-TW/quickstart-javascript.html">快速上手</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/interop.html">交互作用</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/syntax-cheatsheet.html">句法簡潔手冊</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/libraries.html">函式庫</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/converting-from-js.html">轉換 JS</a></li></ul></div><div class="navGroup navGroupActive"><h3>原生</h3><ul><li class="navListItem"><a class="navItem" href="/docs/zh-TW/native.html">原生</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/quickstart-ocaml.html">快速上手</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/convert-from-ocaml.html">轉換 OCaml</a></li></ul></div><div class="navGroup navGroupActive"><h3>附加選項</h3><ul><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/docs/zh-TW/faq.html">常見問題</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/comparison-to-ocaml.html">與 OCaml 比較</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/newcomer-examples.html">新手示範</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/project-structure.html">專案結構</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/zh-TW" target="_blank">Translate</a><h1>常見問題</h1></header><article><div><span><h3><a class="anchor" aria-hidden="true" name="reason-ocaml"></a><a href="#reason-ocaml" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>我應該先學 Reason 還是 OCaml？</h3>
<p>無須選擇！ Reason 與 OCaml 共享相同語義（例如，如何執行程式）。 差別在於句法。 隨時帶著 <a href="https://github.com/reasonml/reason-tools">Reason-tools</a> 在身邊，隨時轉換兩者句法。 Reason 教學就是 OCaml 教學，反之亦然。 在終端機中，你可以設定下列別名：</p>
<pre><code class="hljs css sh"><span class="hljs-comment"># converts ocaml code into reason</span>
<span class="hljs-built_in">alias</span> mlre=<span class="hljs-string">"pbpaste | refmt --parse ml --print re --interface false | pbcopy"</span>
<span class="hljs-comment"># converts reason code into ocaml</span>
<span class="hljs-built_in">alias</span> reml=<span class="hljs-string">"pbpaste | refmt --parse re --print ml --interface false | pbcopy"</span>
</code></pre>
<p>這會從（macOS）剪貼簿取得程式碼，轉換並貼上回剪貼簿！換掉 pbpaste/pbcopy 成你的系統剪貼簿函式。</p>
<h3><a class="anchor" aria-hidden="true" name="reason"></a><a href="#reason" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>我不確定 Reason 做什麼</h3>
<p><a href="/docs/zh-TW/quickstart-javascript.html">我們擅長編譯成 JS</a>。 試想有哪些專案你通常會使用純 JavaScript；試著移植/撰寫到 Reason + BuckleScript！ 我們建議試著實作具體，終端用戶專案（例如，小型命令列工具）而非基礎建設等級專案（例如，樣板文件產生器）。 後者分類需要專門技能及了解符合 Reason 的程式碼風格。</p>
<h3><a class="anchor" aria-hidden="true" name="reason-bucklescript-ocaml"></a><a href="#reason-bucklescript-ocaml" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reason，BuckleScript 及 OCaml 之間有什麼關係？</h3>
<p>請見<a href="/docs/zh-TW/quickstart-javascript.html">這裡</a>。Reason 提供句法給 OCaml 並支援所有功能。BuckleScript 將 OCaml/Reason 程式碼編譯成 JavaScript。</p>
<h3><a class="anchor" aria-hidden="true" name="print-endline-string-of-int"></a><a href="#print-endline-string-of-int" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>這些 <code>print_endline</code>，<code>string_of_int</code> 從哪來的？</h3>
<p>來自於標準函式庫，編譯你的檔案時預先 <code>open</code>。這就是為何你會在範疇中看到它。</p>
<h3><a class="anchor" aria-hidden="true" name=""></a><a href="#" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>我可以有個函式印出任意資料結構嗎？</h3>
<p>如果透過 BuckleScript 編譯出 JavaScript，使用 BuckleScript 的 <a href="https://bucklescript.github.io/bucklescript/api/Js.html#VALlog"><code>Js.log</code></a>，這會使用 JS 的 <code>console.log</code>。 如果編譯系統原生，你會需要像是 <a href="https://github.com/diml/ppx_show"> ppx_show</a> 的東西。 OCaml 的未來功能（稱之為隱含模組）將會直接在語言中解決這個問題。</p>
<h3><a class="anchor" aria-hidden="true" name=""></a><a href="#" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>為什麼有 + 用來相加整數 +. 用來相加浮點數呢？</h3>
<p>請見<a href="/docs/zh-TW/integer-and-float.html#design-decisions">這裡</a>。</p>
<h3><a class="anchor" aria-hidden="true" name="reason"></a><a href="#reason" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>__ 函式庫可以在 Reason 中運作嗎？</h3>
<p>大多數 JS 函式庫應該很容易在 Reason + BuckleScript 中使用。 而在原生方面，因為 Reason 就是個句法轉換：可以，它們也可以在 Reason 中運作。 但是原生的工作流程目前正在開發中，需要加以磨光。</p>
<h3><a class="anchor" aria-hidden="true" name="js-nodejs"></a><a href="#js-nodejs" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>那麼伺服端呢？我該編譯成系統原生還是 JS 並使用 node.js？</h3>
<p>我們可以編譯成原生，但是原生工作流程仍在開發中。 目前來說，建議透過 BuckleScript 編譯 JS 並使用 <a href="https://github.com/reasonml-community">reasonml-community</a> 或其它地方的繫結。</p>
<h3><a class="anchor" aria-hidden="true" name="bucklescript"></a><a href="#bucklescript" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>那麼 BuckleScript 的非同步呢？</h3>
<p>首先，如果你不是處理使用 promise 的函式庫，你可以單純使用回呼函式。任何人都可上手且更具效能。</p>
<p>如果你要繫結使用 promises 的函式庫，或者進行溝通，你可以使用 BS 的 <a href="http://bucklescript.github.io/bucklescript/api/Js.Promise.html">Js.Promise</a>。 未來極有可能會有些句法糖。 長期來看，我們希望在 OCaml/Reason 實作相容規格的 promises，這樣編譯器的最佳化就可派上用場。</p>
<p>更多有關符合 OCaml 風格的解決方案：在原生 OCaml 方面，我們有 <a href="http://ocsigen.org/lwt/">lwt</a> 及 <a href="https://ocaml.janestreet.com/ocaml-core/111.03.00/doc/async/#Std">Async</a>。 目前在 web 並沒有使用，未來可能會。</p>
<h3><a class="anchor" aria-hidden="true" name=""></a><a href="#" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>那麼（單元）測試呢？</h3>
<p>某些 OCaml 的語言功能（不只是型別）能夠延遲對單元測試的需求。 在此期間，對於編譯成 JS，我們正在開發 <a href="https://github.com/BuckleTypes/bs-jest">Jest 繫結</a>。 我們也將會了解更多 Jest 供原生使用，若在未來使用 Reason 撰寫 Jest（尚未有具體計畫）。 目前 <a href="http://ounit.forge.ocamlcore.org">OUnit</a> 是個良好，小型的 OCaml 測試函式庫。</p>
<h3><a class="anchor" aria-hidden="true" name="merlin"></a><a href="#merlin" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>專案目錄下的 <code>.merlin</code> 檔案是什麼？</h3>
<p>它是個 <a href="/docs/zh-TW/extra-goodies.html#merlin">Merlin</a> 的中繼資料（metadata），Merlin 用來作為共享編輯器整合用的後端，提供例如自動補完（autocomplete），移至定義（jump-to-definition）等功能。 對於 <a href="/docs/zh-TW/quickstart-javascript.html">JavaScript 工作流程</a>，<code>bsb</code> 建置系統為你產生 <code>.merlin</code> 檔案；不需要將檔案納入版本控制，也不需要手動修改它。</p>
<h3><a class="anchor" aria-hidden="true" name="import-require"></a><a href="#import-require" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>我沒看到任何 <code>import</code> 或 <code>require</code> ；模組解析是如何運作？</h3>
<p>Reason/OCaml 不需要你撰寫任何匯入；檔案內的模組會自動在專案中搜尋。 具體來說，<code>Hello</code> 模組編譯器會找尋 code&gt;hello.re</code> 或 <code>hello.ml</code> 檔案（以及相對應的<a href="/docs/zh-TW/module.html#signatures">介面檔案</a>，<code>hello.rei</code> 或 <code>hello.mli</code>，如果有的話）。</p>
<p>模組名稱即檔案名稱，模組字首大寫。名稱在專案內必須是獨一無二；這從檔案系統中抽象出來並且讓你能夠隨意移動位置而不需修改程式碼。</p>
<h3><a class="anchor" aria-hidden="true" name="some-none-contents-array-list"></a><a href="#some-none-contents-array-list" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>這些 <code>Some | None</code>，<code>contents</code>，<code>Array</code>，<code>List</code> 都是特別東西？這些是從哪裡來的？</h3>
<p>它們只是平凡的 variants/records/module 定義，來自於<a href="/api/index.html">標準函式庫</a>，預設在編譯期間 <code>open</code>。</p>
<h3><a class="anchor" aria-hidden="true" name="foo"></a><a href="#foo" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>參數前面有個底線（例如， <code>_</code> 或 <code>_foo</code>）是什麼意思？</h3>
<p>Say you have <code>List.map(item =&gt; 1, myList);</code>. 若參數 <code>item</code> 不曾使用，編譯器將會產生警告。 Using <code>item =&gt; 1</code> instead indicates that you're intentionally receiving and ignoring the argument, therefore bypassing the warning. Alternatively, <code>_item =&gt; 1</code> has the same effect, but indicates more descriptively what you're ignoring.</p>
<h3><a class="anchor" aria-hidden="true" name="mymodulet"></a><a href="#mymodulet" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>為什麼一直看到 <code>MyModule.t</code>，這是什麼？</h3>
<p>假設 <code>MyModule</code> 是個模組名稱， <code>t</code> 則是個社群慣例，表示代表該模組的型別，無論該型別是什麼。 舉例來說，<a href="http://bucklescript.github.io/bucklescript/api/Js.String.html"><code>Js.String</code></a> 模組的 <a href="http://bucklescript.github.io/bucklescript/api/Js.String.html#TYPEt"><code>String.t</code></a> 就是模組型別，代表著 &quot;一個字串&quot;。</p>
<h3><a class="anchor" aria-hidden="true" name="js-promise-http-bucklescriptgithubio-bucklescript-api-js-promisehtml-jspromise-http-bucklescriptgithubio-bucklescript-api-jspromisehtml-js-array-http-bucklescriptgithubio-bucklescript-api-js-arrayhtml-js-string-http-bucklescriptgithubio-bucklescript-api-js-stringhtml"></a><a href="#js-promise-http-bucklescriptgithubio-bucklescript-api-js-promisehtml-jspromise-http-bucklescriptgithubio-bucklescript-api-jspromisehtml-js-array-http-bucklescriptgithubio-bucklescript-api-js-arrayhtml-js-string-http-bucklescriptgithubio-bucklescript-api-js-stringhtml" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>為何有 <a href="http://bucklescript.github.io/bucklescript/api/Js_promise.html"><code>Js_promise</code></a> 及 <a href="http://bucklescript.github.io/bucklescript/api/Js.Promise.html"><code>Js.Promise</code></a>？ 還有 <a href="http://bucklescript.github.io/bucklescript/api/Js_array.html"><code>Js_array</code></a>，<a href="http://bucklescript.github.io/bucklescript/api/Js_string.html"><code>Js_string</code></a> 等？</h3>
<p>按照慣例，<code>Js_foo</code> 是實際的模組，<code>Js.Foo</code> 只是個別名。 兩者是<a href="https://github.com/bloomberg/bucklescript/blob/7bc37f387a726ba1ae4afeefe02b9c82577d9e10/jscomp/runtime/js.ml#L124-L138">相等的</a>。 偏好 <code>Js.Foo</code>，因為是個正式，公開的模組名稱。</p>
<h3><a class="anchor" aria-hidden="true" name="modular-implicit-multicore-algebraic-effects"></a><a href="#modular-implicit-multicore-algebraic-effects" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>隱含模組（modular implicit）&amp; 多核心（multicore）&amp; 代數效應（algebraic effects）何時會完成？</h3>
<p>將來某天。 同時，請幫忙撰寫更多的 Reason 程式碼！ 流行程度對 OCaml 貢獻有影響。 OCaml 的人們愈不用擔心投入不成正比，愈多專注在研究及執行！</p>
<h3><a class="anchor" aria-hidden="true" name="bucklescript-bsb"></a><a href="#bucklescript-bsb" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>為何 BuckleScript 及 bsb 如此快速？怎樣才能慢下來？</h3>
<p>BuckleScript 整個堆疊都對效能作最佳調整。你可以試著加入一堆間接層及中繼語言來降低速度。試試：</p>
<ul>
<li>這裡及那裡加入一些無窮迴圈。</li>
<li>管線裡面加入 JavaScript 建置工具。</li>
<li>撰寫 hello world 時牽引更多的相依模組。</li>
</ul>
<h3><a class="anchor" aria-hidden="true" name="cmi-cmx-cmj-cma-"></a><a href="#cmi-cmx-cmj-cma-" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>我看到一些奇怪的 .cmi/.cmx/.cmj/.cma 出現在編譯器錯誤。這些檔案從哪來的？</h3>
<p>OCaml 社群經常使用檔案副檔名來區分型別原始碼，人工品及中繼資料，與你的建置目標物有關（原生/二進制碼/JavaScript）。 以下列出你可能看過的副檔名：</p>
<h4><a class="anchor" aria-hidden="true" name=""></a><a href="#" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>原始檔案</h4>
<ul>
<li><code>.ml</code>: OCaml 程式碼檔案</li>
<li><code>.mli</code>: OCaml 介面檔案；決定 <code>.ml</code> 哪些部份可以在外部被使用</li>
<li><code>.re</code>: Reason 程式碼檔案。就像 <code>.ml</code>，但是給 Reason 使用</li>
<li><code>.rei</code>: Reason 介面檔案。就像 <code>.mli</code>，但是給 Reason 使用</li>
</ul>
<h4><a class="anchor" aria-hidden="true" name=""></a><a href="#" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>編譯後檔案</h4>
<ul>
<li><code>.cmi</code>：編譯後的介面（.rei/mli）檔案</li>
<li><code>.cmx</code>：原生的編譯後檔案（由 ocamlopt 產生）</li>
<li><code>.cmo</code>：二進碼的編譯後檔案</li>
<li><code>.cmj</code>：web 的編譯後檔案（由 BuckleScript 產生）</li>
<li><code>.cma</code>：二進碼的函式庫檔案（同等於 C 的 .a 檔案）</li>
<li><code>.cmxa</code>：原生的函式庫檔案</li>
<li><code>.cmt</code>：包含 &quot;Typedtree&quot; — 基本的 AST 包含所有型別資訊</li>
<li><code>.cmti</code>：就像是 .cmt 檔案，但是是給介面檔案</li>
<li><code>.cmxs</code>：動態載入外掛（供原生編譯用）</li>
<li><code>.o</code>：原生物件編譯後檔案</li>
<li><code>.out</code>：ocamlc/ocamlopt 慣用的最終輸出檔名/副檔名（例如，<code>ocamlc -o myExecutable.out</code>）</li>
</ul>
<h4><a class="anchor" aria-hidden="true" name="ocaml"></a><a href="#ocaml" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>其他 OCaml 生態圈檔案</h4>
<ul>
<li><code>.mll</code>：ocamllex 的語彙分析器定義檔案</li>
<li><code>.mly</code>: ocamlyacc 剖析器產生器定義檔案</li>
<li><code>.mldylib</code>：包含所有將被用來編譯及封存在一起的模組路徑，建置相對應 <code>.cmxs</code> 目標（原生外掛）</li>
<li><code>.mliv</code>：供某些內建特定 <a href="https://github.com/ocaml-batteries-team/batteries-included/blob/f019927b9503ec65ef816f02315de78d4bae3481/src/batArray.mliv">自製前處理 </a> 使用。</li>
<li><code>.mllib</code>：Ocaml 函式庫（cma 及 cmxa）</li>
<li><code>.mlpack</code>：Ocaml 套件（cmo 建置使用 -pack 旗標）</li>
<li><code>.mlpp</code>：<a href="https://github.com/ygrek/ocaml-extlib">Extlib</a>-特定檔案供自製前處理使用</li>
<li><code>.mltop</code>：<a href="https://shonkychef.wordpress.com/2009/07/28/making-an-ocaml-toplevel-with-ocamlbuild/">OCamlbuild 最上層檔案</a>，由 OCamlbuild 所使用用來產生 .top 檔案</li>
<li><code>.odocl</code>：OCaml 文件檔案</li>
</ul>
<p>如果這些解釋仍感到隱密，以下是一些上述所使用到詞彙解釋： - <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">AST</a>：抽象句法樹（Abstract Syntax Tree）。 從程式碼產生出來的資料結構，供編譯器操作使用。 - <a href="https://en.wikipedia.org/wiki/Linker_(computing)">連結</a>：這個步驟編譯器將多個中間編譯檔案組合在一起。 例如，將 A 與 B 連結，因為 A 程式碼中引用到 B。 - 系統原生：建置出可供系統平台執行的組語指令。 - <a href="https://en.wikipedia.org/wiki/Bytecode">二元碼</a>：類似系統原生程式碼，更好的可攜性但較低效能 - <a href="https://en.wikipedia.org/wiki/Object_file">物件檔案</a>：包含無法直接執行的機器碼。</p>
<p>更多有關這些副檔名的資訊及內容請上<a href="https://ocaml.org/learn/tutorials/filenames.html">OCaml 網站</a>及<a href="http://caml.inria.fr/pub/ml-archives/caml-list/2008/09/2bc9b38171177af5dc0d832a365d290d.en.html">此郵件列表文章</a>。 這裡也有更深入的<a href="https://caml.inria.fr/pub/docs/manual-ocaml/native.html">系統原生</a>及<a href="http://caml.inria.fr/pub/docs/manual-ocaml/comp.html">二元碼</a>的編譯，OCaml 手冊中有更詳細描述。</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="convert-from-ocaml.html">← 轉換 OCaml</a><a class="docs-next button" href="comparison-to-ocaml.html">與 OCaml 比較 →</a></div></div></div></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react'
              });
            </script></body></html>