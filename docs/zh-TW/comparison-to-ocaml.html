<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>與 OCaml 比較 · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="與 OCaml 比較 · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/index.html"/><meta property="og:description" content="如果你來自 OCaml 或是正在閱讀 OCaml 所撰寫的教學，本指南是為你所準備！ 但請別忘了 [reason-tools](https://github.com/reasonml/reason-tools) 可以直接進行 OCaml 與 Reason 句法轉換。"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/arduino-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/dummy.svg"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/docs/zh-TW/quickstart-javascript.html" target="_self">文件</a></li><li><a href="/zh-TW/try.html" target="_self">試用</a></li><li><a href="/api/index.html" target="_self">API</a></li><li><a href="/docs/zh-TW/community.html" target="_self">社群</a></li><li><a href="/blog" target="_self">部落格</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg"/>繁體中文</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/ja">日本語</a></li><li><a href="/en">English</a></li><li><a href="/de">Deutsch</a></li><li><a href="/es-ES">Español</a></li><li><a href="/fr">Français</a></li><li><a href="/ko">한국어</a></li><li><a href="/pt-BR">Português (Brasil)</a></li><li><a href="/ru">Русский</a></li><li><a href="/uk">Українська</a></li><li><a href="/zh-CN">中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank">協助翻譯</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Extra</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>簡介</h3><ul><li class="navListItem"><a class="navItem" href="/docs/zh-TW/what-and-why.html">什麼 &amp; 為何</a></li></ul></div><div class="navGroup navGroupActive"><h3>編輯器設置</h3><ul><li class="navListItem"><a class="navItem" href="/docs/zh-TW/global-installation.html">全域安裝</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/editor-plugins.html">編輯器外掛</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/extra-goodies.html">更多好物</a></li></ul></div><div class="navGroup navGroupActive"><h3>語言基礎</h3><ul><li class="navListItem"><a class="navItem" href="/docs/zh-TW/overview.html">概述</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/let-binding.html">Let 繫結</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/type.html">型別！</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/string-and-char.html">字串 &amp; 字元</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/boolean.html">布林值</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/integer-and-float.html">整數 &amp; 浮點數</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/tuple.html">Tuple</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/record.html">Record</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/variant.html">變異！</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/list-and-array.html">List &amp; 陣列</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/function.html">函式</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/if-else.html">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/more-on-type.html">更多有關型別</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/destructuring.html">解構</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/pattern-matching.html">樣式匹配</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/mutation.html">可突變</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/imperative-loops.html">命令式迴圈</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/jsx.html">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/external.html">外部</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/exception.html">例外</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/object.html">物件</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/module.html">模組</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/promise.html">Promise</a></li></ul></div><div class="navGroup navGroupActive"><h3>JavaScript</h3><ul><li class="navListItem"><a class="navItem" href="/docs/zh-TW/quickstart-javascript.html">快速上手</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/interop.html">交互作用</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/syntax-cheatsheet.html">句法簡潔手冊</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/libraries.html">函式庫</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/converting-from-js.html">轉換 JS</a></li></ul></div><div class="navGroup navGroupActive"><h3>原生</h3><ul><li class="navListItem"><a class="navItem" href="/docs/zh-TW/native.html">原生</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/quickstart-ocaml.html">快速上手</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/convert-from-ocaml.html">轉換 OCaml</a></li></ul></div><div class="navGroup navGroupActive"><h3>附加選項</h3><ul><li class="navListItem"><a class="navItem" href="/docs/zh-TW/faq.html">常見問題</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/docs/zh-TW/comparison-to-ocaml.html">與 OCaml 比較</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/newcomer-examples.html">新手示範</a></li><li class="navListItem"><a class="navItem" href="/docs/zh-TW/project-structure.html">專案結構</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/zh-TW" target="_blank">Translate</a><h1>與 OCaml 比較</h1></header><article><div><span><p>如果你來自 OCaml 或是正在閱讀 OCaml 所撰寫的教學，本指南是為你所準備！ 但請別忘了 <a href="https://github.com/reasonml/reason-tools">reason-tools</a> 可以直接進行 OCaml 與 Reason 句法轉換。</p>
<h2><a class="anchor" aria-hidden="true" name=""></a><a href="#" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>註解</h2>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>(* OCaml (*nest*) *)</code></td><td><code>/* Reason /*nest*/ */</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" name="operator"></a><a href="#operator" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>重新命名運算子（Operator）</h2>
<p>Reason 包含所有 OCaml 的中綴運算子（infix operators），但某些運算子表達方式不同。 在 Reason，結構相等為 <code>==</code>，而參考（實際）相等為 <code>===</code>。 在 Reason，若要達到相對應的不相等，只需要將第 1 個字元改成 <code>!</code> 即可。 （<code>!=</code> 結構不相等， <code>!==</code> 參考不相等）。</p>
<table>
<thead>
<tr><th>相等</th><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td>結構</td><td><code>x = y</code></td><td><code>x == y</code></td></tr>
<tr><td>參考</td><td><code>x == y</code></td><td><code>x === y</code></td></tr>
</tbody>
</table>
<table>
<thead>
<tr><th>不相等</th><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td>結構</td><td><code>x &lt;&gt; y</code></td><td><code>x != y</code></td></tr>
<tr><td>參考</td><td><code>x != y</code></td><td><code>x !== y</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" name=""></a><a href="#" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>區域範疇</h2>
<p>Reason 的詞法範疇與 OCaml 一樣，但是 let 繫結的句法類似 &quot;區域範疇&quot;，大多數開發者所熟悉。 在 Reason，範疇使用括號 <code>{}</code> 建立，範疇內可以包含 <code>let</code> 繫結及命令的指令，使用 <code>;</code> 分隔。 所有區塊都在最後一行評估，最後一行的分號可省略。 當你需串連多個 <code>;</code> 時候才需要 <code>{}</code> 括號。</p>
<table>
  <tr>
    <th>
      <p>
        OCaml
      </p>
    </th>
<pre><code class="hljs">&lt;th&gt;
  &lt;p&gt;
    Reason
  &lt;/p&gt;
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre>
let _ =
  let msg = "Hello" in
  print_string msg;
  let msg2 = "Goodbye" in
  print_string msg2</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;
</code></pre>
<p>{
let msg = &quot;Hello&quot;;
print_string(msg);
let msg2 = &quot;Goodbye&quot;;
print_string(msg2)
};</pre>
</td></p>
  </tr>
</table>
<p>Reason 的 <code>{}</code> 句法移除了多數主要在 OCaml 句法的痛點：</p>
<ul>
<li>完全刪除雙分號。</li>
<li>完全刪除 <code>begin</code>/<code>end</code>。</li>
<li>不存在臭名昭彰的命令剖析<a href="https://github.com/ocaml/ocaml/pull/278">問題</a>。</li>
<li>模組內部與區域範疇一致。</li>
</ul>
<h2><a class="anchor" aria-hidden="true" name="vs"></a><a href="#vs" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>區域範疇 Vs. 模組內部</h2>
<p>在 Reason，所有東西都可以用 <code>{}</code> 包在 <a href="#local-scope">區域範疇</a>及模組內部。 通常可以在兩個語境（contexts）之間剪下貼上程式碼。 在 OCaml，兩個語境之間的句法差異很大。 區域範疇需用 <code>in</code> 結尾，模組內部則不需要，命令敘述必須指派 <code>_</code> 或 <code>()</code> 又或者使用雙分號 <code>;;</code>。</p>
<table>
  <tr>
    <th>
      <p>
        OCaml 模組內部
      </p>
    </th>
<pre><code class="hljs">&lt;th&gt;
  &lt;p&gt;
    Reason 模組內部
  &lt;/p&gt;
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre>
let ten = 10
let () = imperativeFunc ten ten
let () = imperativeFunc 0 0</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;
</code></pre>
<p>let ten = 10;
imperativeFunc(ten, ten);
imperativeFunc(0, 0);</pre>
</td></p>
  </tr>
  <tr>
    <td>
      <pre>
let ten = 10;;
imperativeFunc ten ten;;
imperativeFunc 0 0;;</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  同上
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <th>
      <p>
        OCaml 區域範疇
      </p>
    </th>
<pre><code class="hljs">&lt;th&gt;
  &lt;p&gt;
    Reason 區域範疇
  &lt;/p&gt;
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre>
let ten = 10 in
let _ = imperativeFunc ten ten in
imperativeFunc 0 0</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  同上
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre>
let ten = 10 in begin
  imperativeFunc ten ten;
  imperativeFunc 0 0
end</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  同上
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre>
let ten = 10 in (
  imperativeFunc ten ten;
  imperativeFunc 0 0
)</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  同上
&lt;/td&gt;
</code></pre>
  </tr>
</table>
<h2><a class="anchor" aria-hidden="true" name="tuple-record"></a><a href="#tuple-record" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tuple 及 Record</h2>
<p>在 Reason，tuples 必須使用括號。</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let tup = 4, 5</code></td><td><code>let tup = (4, 5);</code></td></tr>
<tr><td><code>let tup = ((1: int), (2:int))</code></td><td><code>let tup = (1: int, 2:int);</code></td></tr>
<tr><td><code>fun ((a: int), (b: int)) -&gt; a</code></td><td><code>((a: int, b: int)) =&gt; a;</code></td></tr>
</tbody>
</table>
<p>在 Reason，record 值像是 JavaScript，使用 <code>:</code> 而不是 <code>=</code>。</p>
<table>
  <tr>
    <th>
      <p>
        OCaml
      </p>
    </th>
<pre><code class="hljs">&lt;th&gt;
  &lt;p&gt;
    Reason
  &lt;/p&gt;
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre>
let myRec = {x = 0; y = 10}</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;
</code></pre>
<p>let myRec = {x: 0, y: 10};</pre>
</td></p>
  </tr>
  <tr>
    <td>
      <pre>
let myFuncs = {
  myFun = (fun x -> x + 1);
  your = (fun a b -> a + b);
}</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;
</code></pre>
<p>let myFuncs = {
myFun: (x) =&gt; x + 1,
your: (a, b) =&gt; a + b
};</pre>
</td></table></p>
<pre><code class="hljs">&lt;h2&gt;
  Lists
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let list = [1; 2; 3]&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let list = [1, 2, 3]&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let list = hd :: tl&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let list = [hd, ...tl];&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h2&gt;
  型別定義
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml Tuple
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason Tuple
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type tuple = int * int&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type tuple = (int, int);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let tup: tuple = (10, 30)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let tup: tuple = (10, 30);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml Record
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason Record
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type r = {x: int; y: int}&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type r = {x: int, y: int};&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let myRec: r = {x = 0; y = 10}&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let myRec: r = {x: 0, y: 10};&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml 函式
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason 函式
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type func = int -&amp;gt; int&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type func = int =&amp;gt; int;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x: func = fun a -&amp;gt; a + 1&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x: func = (a) =&amp;gt; a + 1;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h2&gt;
  函式
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x a b = e&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = (a, b) =&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = fun a b -&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = (a, b) =&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = fun a -&amp;gt; fun b -&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = (a, b) =&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  單一參數比對函式
&lt;/h3&gt;

&lt;p&gt;
  OCaml 函式定義（&lt;code&gt;function |&lt;/code&gt;）可認定同等 &lt;code&gt;function a -&amp;gt; match a with ...&lt;/code&gt;。 Reason 也一樣，但是句法讓它更清楚是一個單一參數函式的延伸。 單一案例比對是一個簡單 lambda 的自然延伸，多種案例 lambda 是一個單一案例 lambda 的自然延伸。
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        形式
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      lambda
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>fun pat -&gt; e</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>fun pat =&gt; e</pre>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      單一比對案例
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>function | pat -&gt; e</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>fun | pat =&gt; e</pre>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      多種案例
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>function | pat -&gt; e
| pat2 -&gt; e</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>fun | pat =&gt; e
| pat2 =&gt; e</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  標註參數
&lt;/h3&gt;

&lt;p&gt;
  在 Reason 與 OCaml，引數的型別標註（以及其他）在括號內的最後加上 &lt;code&gt;:typeAnnotation&lt;/code&gt;。
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;reason&quot;&gt;(arg: argType) =&amp;gt; returnValue;
</code></pre>
<p></code></pre></p>
<pre><code class="hljs">&lt;pre&gt;&lt;code class=&quot;reason&quot;&gt;(arg: argType) =&amp;gt; (arg2: arg2Type) =&amp;gt; returnValue;
</code></pre>
<p></code></pre></p>
<pre><code class="hljs">&lt;pre&gt;&lt;code class=&quot;reason&quot;&gt;(arg: argType, arg2: arg2Type) =&amp;gt; returnValue;
</code></pre>
<p></code></pre></p>
<pre><code class="hljs">&lt;p&gt;
  當使用 &quot;超填 let 繫結&quot; 形式，Reason 與 OCaml 允許標註傳回型別。
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;(* OCaml *)
</code></pre>
<p>let myFunc (a:int) (b:int) :int * int = (a, b)
let myFunc (a:int) (b:int) :int list = [1]
let myFunc (a:int) (b:int) :int -&gt; int = fun x -&gt; x + a + b
</code></pre></p>
<pre><code class="hljs">&lt;pre&gt;&lt;code class=&quot;reason&quot;&gt;/* Reason */
</code></pre>
<p>let myFunc = (a: int, b: int) :(int, int) =&gt; (a, b);
let myFunc = (a: int, b: int) :list(int) =&gt; [1];
let myFunc = (a: int, b: int): (int =&gt; int) =&gt; (x) =&gt; x + a + b;
</code></pre></p>
<pre><code class="hljs">&lt;p&gt;
  因為 Reason 到處使用 &lt;code&gt;=&amp;gt;&lt;/code&gt;，只有一種情境傳回型別需要額外括號，就是傳回型別本身是函式型別。
&lt;/p&gt;

&lt;h3&gt;
  型別引數
&lt;/h3&gt;

&lt;h4&gt;
  OCaml
&lt;/h4&gt;

&lt;p&gt;
  OCaml 的型別引數（想做是 “泛型”），係由反轉順序套用。
&lt;/p&gt;

&lt;p&gt;
  在 OCaml，存在某些不直覺的後果。
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let x: int list = [2]
</code></pre>
<p>type listOfListOfInts = int list list</p>
<p>(* 剖析成： *)
type listOfListOfInts = (int list) list
</code></pre></p>
<pre><code class="hljs">&lt;p&gt;
  當建構子接受多個引數時，更加奇怪。 多個引數必須使用括號及逗點分隔，這括號不代表 tuples。 當建構型別實例時，例如 &lt;code&gt;(int, string) tuple&lt;/code&gt;，也必須使用括號/逗點形式。
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;type ('a, 'b) tuple = 'a * 'b
</code></pre>
<p>type listOfTuplesOfStringAndInt = (string, int) tuple list</p>
<p>(* Which is parsed as: *)
type listOfTuplesOfStringAndInt = ((string, int) tuple) list</p>
<p>(* Which allows a list of (tuples of (string and int)) *)
let tuples: listOfTuplesOfStringAndInt = [(&quot;asdf&quot;, 3)]
</code></pre></p>
<pre><code class="hljs">&lt;h4&gt;
  Reason
&lt;/h4&gt;

&lt;p&gt;
  總之，Reason 幾乎統一所有語法成簡單的&quot;函式應用&quot;風格，表示型別參數也遵循相同逗點分隔的樣式。 結果是可以少學習一些句法樣式。
&lt;/p&gt;

&lt;p&gt;
  例如，想像 &lt;code&gt;list&lt;/code&gt; 當作&quot;函式&quot;，接受一個型別傳回新的型別。 type and returns a new type.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let x: int list = [2]
type listOfListOfInts = int list list
type ('a, 'b) tup = ('a * 'b)
type pairs = (int, int) tup list
let tuples: pairs = [(2, 3)]</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let x: list(int) = [2];
type listOfListOfInts = list(list(int));
type tup('a, 'b) = ('a, 'b);
type pairs = list(tup(int, int));
let tuples: pairs = [(2, 3)];</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h2&gt;
  Tuples 作為型別參數
&lt;/h2&gt;

&lt;p&gt;
  因為 OCaml 使用括號及逗點來表示型別建構子的多個參數，當參數本身是 tuple 時容易混淆。 OCaml 中，很難記住接受多個參數跟單個 tuple 參數的差別。
&lt;/p&gt;

&lt;p&gt;
  下列範例展示傳遞&lt;em&gt;兩個&lt;/em&gt;型別參數到 &lt;code&gt;pair&lt;/code&gt; 和&lt;em&gt;單一&lt;/em&gt;必須是 tuple 的型別參數。
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type intPair = (int, int) pair&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type intPair = pair(int, int)&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type pairList = (int * int) list&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type pairList = list((int, int))&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    在 Reason，代表 tuples 或 tuple 型別的語法看起來都像 tuples。
  &lt;/li&gt;
  &lt;li&gt;
    在 Reason，代表 records 或 record 型別的語法看起來都像 records。
  &lt;/li&gt;
  &lt;li&gt;
    其他所有都是應用程式的句法樣式（逗點分隔參數）。
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;
  變異
&lt;/h2&gt;

&lt;h5&gt;
  OCaml
&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    OCaml 已經預期建構子參數是 tuple 形式，當單一建構子預期單一參數且參數&lt;em&gt;為&lt;/em&gt; tuple 型別容易混淆。
  &lt;/li&gt;
  &lt;li&gt;
    更加混淆的是，建構子&lt;em&gt;實際上&lt;/em&gt;不接受 tuples 時，語法看起來像是 tuples。
  &lt;/li&gt;
  &lt;li&gt;
    有時候初始多個參數的建構子的語法跟建構單一參數，參數為 tuple 的建構子語法重疊 - 當你實際上不是使用 tuple 時，看起來&lt;em&gt;完全&lt;/em&gt;像是&lt;em&gt;在&lt;/em&gt;使用 tuple。
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;
  Reason
&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    變異建構子型別預期用逗點分隔列出，使用括號來分組優先順序（&lt;strong&gt;其他&lt;/strong&gt;也是一樣）。
  &lt;/li&gt;
  &lt;li&gt;
    建構變異的實體（如你所猜想）遵循函式應用風格（逗點分隔列出）。
  &lt;/li&gt;
  &lt;li&gt;
    Tuples &lt;strong&gt;永遠&lt;/strong&gt;&lt;em&gt;看起來&lt;/em&gt;像是 tuples，其他看起來像是 tuple 的 &lt;em&gt;就是&lt;/em&gt; tuple。
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>type myVariant =
| HasNothing
| HasSingleInt of int
| HasSingleTuple of (int * int)
| HasMultipleInts of int * int
| HasMultipleTuples of (int * int) * (int * int)
</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>type myVariant =
| HasNothing
| HasSingleInt(int)
| HasSingleTuple((int, int))
| HasMultipleInts(int, int)
| HasMultipleTuples((int, int), (int, int));
</pre>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let a = HasSingleInt 10
let a = HasSingleTuple (10, 10)
let a = HasMultipleInts (10, 10)
let a = HasMultipleTuples ((10, 10), (10, 10))
</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let a = HasSingleInt(10);
let a = HasSingleTuple((10, 10));
let a = HasMultipleInts(10, 10);
let a = HasMultipleTuples((10, 10), (10, 10));
</pre>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let res x = match x with
| HasNothing -&gt; 0
| HasSingleInt x -&gt; 0
| HasSingleTuple (x, y) -&gt; 0
| HasMultipleInts (x, y) -&gt; 0
| HasMultipleTuples ((x, y), (q, r)) -&gt; 0
</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let res = (x) =&gt;
switch (x) {
| HasNothing =&gt; 0
| HasSingleInt(x) =&gt; 0
| HasSingleTuple((x, y)) =&gt; 0
| HasMultipleInts(x, y) =&gt; 0
| HasMultipleTuples((x, y), (q, r)) =&gt; 0
};
</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h2&gt;
  樣式匹配
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let res = match x with
| A (x, y) -&gt; match y with
| None -&gt; 0
| Some i -&gt; 10
| B (x, y) -&gt; 0</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let res = switch (x) {
| A((x, y)) =&gt; switch (y) {
| None =&gt; 0
| Some(i) =&gt; 10
}
| B((x, y)) =&gt; 0
};</p>
</pre>
        </td>
      </tr>
    </table>
<pre><code class="hljs">&lt;p&gt;
  你能發現 OCaml 範例的錯誤嗎？ 這是 OCaml 開發者中最常見的錯誤之一。 巢狀 &lt;code&gt;match&lt;/code&gt; &lt;em&gt;必須&lt;/em&gt;包裝在括號裡面，否則&lt;code&gt;某些&lt;/code&gt;情況會當作隸屬於外圍 &lt;code&gt;match&lt;/code&gt;。 視覺上，實際是：
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let res = match x with
</code></pre>
<p>| A (x, y) -&gt; match y with
| None -&gt; 0
| Some i -&gt; 10
| B (x, y) -&gt; 0
</code></pre></p>
<pre><code class="hljs">&lt;p&gt;
  Reason 強制在 &lt;code&gt;switch&lt;/code&gt; 使用 &lt;code&gt;{}&lt;/code&gt; 來避免這個問題。
&lt;/p&gt;

&lt;h2&gt;
  模組和標記式
&lt;/h2&gt;

&lt;h3&gt;
  定義
&lt;/h3&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module type MySig = sig
type t = int
val x: int
end
module MyModule: MySig = struct
type t = int
let x = 10
end
module MyModule = struct
module NestedModule = struct
let msg = &quot;hello&quot;;
end
end
</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module type MySig = {
type t = int;
let x: int;
};
module MyModule: MySig = {
type t = int;
let x = 10;
};
module MyModule = {
module NestedModule = {
let msg = &quot;hello&quot;;
};
};
</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  Functors 型別
&lt;/h3&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module type FType =
functor (A: ASig) -&gt;
functor (B: BSig) -&gt; Result
</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module type FType =
(A: ASig) =&gt;
(B: BSig) =&gt; Result;
</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h2&gt;
  Functors
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module F =
functor (A: ASig) -&gt;
functor (B: BSig) -&gt; struct end</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module F =
(A: ASig) =&gt;
(B: BSig) =&gt; {};</pre>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module F = functor (A: ASig) (B: BSig) -&gt; struct end</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module F = (A: ASig, B: BSig) =&gt; {};</pre>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module F (A: ASig) (B: BSig) = struct end</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module F = (A: ASig, B: BSig) =&gt; {};</pre>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module Res = F(A)(B)</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module Res = F(A, B);</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h2&gt;
  各種改進
&lt;/h2&gt;

&lt;p&gt;
  OCaml 並不要求連續 &lt;code&gt;(a;b;c;d)&lt;/code&gt; 或 tuples &lt;code&gt;(x,y)&lt;/code&gt; 使用括號，所以終結其他非常方便語法規則。 由於 Reason 使用 &lt;code&gt;{}&lt;/code&gt; 圍起連續或 let 繫結，且 Reason 要求 &lt;code&gt;()&lt;/code&gt; 圍著 tuples，其他許多語法建構更加直覺表達，不需要額外括號。
&lt;/p&gt;

&lt;h3&gt;
  Record 的 Lambdas 欄位不再需要額外括號
&lt;/h3&gt;

&lt;p&gt;
  這是個受歡迎的改善，因為當函式傳回值是個 tuple 時，需要中置逗點 &lt;code&gt;,&lt;/code&gt;，使用者看到的 OCaml 型別錯誤時很容易混淆。
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let myFuncs = {
myFun = (fun x -&gt; x + 1);
your = (fun a b -&gt; a + b);
}</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let myFuncs = {
myFun: (x) =&gt; x + 1,
your: (a, b) =&gt; a + b
};</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  符合結果的 Lambdas 不再需要額外括號
&lt;/h3&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let x = match prnt with
| None -&gt; fun a -&gt; blah
(* Extra () required ! *)
| Some &quot;_&quot; -&gt; (fun a -&gt; ())
| Some &quot;ml&quot; -&gt; blah
</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let x =
switch (prnt) {
| None =&gt; (a) =&gt; blah
| Some(&quot;_&quot;) =&gt; (a) =&gt; ()
| Some(&quot;ml&quot;) =&gt; blah
};</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  Lambdas 和 tuples 的型別註記不再需要額外括號
&lt;/h3&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let tuple = ((fun x -&amp;gt; x), 20)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let tuple = ((x) =&amp;gt; x, 20);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let tuple = ((&quot;hi&quot;: string), (20: int))&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let tuple = (&quot;hi&quot;: string, 20: int);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h2&gt;
  各種差異
&lt;/h2&gt;

&lt;h3&gt;
  &lt;code&gt;as&lt;/code&gt; 優先順序
&lt;/h3&gt;

&lt;p&gt;
  Reason 中，&lt;code&gt;as&lt;/code&gt; 比 &lt;code&gt;|&lt;/code&gt; 有更高優先順序。可以新增 &lt;code&gt;as&lt;/code&gt; 別名供樣式匹配整個列使用。
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let ppp = match MyThing 20 with
| (MyThing x as ppp)
| (YourThing x as ppp) -&gt; ppp;
</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let ppp =
switch (MyThing(20)) {
| MyThing(x) as ppp
| YourThing(x) as ppp =&gt; ppp
};
</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  可變的 Record 欄位改變
&lt;/h3&gt;

&lt;p&gt;
  因為在 Reason 相等與否定已經更加一致，可變欄位的修改可以使用 &lt;code&gt;=&lt;/code&gt; 操作子。
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;myRec.field &amp;lt;- &quot;next&quot;&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;myRec.field = &quot;next&quot;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  前置運算子
&lt;/h3&gt;

&lt;p&gt;
  Reason 的 &lt;code&gt;!&lt;/code&gt; 用做布林的 &lt;code&gt;not&lt;/code&gt;。取值使用後置 &lt;code&gt;^&lt;/code&gt;。
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(foo.bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo.bar^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(foo#bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo#bar^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(!foo.bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo^.bar^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(!foo#bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = (foo^)#bar^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(!(foo.bar))&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo.bar^ ^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(!(foo#bar))&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo#bar^ ^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !!(foo.bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = !!foo.bar;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !!(foo#bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = !!foo#bar;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !~(foo.bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = !~foo.bar;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !~(foo#bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = !~foo#bar;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  註解轉義
&lt;/h3&gt;

&lt;p&gt;
  因為 Reason 使用 C-風格註解，某些不清楚的自訂前置/中置操作子必須用不同的方式撰寫。 前置/中置操作子的規則跟 OCaml 語法一樣，但有下列例外情況：
&lt;/p&gt;

&lt;p&gt;
  具體來說，前置/中置操作子的第一個字元是星號或正斜杠，必須使用反斜線跳脫。 當加入到 AST 會剖析&lt;em&gt;除了&lt;/em&gt;反斜線的部份。 當重新印出時，跳脫反斜線將會自動加回。
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let (/*) a b = a + b&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let (/\*) a b =&amp;gt; a + b;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = 12 /-* 23 /-* 12&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = 12 /-* 23 /-* 12;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let y = (/*) a b&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let y = a /\* b;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let (!=*) q r = q + r&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let ( !=* ) = (q, r) =&amp;gt; q + r;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let res = q (!=*) r&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let res = q(( !=* ), r);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let (!=/*) q r = q + r&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let ( !=/\* ) = (q, r) =&amp;gt; q + r;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let res = q (!=/*) r&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let res = q(( !=/\* ), r);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  重新命名運算子（Operator）
&lt;/h3&gt;

&lt;p&gt;
  如果 Reason 使用 &lt;code&gt;==&lt;/code&gt; 代表 OCaml 的 &lt;code&gt;=&lt;/code&gt;，&lt;code&gt;===&lt;/code&gt; 代表 OCaml 的 &lt;code&gt;==&lt;/code&gt;，那麼 Reason 如何代表 OCaml 的 &lt;code&gt;===&lt;/code&gt; 符號 （如果有定義了）？ Reason 提供一個方法！ &quot;跳脫&quot;三個相等符號！
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      標識符
    &lt;/th&gt;
    
    &lt;th&gt;
      涵義
    &lt;/th&gt;
    
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&quot;===&quot;&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      自訂值
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;x === y&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;x \=== y&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  REPL
&lt;/h3&gt;

&lt;p&gt;
  Reason 的 REPL &lt;a href=&quot;extra-goodies.md#repl&quot;&gt;&lt;code&gt;rtop&lt;/code&gt;&lt;/a&gt;（客製化的 &lt;a href=&quot;https://github.com/diml/utop&quot;&gt;&lt;code&gt;utop&lt;/code&gt;&lt;/a&gt;），透過一個 &lt;code&gt;;&lt;/code&gt; 分號來送出每個輸入。 OCaml 的 REPL 要求兩個分號 &lt;code&gt;;;&lt;/code&gt;。
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;;;&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="faq.html">← 常見問題</a><a class="docs-next button" href="newcomer-examples.html">新手示範 →</a></div></div></div></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react'
              });
            </script></body></html>