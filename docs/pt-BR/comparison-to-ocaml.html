<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>Comparação com OCaml · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Comparação com OCaml · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/index.html"/><meta property="og:description" content="Se você veio da OCaml ou é um recém-chegado lendo um tutorial escrito na OCaml, este guia é para você! Mas não se esqueça de que [ reason-tools](https://github.com/reasonml/reason-tools) pode converter entre sintaxe OCaml e Reason em tempo real."/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/arduino-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/dummy.svg"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/docs/pt-BR/quickstart-javascript.html" target="_self">Documentação</a></li><li><a href="/pt-BR/try.html" target="_self">Tentar</a></li><li><a href="/api/index.html" target="_self">API</a></li><li><a href="/docs/pt-BR/community.html" target="_self">Comunidade</a></li><li><a href="/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg"/>Português (Brasil)</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/ja">日本語</a></li><li><a href="/en">English</a></li><li><a href="/de">Deutsch</a></li><li><a href="/es-ES">Español</a></li><li><a href="/fr">Français</a></li><li><a href="/ko">한국어</a></li><li><a href="/ru">Русский</a></li><li><a href="/uk">Українська</a></li><li><a href="/zh-CN">中文</a></li><li><a href="/zh-TW">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank">Ajude a Traduzir</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Extra</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Introdução</h3><ul><li class="navListItem"><a class="navItem" href="/docs/pt-BR/what-and-why.html">O quê &amp; porquê</a></li></ul></div><div class="navGroup navGroupActive"><h3>Configuração do Editor</h3><ul><li class="navListItem"><a class="navItem" href="/docs/pt-BR/global-installation.html">Instalação Global</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/editor-plugins.html">Plugins para Editores</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/extra-goodies.html">Miscelânea</a></li></ul></div><div class="navGroup navGroupActive"><h3>Noções Básicas da Linguagem</h3><ul><li class="navListItem"><a class="navItem" href="/docs/pt-BR/overview.html">Visão geral</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/let-binding.html">Let Binding</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/type.html">Tipo!</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/string-and-char.html">String &amp; Char</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/boolean.html">Boolean</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/integer-and-float.html">Inteiro &amp; Float</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/tuple.html">Tupla</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/record.html">Record</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/variant.html">Variantes!</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/list-and-array.html">Lista &amp; Array</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/function.html">Função</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/if-else.html">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/more-on-type.html">Mais sobre Tipos</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/destructuring.html">Destructuring</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/pattern-matching.html">Correspondência de Padrões!</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/mutation.html">Mutação</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/imperative-loops.html">Loops Imperativos</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/jsx.html">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/external.html">External</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/exception.html">Exceção</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/object.html">Objeto</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/module.html">Módulos</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/promise.html">Promise</a></li></ul></div><div class="navGroup navGroupActive"><h3>JavaScript</h3><ul><li class="navListItem"><a class="navItem" href="/docs/pt-BR/quickstart-javascript.html">Introdução</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/interop.html">Interoperabilidade</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/syntax-cheatsheet.html">Sintaxe</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/libraries.html">Bibliotecas</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/converting-from-js.html">Convertendo de JS</a></li></ul></div><div class="navGroup navGroupActive"><h3>Nativo</h3><ul><li class="navListItem"><a class="navItem" href="/docs/pt-BR/native.html">Nativo</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/quickstart-ocaml.html">Introdução</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/convert-from-ocaml.html">Convertendo de OCaml</a></li></ul></div><div class="navGroup navGroupActive"><h3>Extra</h3><ul><li class="navListItem"><a class="navItem" href="/docs/pt-BR/faq.html">Perguntas Frequentes</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/docs/pt-BR/comparison-to-ocaml.html">Comparação com OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/newcomer-examples.html">Exemplos para Iniciantes</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/project-structure.html">Estrutura de Projeto</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/pt-BR" target="_blank">Translate</a><h1>Comparação com OCaml</h1></header><article><div><span><p>Se você veio da OCaml ou é um recém-chegado lendo um tutorial escrito na OCaml, este guia é para você! Mas não se esqueça de que <a href="https://github.com/reasonml/reason-tools"> reason-tools</a> pode converter entre sintaxe OCaml e Reason em tempo real.</p>
<h2><a class="anchor" aria-hidden="true" name="comentarios"></a><a href="#comentarios" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Comentários</h2>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>(* OCaml (*nest*) *)</code></td><td><code>/* Reason /*nest*/ */</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" name="renomeando-operadores"></a><a href="#renomeando-operadores" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Renomeando Operadores</h2>
<p>Reason tem todos os operadores infixos da OCaml, mas alguns deles são expressos de maneira diferente. No Reason, igualdade estrutural é escrita com <code>= =</code> e igualdade referencial (física) é escrita com <code>=</code>. No Reason, para obter a correspondente desigualdade, simplesmente troca-se o primeiro caractere por um caractere de <code>!</code> (exclamação). (<code>!=</code> de desigualdade estrutural, e <code>!==</code> para desigualdade de referência).</p>
<table>
<thead>
<tr><th>Igualdade</th><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td>Estrutural</td><td><code>x = y</code></td><td><code>x == y</code></td></tr>
<tr><td>Referêncial</td><td><code>x == y</code></td><td><code>x === y</code></td></tr>
</tbody>
</table>
<table>
<thead>
<tr><th>Desigualdade</th><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td>Estrutural</td><td><code>x &lt;&gt; y</code></td><td><code>x != y</code></td></tr>
<tr><td>Referêncial</td><td><code>x != y</code></td><td><code>x !== y</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" name="escopo-local"></a><a href="#escopo-local" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Escopo Local</h2>
<p>O escopo léxico do Reason é exatamente igual a da OCaml, mas deixe as ligações sintaticamente assemelhando-se aos &quot;escopos de bloco&quot;, que são mais familiar para muitos desenvolvedores. No Reason, eles são criados com chaves <code>{}</code>, que podem conter tanto <code>let</code> ligações e comandos imperativos, separados por <code>;</code>. Todos os blocos avaliam a última linha e o ponto e vírgula na última linha é opcional. <code>{}</code> chaves só são necessárias se você tiver mais de um item para encadear via <code>;</code>.</p>
<table>
  <tr>
    <th>
      <p>
        OCaml
      </p>
    </th>
<pre><code class="hljs">&lt;th&gt;
  &lt;p&gt;
    Reason
  &lt;/p&gt;
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <code>&lt;pre>
let _ =
  let msg = "Hello" in
  print_string msg;
  let msg2 = "Goodbye" in
  print_string msg2&lt;/pre></code>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>{
let msg = &quot;Hello&quot;;
print_string(msg);
let msg2 = &quot;Goodbye&quot;;
print_string(msg2)
};&lt;/pre&gt;</code>
</td></p>
  </tr>
</table>
<p>A sintaxe <code>{}</code> do Reason remove muitos pontos de dor (pontos fracos) comummente relatados na sintaxe do OCaml:</p>
<ul>
<li>Os pontos-e-vírgulas duplos foram completamente removidos.</li>
<li><code>início</code>/<code>fim</code> foi removido completamente.</li>
<li>Parâmetros imperiais infames <a href="https://github.com/ocaml/ocaml/pull/278">issue</a> se foram.</li>
<li>Body de módulos e escopo local foram unificados.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" name="escopo-local-vs-corpo-de-modulo"></a><a href="#escopo-local-vs-corpo-de-modulo" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Escopo Local Vs. Corpo de Módulo</h2>
<p>No Reason, tudo que puder ocorrer entre <code>{}</code> nos <a href="#local-scope">Escopos Locais</a> e nos corpos de módulos. Você geralmente pode até cortar/colar código entre os dois contextos. Em OCaml, as sintaxes para os dois contextos são muito diferentes. Escopo local requer <code>in</code> à direita, mas corpos de módulos não e algumas declarações imperativas devem ser atribuídas a <code>_</code> ou <code>()</code>, ou então usam <code>;;</code>.</p>
<table>
  <tr>
    <th>
      <p>
        Corpo do módulo OCaml
      </p>
    </th>
<pre><code class="hljs">&lt;th&gt;
  &lt;p&gt;
    Corpo do módulo Reason
  &lt;/p&gt;
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <code>&lt;pre>
let ten = 10
let () = imperativeFunc ten ten
let () = imperativeFunc 0 0&lt;/pre></code>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let ten = 10;
imperativeFunc(ten, ten);
imperativeFunc(0, 0);&lt;/pre&gt;</code>
</td></p>
  </tr>
  <tr>
    <td>
      <code>&lt;pre>
let ten = 10;;
imperativeFunc ten ten;;
imperativeFunc 0 0;;&lt;/pre></code>
    </td>
<pre><code class="hljs">&lt;td&gt;
  Mesmo que acima
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <th>
      <p>
        Escopo Local OCaml
      </p>
    </th>
<pre><code class="hljs">&lt;th&gt;
  &lt;p&gt;
    Escopo Local Reason
  &lt;/p&gt;
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <code>&lt;pre>
let ten = 10 in
let _ = imperativeFunc ten ten in
imperativeFunc 0 0&lt;/pre></code>
    </td>
<pre><code class="hljs">&lt;td&gt;
  mesmo que acima
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <code>&lt;pre>
let ten = 10 in begin
  imperativeFunc ten ten;
  imperativeFunc 0 0
end&lt;/pre></code>
    </td>
<pre><code class="hljs">&lt;td&gt;
  mesmo que acima
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <code>&lt;pre>
let ten = 10 in (
  imperativeFunc ten ten;
  imperativeFunc 0 0
)&lt;/pre></code>
    </td>
<pre><code class="hljs">&lt;td&gt;
  mesmo que acima
&lt;/td&gt;
</code></pre>
  </tr>
</table>
<h2><a class="anchor" aria-hidden="true" name="tupla-e-record"></a><a href="#tupla-e-record" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tupla e Record</h2>
<p>No Reason, tuplas sempre requerem parênteses.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let tup = 4, 5</code></td><td><code>let tup = (4, 5);</code></td></tr>
<tr><td><code>let tup = ((1: int), (2:int))</code></td><td><code>let tup = (1: int, 2:int);</code></td></tr>
<tr><td><code>fun ((a: int), (b: int)) -&gt; a</code></td><td><code>((a: int, b: int)) =&gt; a;</code></td></tr>
</tbody>
</table>
<p>In Reason, record values resemble JavaScript, using <code>:</code> instead of <code>=</code>.</p>
<table>
  <tr>
    <th>
      <p>
        OCaml
      </p>
    </th>
<pre><code class="hljs">&lt;th&gt;
  &lt;p&gt;
    Reason
  &lt;/p&gt;
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <code>&lt;pre>
let myRec = {x = 0; y = 10}&lt;/pre></code>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let myRec = {x: 0, y: 10};&lt;/pre&gt;</code>
</td></p>
  </tr>
  <tr>
    <td>
      <code>&lt;pre>
let myFuncs = {
  myFun = (fun x -> x + 1);
  your = (fun a b -> a + b);
}&lt;/pre></code>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let myFuncs = {
myFun: (x) =&gt; x + 1,
your: (a, b) =&gt; a + b
};&lt;/pre&gt;</code>
</td></table></p>
<pre><code class="hljs">&lt;h2&gt;
  Listas
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let list = [1; 2; 3]&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let list = [1, 2, 3]&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let list = hd :: tl&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let list = [hd, ...tl];&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h2&gt;
  Definições de Tipo
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      Tupla OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Tupla Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type tuple = int * int&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type tuple = (int, int);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let tup: tuple = (10, 30)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let tup: tuple = (10, 30);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      Registro de OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Registro do Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type r = {x: int; y: int}&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type r = {x: int, y: int};&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let myRec: r = {x = 0; y = 10}&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let myRec: r = {x: 0, y: 10};&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      Funções no OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Funções no Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type func = int -&amp;gt; int&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type func = int =&amp;gt; int;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x: func = fun a -&amp;gt; a + 1&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x: func = (a) =&amp;gt; a + 1;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h2&gt;
  Funções
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x a b = e&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = (a, b) =&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = fun a b -&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = (a, b) =&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = fun a -&amp;gt; fun b -&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = (a, b) =&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  Funções com casamento de argumento único
&lt;/h3&gt;

&lt;p&gt;
  OCaml tem uma definição de função (&lt;code&gt;function |&lt;/code&gt;) que é considerado como equivalente de &lt;code&gt;function a -&amp;gt; match a with ...&lt;/code&gt;. Reason tem o mesmo, mas a sintaxe deixa claro como é na verdade uma extensão da função de argumento único. A correspondência de caso único é uma extensão natural do lambda simples, e o lambda múltiplo é uma extensão natural do lambda de caso único.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        Form
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      lambda
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>fun pat -&gt; e&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>fun pat =&gt; e&lt;/pre&gt;</code>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      caso de correspondência única
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>function | pat -&gt; e&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>fun | pat =&gt; e&lt;/pre&gt;</code>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      múltiplos casos
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>function | pat -&gt; e
| pat2 -&gt; e&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>fun | pat =&gt; e
| pat2 =&gt; e&lt;/pre&gt;</code>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  Anotando Argumentos
&lt;/h3&gt;

&lt;p&gt;
  Tanto o Reason como OCaml, argumentos são anotados com tipos por (como acontece com tudo o resto), envolvê-los entre parênteses depois acrescentando &lt;code&gt;: typeAnnotation&lt;/code&gt;.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;reason&quot;&gt;(arg: tipoDeArg) =&amp;gt; valorDeRetorno;
</code></pre>
<p></code></pre></p>
<pre><code class="hljs">&lt;pre&gt;&lt;code class=&quot;reason&quot;&gt;(arg: tipoDeArg) =&amp;gt; (arg2: tipoDeArg2) =&amp;gt; valorDeRetorno;
</code></pre>
<p></code></pre></p>
<pre><code class="hljs">&lt;pre&gt;&lt;code class=&quot;reason&quot;&gt;(arg: tipoDeArg, arg2: tipoDeArg2) =&amp;gt; valorDeRetorno;
</code></pre>
<p></code></pre></p>
<pre><code class="hljs">&lt;p&gt;
  Tanto o Reason como OCaml permitem anotar o tipo de retorno, quando usando a forma &quot;super sugared let binding&quot;.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;(* OCaml *)
</code></pre>
<p>let myFunc (a:int) (b:int) :int * int = (a, b)
let myFunc (a:int) (b:int) :int list = [1]
let myFunc (a:int) (b:int) :int -&gt; int = fun x -&gt; x + a + b
</code></pre></p>
<pre><code class="hljs">&lt;pre&gt;&lt;code class=&quot;reason&quot;&gt;/* Reason */
</code></pre>
<p>let myFunc = (a: int, b: int): (int, int) =&gt; (a, b);
let myFunc = (a: int, b: int): list(int) =&gt; [1];
let myFunc = (a: int, b: int): (int =&gt; int) =&gt; (x) =&gt; x + a + b;
</code></pre></p>
<pre><code class="hljs">&lt;p&gt;
  Porque estamos usando &lt;code&gt;=&amp;gt;&lt;/code&gt; para todas as funções no Reason, há um caso onde precisamos adicionar um parenteses extra em torno de um tipo de retorno que é em si um tipo de função.
&lt;/p&gt;

&lt;h3&gt;
  Parâmetros de Tipo
&lt;/h3&gt;

&lt;h4&gt;
  OCaml
&lt;/h4&gt;

&lt;p&gt;
  Aplicações do tipo do OCaml (pense &quot;genéricas&quot;), são aplicadas na ordem inversa.
&lt;/p&gt;

&lt;p&gt;
  Com OCaml, existem algumas consequências não intuitivas para isso.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let x: int list = [2]
</code></pre>
<p>type listaDeListaDeInts = int list list</p>
<p>(* Traduzido como: *)
type listaDeListaDeInts = (int list) list
</code></pre></p>
<pre><code class="hljs">&lt;p&gt;
  As coisas ficam ainda mais estranhas quando parâmetros de tipo aceitam parâmetros múltiplos. Argumentos múltiplos requerem parênteses e vírgulas para separar os parâmetros de tipo, mas esses parênteses não representam tuplas. A forma de parênteses/vírgula também deve ser dada ao construir instâncias de tipo tais como &lt;code&gt;(int, string) tupla&lt;/code&gt;.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;type ('a, 'b) tupla = 'a * 'b
</code></pre>
<p>type listaDeTuplasDeStringEInt = (string, int) tupla list</p>
<p>(* Que é traduzido como: *)
type listaDeTuplasDeStringEInt = ((string, int) tupla) list</p>
<p>(* Que permite uma lista de (tuplas de (string e int)) *)
let tuplas: listaDeTuplasDeStringEInt = [(&quot;asdf&quot;, 3)]
</code></pre></p>
<pre><code class="hljs">&lt;h4&gt;
  Reason
&lt;/h4&gt;

&lt;p&gt;
  Em resumo, o Reason unifica quase toda a sintaxe no estilo simples de &quot;aplicação de função&quot;, o que significa que os parâmetros de tipo seguem o mesmo padrão separado por vírgula visto em qualquer outro lugar na sintaxe. Isso resulta em menos padrões sintáticos para aprender.
&lt;/p&gt;

&lt;p&gt;
  Por exemplo, você pode imaginar &lt;code&gt;list&lt;/code&gt; ser uma &quot;função&quot; para tipos que aceita um tipo e retorna um novo tipo.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let x: int list = [2]
type listOfListOfInts = int list list
type ('a, 'b) tup = ('a * 'b)
type pairs = (int, int) tup list
let tuples: pairs = [(2, 3)]&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let x: list(int) = [2];
type listOfListOfInts = list(list(int));
type tup('a, 'b) = ('a, 'b);
type pairs = list(tup(int, int));
let tuples: pairs = [(2, 3)];&lt;/pre&gt;</code>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h2&gt;
  Tuplas Como Parâmetros de Tipo
&lt;/h2&gt;

&lt;p&gt;
  Como o OCaml usa parenteses e vírgulas para representar argumentos múltiplos para construtores de tipo, é confuso quando um dos argumentos para um construtor de tipo é uma tupla ele próprio. Na OCaml, é difícil lembrar a diferença entre um construtor de tipos aceitando vários argumentos e um construtor de tipo aceitando um único argumento que acontece de ser um tupla.
&lt;/p&gt;

&lt;p&gt;
  Os exemplos a seguir mostram a diferença entre passar &lt;em&gt;dois &lt;/em&gt; tipos de parâmetros para &lt;code&gt;par&lt;/code&gt;, e um parâmetro de tipo &lt;em&gt;single&lt;/em&gt; que na verdade é um tuple.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type intPar = (int, int) pair&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type intPar = pair(int, int)&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type listaPar = (int * int) list&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type listaPar = list((int, int))&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    No Reason, sintaxes que representam tuplas ou tipos de tuplas, sempre se parecem com tuplas.
  &lt;/li&gt;
  &lt;li&gt;
    No Reason, sintaxes que representam registros ou tipos de registros, sempre se parecem com registros.
  &lt;/li&gt;
  &lt;li&gt;
    Quase todo o resto usa o padrão sintático de aplicação de função (argumentos separados por vírgula).
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;
  Variantes
&lt;/h2&gt;

&lt;h5&gt;
  OCaml
&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    OCaml já espera que os tipos de argumentos do construtor sejam especificados no formulário de tuple, por isso fica confuso quando um único construtor espera um argumento único que &lt;em&gt;acontece&lt;/em&gt; de ser um tipo de tuple.
  &lt;/li&gt;
  &lt;li&gt;
    O que é ainda mais confuso é que os construtores não &lt;em&gt;realmente&lt;/em&gt; aceitam tuplas, ainda que a sintaxe pareça assemelhar-se tuplas.
  &lt;/li&gt;
  &lt;li&gt;
    Às vezes, a sintaxe para instanciar um construtor com vários argumentos sobrepõe a sintaxe para construir uma variante com um único argumento que acontece de ser uma tupla - então parece &lt;em&gt;exatamente&lt;/em&gt; que você &lt;em&gt;está&lt;/em&gt; fornecendo uma tupla quando você não está realmente fornecendo uma tupla.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;
  Reason
&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    Tipos de construtores de variantes devem ser listados como listas separadas por vírgulas, usando parênteses para preceder grupo (como com &lt;strong&gt; todo&lt;/strong&gt; resto).
  &lt;/li&gt;
  &lt;li&gt;
    Construir instâncias da variante (como você teria adivinhado) segue o estilo de aplicação de função (listas separadas por vírgulas).
  &lt;/li&gt;
  &lt;li&gt;
    Tuplas &lt;strong&gt;sempre&lt;/strong&gt; &lt;em&gt;parecem&lt;/em&gt; como tuplas e qualquer coisa que se pareça com uma tupla &lt;em&gt;é&lt;/em&gt; uma tupla.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>type myVariant =
| HasNothing
| HasSingleInt of int
| HasSingleTuple of (int * int)
| HasMultipleInts of int * int
| HasMultipleTuples of (int * int) * (int * int)
&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>type myVariant =
| HasNothing
| HasSingleInt(int)
| HasSingleTuple((int, int))
| HasMultipleInts(int, int)
| HasMultipleTuples((int, int), (int, int));
&lt;/pre&gt;</code>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let a = HasSingleInt 10
let a = HasSingleTuple (10, 10)
let a = HasMultipleInts (10, 10)
let a = HasMultipleTuples ((10, 10), (10, 10))
&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let a = HasSingleInt(10);
let a = HasSingleTuple((10, 10));
let a = HasMultipleInts(10, 10);
let a = HasMultipleTuples((10, 10), (10, 10));
&lt;/pre&gt;</code>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let res x = match x with
| HasNothing -&gt; 0
| HasSingleInt x -&gt; 0
| HasSingleTuple (x, y) -&gt; 0
| HasMultipleInts (x, y) -&gt; 0
| HasMultipleTuples ((x, y), (q, r)) -&gt; 0
&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let res = (x) =&gt;
switch (x) {
| HasNothing =&gt; 0
| HasSingleInt(x) =&gt; 0
| HasSingleTuple((x, y)) =&gt; 0
| HasMultipleInts(x, y) =&gt; 0
| HasMultipleTuples((x, y), (q, r)) =&gt; 0
};
&lt;/pre&gt;</code>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h2&gt;
  Casamento de Padrões
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let res = match x with
| A (x, y) -&gt; match y with
| None -&gt; 0
| Some i -&gt; 10
| B (x, y) -&gt; 0&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let res = switch (x) {
| A((x, y)) =&gt; switch (y) {
| None =&gt; 0
| Some(i) =&gt; 10
}
| B((x, y)) =&gt; 0
};
&lt;/pre&gt;</code>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;p&gt;
  Você consegue detectar o erro no exemplo OCaml? Este é um dos erros mais comuns entre os programadores OCaml. O &lt;code&gt;match&lt;/code&gt; aninhado &lt;em&gt;deve&lt;/em&gt; ser encapsulado entre parênteses, caso contrário o caso &lt;code&gt;Some&lt;/code&gt; é analisado como pertencente à correspondência &lt;code&gt;match&lt;/code&gt; externo. Visualmente, é na verdade:
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let res = match x with
</code></pre>
<p>| A (x, y) -&gt; match y with
| None -&gt; 0
| Some i -&gt; 10
| B (x, y) -&gt; 0
</code></pre></p>
<pre><code class="hljs">&lt;p&gt;
  Os casos obrigatórios de &lt;code&gt;{}&lt;/code&gt; em torno de &lt;code&gt;switch&lt;/code&gt; evitam esse problema.
&lt;/p&gt;

&lt;h2&gt;
  Módulos e Assinaturas
&lt;/h2&gt;

&lt;h3&gt;
  Definição
&lt;/h3&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>module type MySig = sig
type t = int
val x: int
end
module MyModule: MySig = struct
type t = int
let x = 10
end
module MyModule = struct
module NestedModule = struct
let msg = &quot;hello&quot;;
end
end
&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>module type MySig = {
type t = int;
let x: int;
};
module MyModule: MySig = {
type t = int;
let x = 10;
};
module MyModule = {
module NestedModule = {
let msg = &quot;hello&quot;;
};
};
&lt;/pre&gt;</code>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  Tipos de Funtores
&lt;/h3&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>module type FType =
functor (A: ASig) -&gt;
functor (B: BSig) -&gt; Result
&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>module type FType =
(A: ASig) =&gt;
(B: BSig) =&gt; Result;
&lt;/pre&gt;</code>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h2&gt;
  Funtores
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>module F =
functor (A: ASig) -&gt;
functor (B: BSig) -&gt; struct end&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>module F =
(A: ASig) =&gt;
(B: BSig) =&gt; {};&lt;/pre&gt;</code>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>module F = functor (A: ASig) (B: BSig) -&gt; struct end&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>module F = (A: ASig, B: BSig) =&gt; {};&lt;/pre&gt;</code>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>module F (A: ASig) (B: BSig) = struct end&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>module F = (A: ASig, B: BSig) =&gt; {};&lt;/pre&gt;</code>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>module Res = F(A)(B)&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>module Res = F(A, B);&lt;/pre&gt;</code>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h2&gt;
  Melhorias Variadas
&lt;/h2&gt;

&lt;p&gt;
  OCaml não requer parênteses ao redor de sequências &lt;code&gt;(a;b;c;d)&lt;/code&gt; ou tuplas &lt;code&gt;(x,y)&lt;/code&gt; então isso acaba impedindo a aplicação de várias outras regras sintáticas muito convenientes. Como o Reason sempre usa &lt;code&gt;{}&lt;/code&gt; para cercar sequências ou declarações let, e o Reason sempre requer o uso de &lt;code&gt;()&lt;/code&gt; cercando tuplas, muitos outros construtos de sintaxe são expressados de forma mais intuitiva, sem precisar de parênteses extras.
&lt;/p&gt;

&lt;h3&gt;
  Lambdas como campos de registros não precisam mais de parênteses extras
&lt;/h3&gt;

&lt;p&gt;
  Essa é uma melhoria bem-vinda porque os erros de tipo de OCaml que o usuário veriam eram muito confusos quando o sistema acreditava que o tipo de retorno da função seria uma tupla com vírgula &lt;code&gt;,&lt;/code&gt; infixa.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let myFuncs = {
myFun = (fun x -&gt; x + 1);
your = (fun a b -&gt; a + b);
}&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let myFuncs = {
myFun: (x) =&gt; x + 1,
your: (a, b) =&gt; a + b
};&lt;/pre&gt;</code>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  Lambdas como resultado de casamento de padrões não precisam mais de parênteses extras
&lt;/h3&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let x = match prnt with
| None -&gt; fun a -&gt; blah
(* Extra () required ! *)
| Some &quot;_&quot; -&gt; (fun a -&gt; ())
| Some &quot;ml&quot; -&gt; blah
&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let x =
switch (prnt) {
| None =&gt; (a) =&gt; blah
| Some(&quot;_&quot;) =&gt; (a) =&gt; ()
| Some(&quot;ml&quot;) =&gt; blah
};&lt;/pre&gt;</code>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  Lambdas e anotações de tipos em tuplas não requerem mais parênteses adicionais
&lt;/h3&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let tuple = ((fun x -&amp;gt; x), 20)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let tuple = ((x) =&amp;gt; x, 20);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let tuple = ((&quot;olar&quot;: string), (20: int))&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let tuple = (&quot;olar&quot;: string, 20: int);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h2&gt;
  Diferenças Variadas
&lt;/h2&gt;

&lt;h3&gt;
  Precedência de &lt;code&gt;as&lt;/code&gt;
&lt;/h3&gt;

&lt;p&gt;
  Em Reason, o &lt;code&gt;as&lt;/code&gt; tem maior precedência que a &lt;code&gt;|&lt;/code&gt; barra. Isso permite criar pseudônimos &lt;code&gt;as&lt;/code&gt; para linhas inteiras quando casando padrões.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let ppp = match MyThing 20 with
| (MyThing x as ppp)
| (YourThing x as ppp) -&gt; ppp;
&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let ppp =
switch (MyThing(20)) {
| MyThing(x) as ppp
| YourThing(x) as ppp =&gt; ppp
};
&lt;/pre&gt;</code>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  Atualizações de Campos de Registros Mutáveis
&lt;/h3&gt;

&lt;p&gt;
  Como igualdades e suas negações foram tornadas mais consistentes no Reason, o operador &lt;code&gt;=&lt;/code&gt; está disponível para atualização de campos mutáveis.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;myRec.field &amp;lt;- &quot;proximo&quot;&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;myRec.field = &quot;proximo&quot;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  Operadores prefixos
&lt;/h3&gt;

&lt;p&gt;
  No Reason, o operador &lt;code&gt;!&lt;/code&gt; é usado para a negação booleana (&lt;code&gt;not&lt;/code&gt;). O derreferenciamento usa o operador pósfixo &lt;code&gt;ˆ&lt;/code&gt;.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(foo.bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo.bar^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(foo#bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo#bar^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(!foo.bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo^.bar^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(!foo#bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = (foo^)#bar^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(!(foo.bar))&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo.bar^ ^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(!(foo#bar))&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo#bar^ ^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !!(foo.bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = !!foo.bar;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !!(foo#bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = !!foo#bar;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !~(foo.bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = !~foo.bar;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !~(foo#bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = !~foo#bar;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  Escapando Comentários
&lt;/h3&gt;

&lt;p&gt;
  Como o Reason usa comentários no estilo C, alguns operadores prefixos ou infixos obscuros precisam ser escritos de forma distinta. As regras para operadores prefixos ou infixos são as mesmas que na sintaxe de OCaml, com as seguintes exceções:
&lt;/p&gt;

&lt;p&gt;
  Especificamente, se qualquer caractere exceto o primeiro e um operador prefixo ou infixo é um asterisco ou uma barra, esse caractere deve ser escapado com uma barra invertida. Esses operadores serão analisados &lt;em&gt;sem&lt;/em&gt; a barra invertida quando adicionados à AST. Quando impressos, as barras invertidas de escape serão adicionadas de volta automaticamente.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let (/*) a b = a + b&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let (/\*) a b =&amp;gt; a + b;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = 12 /-* 23 /-* 12&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = 12 /-* 23 /-* 12;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let y = (/*) a b&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let y = a /\* b;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let (!=*) q r = q + r&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let ( !=* ) = (q, r) =&amp;gt; q + r;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let res = q (!=*) r&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let res = q(( !=* ), r);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let (!=/*) q r = q + r&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let ( !=/\* ) = (q, r) =&amp;gt; q + r;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let res = q (!=/*) r&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let res = q(( !=/\* ), r);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  Renomeando Operadores
&lt;/h3&gt;

&lt;p&gt;
  Se o Reason usa &lt;code&gt;==&lt;/code&gt; para representar o &lt;code&gt;=&lt;/code&gt; de OCaml, e usa o &lt;code&gt;===&lt;/code&gt; para representar o &lt;code&gt;==&lt;/code&gt; de OCaml, então como o Reason representaria o &lt;code&gt;===&lt;/code&gt; de OCaml (se tal operador fosse definido)? Reason dá um jeito! &quot;Escape&quot; o símbolo de igual triplo!
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      Identificador
    &lt;/th&gt;
    
    &lt;th&gt;
      Significado
    &lt;/th&gt;
    
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&quot;===&quot;&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      Valor personalizado
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;x === y&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;x \=== y&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  REPL
&lt;/h3&gt;

&lt;p&gt;
  Na REPL do Reason, &lt;a href=&quot;extra-goodies.md#repl&quot;&gt;&lt;code&gt;rtop&lt;/code&gt;&lt;/a&gt; (Uma versão customizada do &lt;a href=&quot;https://github.com/diml/utop&quot;&gt;&lt;code&gt;utop&lt;/code&gt;&lt;/a&gt;), cada entrada é submetida usando um único &lt;code&gt;;&lt;/code&gt; ponto e vírgula. A REPL do Ocaml precisa de dois pontos e vírgulas &lt;code&gt;;;&lt;/code&gt;.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;;;&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="faq.html">← Perguntas Frequentes</a><a class="docs-next button" href="newcomer-examples.html">Exemplos para Iniciantes →</a></div></div></div></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react'
              });
            </script></body></html>