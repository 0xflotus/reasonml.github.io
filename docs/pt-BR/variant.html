<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>Variantes! · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Variantes! · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/index.html"/><meta property="og:description" content="Eis a joia da coroa de estruturas de dados do Reason!"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/arduino-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/dummy.svg"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/docs/pt-BR/quickstart-javascript.html" target="_self">Documentação</a></li><li><a href="/pt-BR/try.html" target="_self">Experimentar</a></li><li><a href="/api/index.html" target="_self">API</a></li><li><a href="/docs/pt-BR/community.html" target="_self">Comunidade</a></li><li><a href="/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg"/>Português (Brasil)</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/ja">日本語</a></li><li><a href="/en">English</a></li><li><a href="/es-ES">Español</a></li><li><a href="/fr">Français</a></li><li><a href="/ko">한국어</a></li><li><a href="/ru">Русский</a></li><li><a href="/zh-CN">中文</a></li><li><a href="/zh-TW">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank">Ajude a Traduzir</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Language Basics</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Introdução</h3><ul><li class="navListItem"><a class="navItem" href="/docs/pt-BR/what-and-why.html">O quê &amp; porquê</a></li></ul></div><div class="navGroup navGroupActive"><h3>Configuração do Editor</h3><ul><li class="navListItem"><a class="navItem" href="/docs/pt-BR/global-installation.html">Instalação Global</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/editor-plugins.html">Plugins de Editores</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/extra-goodies.html">Miscelânea</a></li></ul></div><div class="navGroup navGroupActive"><h3>Noções Básicas da Linguagem</h3><ul><li class="navListItem"><a class="navItem" href="/docs/pt-BR/overview.html">Visão geral</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/let-binding.html">Let Binding</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/type.html">Tipo!</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/string-and-char.html">String &amp; Char</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/boolean.html">Boolean</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/integer-and-float.html">Inteiro &amp; Float</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/tuple.html">Tupla</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/record.html">Record</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/docs/pt-BR/variant.html">Variantes!</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/list-and-array.html">Lista &amp; Array</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/function.html">Função</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/if-else.html">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/more-on-type.html">Mais sobre Tipos</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/destructuring.html">Destructuring</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/pattern-matching.html">Correspondência de Padrões!</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/mutation.html">Mutação</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/imperative-loops.html">Loops Imperativos</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/jsx.html">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/external.html">External</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/exception.html">Exceção</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/object.html">Objeto</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/module.html">Módulos</a></li></ul></div><div class="navGroup navGroupActive"><h3>JavaScript</h3><ul><li class="navListItem"><a class="navItem" href="/docs/pt-BR/quickstart-javascript.html">Introdução</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/interop.html">Interoperabilidade</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/syntax-cheatsheet.html">Sintaxe</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/libraries.html">Bibliotecas</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/converting-from-js.html">Convertendo de JS</a></li></ul></div><div class="navGroup navGroupActive"><h3>Nativo</h3><ul><li class="navListItem"><a class="navItem" href="/docs/pt-BR/native.html">Nativo</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/quickstart-ocaml.html">Introdução</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/convert-from-ocaml.html">Convertendo de OCaml</a></li></ul></div><div class="navGroup navGroupActive"><h3>Extra</h3><ul><li class="navListItem"><a class="navItem" href="/docs/pt-BR/comparison-to-ocaml.html">Comparação com OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/newcomer-examples.html">Exemplos para Iniciantes</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/project-structure.html">Estrutura de Projeto</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/pt-BR" target="_blank">Translate</a><h1>Variantes!</h1></header><article><div><span><p>Eis a joia da coroa de estruturas de dados do Reason!</p>
<p>A maioria das estruturas de dados na maioria das línguagens são sobre &quot;isto <strong>e</strong> aquilo&quot; Uma variante nos permite expressar &quot;isto <strong>ou</strong> aquilo&quot;.</p>
<pre><code class="hljs css reason">type myResponseVariant =
  | <span class="hljs-type">Yes</span>
  | <span class="hljs-type">No</span>
  | <span class="hljs-type">PrettyMuch</span>;

<span class="hljs-keyword">let</span> areYouCrushingIt = Yes;
</code></pre>
<p><code>Yes</code>, <code>No</code> e <code>PrettyMuch</code> não são sequências de strings nem referências e nem algum tipo de dado especial. Eles são chamados de &quot;construtores&quot; (ou &quot;tag&quot;). O caractere barra <code>|</code> separa cada construtor.</p>
<p><strong>Observação</strong>: Construtores de uma variante precisam ser capitalizados.</p>
<h2><a class="anchor" aria-hidden="true" name="uso"></a><a href="#uso" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Uso</h2>
<p>Acompanhando a variante vem uma das features mais importante de Reason, a expressão <code>switch</code>.</p>
<p>Um <code>switch</code> em Reason é visivelmente similar ao <code>switch</code> em outras linguagens (em outras palavras, um <code>if/elseif/elseif...</code> extenso). Ele permite checar cada possibilidade de um variante. Para usá-lo, enumere cada construtor de variante acerca de um variante em particular, cada um seguido por <code>=&gt;</code> e uma expressão correspondente para esse caso.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> message =
  <span class="hljs-keyword">switch</span> areYouCrushingIt {
  | <span class="hljs-function"><span class="hljs-params">No</span> =&gt;</span> <span class="hljs-string">"No worries. Keep going!"</span>
  | <span class="hljs-function"><span class="hljs-params">Yes</span> =&gt;</span> <span class="hljs-string">"Great!"</span>
  | <span class="hljs-function"><span class="hljs-params">PrettyMuch</span> =&gt;</span> <span class="hljs-string">"Nice!"</span>
  };
<span class="hljs-comment">/* message is "Great!" */</span>
</code></pre>
<p>Uma variante tem uma quantidade extremamente rica de assistência provido pelo sistema de tipos. Por exemplo, nós podemos oferecer um erro de tipo se você se esquecer de cobrir um caso de seu variante, ou se dois casos forem redundantes. Não se esqueça de ver sobre switch e pattern matching em uma <a href="/docs/pt-BR/pattern-matching.html">próxima seção</a>!</p>
<h3><a class="anchor" aria-hidden="true" name="variantes-precisam-de-uma-definic-o-explicita"></a><a href="#variantes-precisam-de-uma-definic-o-explicita" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Variantes Precisam de uma Definição Explícita</h3>
<p>Se a variante que você está usando faz parte de um arquivo diferente, traga-o ao escopo como você faria <a href="/docs/pt-BR/record.html#record-needs-an-explicit-definition">com um registro</a>:</p>
<pre><code class="hljs css reason"><span class="hljs-comment">/* Zoo.re */</span>

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">animal</span></span> = Dog | Cat | Bird;
</code></pre>
<pre><code class="hljs css reason"><span class="hljs-comment">/* example.re */</span>

<span class="hljs-keyword">let</span> pet: Zoo.<span class="hljs-attr">animal</span> = Dog; <span class="hljs-comment">/* preferred */</span>
<span class="hljs-comment">/* or */</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">pet</span> = Zoo.Dog;
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="argumentos-do-construtor"></a><a href="#argumentos-do-construtor" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Argumentos do Construtor</h3>
<p>Um construtor de uma variante pode suportar dados adicionais separados por vírgulas.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">type</span> account =
  | None
  | Instagram(<span class="hljs-keyword">string</span>)
  | Facebook(<span class="hljs-keyword">string</span>, <span class="hljs-keyword">int</span>);
</code></pre>
<p>Aqui, <code>Instagram</code> possui uma <code>string</code>, e <code>Facebook</code> possui uma <code>string</code> e um <code>int</code>. Uso:</p>
<pre><code class="hljs css reason"><span class="hljs-attribute">let myAccount</span> = Facebook(<span class="hljs-string">"Josh"</span>, 26);
<span class="hljs-attribute">let friendAccount</span> = Instagram(<span class="hljs-string">"Jenny"</span>);
</code></pre>
<p><strong>Percebe como usar um construtor é semelhante a chamar uma função</strong>? É como se <code>Facebook</code> fosse uma função que aceita dois parâmetros. Isso não é uma coincidência; existe uma razão pela qual os dados de um construtor são chamados &quot;argumentos do construtor&quot;.</p>
<p>Usando <code>switch</code>, você pode usar pattern-matching (casamento de padrões, como descrito em uma seção posterior) nos argumentos de um construtor:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> saudacao =
   switch minhaConta {
   | <span class="hljs-type">None</span> =&gt; <span class="hljs-string">"Olá!"</span>
   | <span class="hljs-type">Facebook</span>(nome, idade) =&gt; <span class="hljs-string">"Olá "</span> ++ nome ++ <span class="hljs-string">", você tem "</span> ++ string_of_int(idade) ++ <span class="hljs-string">" anos de idade."</span>
   | <span class="hljs-type">Instagram</span>(nome) =&gt; <span class="hljs-string">"Olá "</span> ++ nome ++ <span class="hljs-string">"!"</span>   };
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="menc-es-honrosas"></a><a href="#menc-es-honrosas" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Menções Honrosas</h3>
<p>A <a href="/api/index.html">biblioteca padrão</a> expõe dois importantes variantes, da qual você vai ouvir muito sobre.</p>
<h4><a class="anchor" aria-hidden="true" name="option"></a><a href="#option" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>option</code></h4>
<pre><code class="hljs css reason"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">option</span></span>(<span class="hljs-symbol">'a</span>) = <span class="hljs-literal">None</span> | <span class="hljs-literal">Some</span>(<span class="hljs-symbol">'a</span>);
</code></pre>
<p>Esta é a convenção usada para simular um valor &quot;nullable&quot; (anulável, também conhecido como <code>undefined</code> ou <code>null</code>) em outras linguagens. Graças a esta conveniência de definição de tipo, Reason pode, por padrão, assumir que todos os valores são não-anuláveis. An <code>int</code> will always be an int, never &quot;<code>int</code> <strong>or</strong> <code>null</code> <strong>or</strong> <code>undefined</code>&quot;. If you do want to express a &quot;nullable int&quot;, you'd use <code>option(int)</code>, whose possible values are <code>None</code> or <code>Some(int)</code>. <code>switch</code> forces you to handle both cases; therefore, <strong>a pure Reason program doesn't have null errors</strong>.</p>
<h4><a class="anchor" aria-hidden="true" name="list"></a><a href="#list" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>list</code></h4>
<pre><code class="hljs css reason"><span class="hljs-keyword">type</span> <span class="hljs-built_in">list</span>(<span class="hljs-symbol">'a</span>) = <span class="hljs-type">Empty</span> | <span class="hljs-type">Head</span>(<span class="hljs-symbol">'a</span>, <span class="hljs-built_in">list</span>(<span class="hljs-symbol">'a</span>));
</code></pre>
<p><em>Não é a definição real. Apenas uma ilustração</em>.</p>
<p>This says: &quot;a list that holds a value of type <code>a</code> (whatever it is) is either empty, or holds that value plus another list&quot;.</p>
<p>Reason gave <code>list</code> a syntax sugar. <code>[1, 2, 3]</code> is conceptually equivalent to <code>Head(1, Head(2, Head(3, Empty)))</code>. Once again, <code>switch</code> forces you to handle every case of this variant, including <code>Empty</code> (aka <code>[]</code>). <strong>This eliminates another big category of access bugs</strong>.</p>
<h4><a class="anchor" aria-hidden="true" name="outros-tipos-variantes"></a><a href="#outros-tipos-variantes" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Outros Tipos Variantes</h4>
<p>Você sabia que você pode usar <code>switch</code> em string, int, float, array e na maioria das outras estruturas de dados? Experimente!</p>
<h2><a class="anchor" aria-hidden="true" name="dicas-truques"></a><a href="#dicas-truques" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dicas &amp; Truques</h2>
<p><strong>Tenha cuidado</strong> para não confundir um construtor carregando 2 argumentos com um construtor carregando apenas 1 argumento do tipo tupla:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">type</span> account =
  | Facebook(<span class="hljs-keyword">string</span>, <span class="hljs-keyword">int</span>) <span class="hljs-comment">/* 2 argumentos */</span>;
<span class="hljs-keyword">type</span> account2 =
  | Instagram((<span class="hljs-keyword">string</span>, <span class="hljs-keyword">int</span>)) <span class="hljs-comment">/* 1 argumento - passa a ser uma tupla com 2 valores */</span>;
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="variantes-devem-ter-construtores"></a><a href="#variantes-devem-ter-construtores" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Variantes Devem Ter Construtores</h3>
<p>Se você vem de uma linguagem não tipada, você pode ser tentado a experimentar <code>type foo = int | string</code>. Isso não é possível em Reason; você teria que dar um construtor a cada ramificação: <code>type foo = Int(int) | String(string)</code>. Embora geralmente precisar disso pode ser um anti-padrão. A seção Decisões de Design abaixo explica mais.</p>
<h3><a class="anchor" aria-hidden="true" name="interoperabilidade-com-javascript"></a><a href="#interoperabilidade-com-javascript" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Interoperabilidade com JavaScript</h3>
<p><em>Esta seção assume conhecimento sobre <a href="https://bucklescript.github.io/docs/en/interop-overview.html">FFI</a> do BuckleScript. Pule isso se você ainda não sentiu-se instigado a usar variantes para comunicar-se com as funções JS</em>.</p>
<p>Quite a few JS libraries use functions that can accept many types of arguments. In these cases, it's very tempting to model them as variants. For example, suppose there's a <code>myLibrary.draw</code> JS function that takes in either a <code>number</code> or a <code>string</code>. You might be tempted to bind it like so:</p>
<pre><code class="hljs css reason">/* reserved <span class="hljs-keyword">for</span> internal usage */
[@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"myLibrary"</span>] <span class="hljs-keyword">external</span> draw : <span class="hljs-symbol">'a</span> =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"draw"</span>;

<span class="hljs-keyword">type</span> animal =
  | <span class="hljs-type">MyFloat</span>(<span class="hljs-built_in">float</span>)
  | <span class="hljs-type">MyString</span>(<span class="hljs-built_in">string</span>);

<span class="hljs-keyword">let</span> betterDraw = (animal) =&gt;
  switch animal {
  | <span class="hljs-type">MyFloat</span>(f) =&gt; draw(f)
  | <span class="hljs-type">MyString</span>(s) =&gt; draw(s)
  };
</code></pre>
<p>You could definitely do that, but there are better ways! For example, simply two <code>external</code>s that both compile to the same JS call:</p>
<pre><code class="hljs css reason">[@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"myLibrary"</span>] <span class="hljs-keyword">external</span> drawFloat : <span class="hljs-built_in">float</span> =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"draw"</span>;
[@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"myLibrary"</span>] <span class="hljs-keyword">external</span> drawString : <span class="hljs-built_in">string</span> =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"draw"</span>;
</code></pre>
<p>BuckleScript also provides <a href="https://bucklescript.github.io/docs/en/function.html#binding-to-polymorphic-function">a few other ways</a> to do this.</p>
<h3><a class="anchor" aria-hidden="true" name="variant-types-are-found-by-field-name"></a><a href="#variant-types-are-found-by-field-name" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Variant Types Are Found By Field Name</h3>
<p>Please refer to this <a href="/docs/pt-BR/record.html#record-types-are-found-by-field-name">record section</a>. Variants are the same: a function can't accept an arbitrary constructor shared by two different variants. Again, such feature exists, it's called a polymorphic variant. We'll talk about this in the future =).</p>
<h2><a class="anchor" aria-hidden="true" name="decis-es-de-design"></a><a href="#decis-es-de-design" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Decisões de Design</h2>
<p>Variants, in their many forms (polymorphic variant, open variant, GADT, etc.), are likely <em>the</em> feature of a type system such as Reason's. The aforementioned <code>option</code> variant, for example, obliterates the need for nullable types, a major source of bugs in other languages. Philosophically speaking, a problem is composed of many possible branches/conditions. Mishandling these conditions is the majority of what we call bugs. <strong>A type system doesn't magically eliminate bugs; it points out the unhandled conditions and asks you to cover them</strong>*. The ability to model &quot;this or that&quot; correctly is crucial.</p>
<p>Por exemplo, algumas pessoas perguntam-se como o sistema de tipos pode impedir que dados JSON mal formatados se propaguem para seu programa. They don't, not by themselves! But if the parser returns the <code>option</code> type <code>None | Some(actualData)</code>, then you'd have to handle the <code>None</code> case explicitly in later call sites. Isso é tudo o que existe.</p>
<p>Em termos de desempenho, uma variante pode, potencialmente, acelerar enormemente a lógica do seu programa. Aqui está um pedaço de JavaScript:</p>
<pre><code class="hljs css js"><span class="hljs-keyword">let</span> data = <span class="hljs-string">'dog'</span>;
<span class="hljs-keyword">if</span> (data === <span class="hljs-string">'dog'</span>) {
  ...
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data === <span class="hljs-string">'cat'</span>) {
  ...
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data === <span class="hljs-string">'bird'</span>) {
  ...
}
</code></pre>
<p>Há uma quantidade linear de verificação de ramificação aqui (<code>O(n)</code>). Compare isso usando uma variante Reason:</p>
<pre><code class="hljs css reason"><span class="hljs-class"><span class="hljs-keyword">type</span> animal = <span class="hljs-type">Dog</span> | <span class="hljs-type">Cat</span> | <span class="hljs-type">Bird</span>;</span>
<span class="hljs-title">let</span> <span class="hljs-class"><span class="hljs-keyword">data</span> = <span class="hljs-type">Dog</span>;</span>
<span class="hljs-title">switch</span> <span class="hljs-class"><span class="hljs-keyword">data</span> {
| <span class="hljs-type">Dog</span> =&gt; ...
| <span class="hljs-type">Cat</span> =&gt; ...
| <span class="hljs-type">Bird</span> =&gt; ...
}</span>
</code></pre>
<p>O compilador vê a variante, então</p>
<ol>
<li>conceitualmente transforma-os em <code>type animal = 0 | 1 | 2</code></li>
<li>compila <code>switch</code> para um formato de tempo-constante (<code>O(1)</code>).</li>
</ol>
<p>Você pode perguntar-se por que as linguagens funcionais tipadas são usadas tantas vezes para a análise; encontrar valores em uma árvore grande de forma eficiente e segura é praticamente o melhor cenário para as variantes.</p>
<!-- TODO: playground link -->
<p>Mente confusa ainda? Variantes têm uma conexão profunda com outros campos da matemática; <a href="https://codewords.recurse.com/issues/three/algebra-and-calculus-of-algebraic-data-types">Veja aqui</a> para uma exploração interessante.</p>
<p>* Sempre é melhor retirar o problema no design invés de recorrer a um sistema de tipos para cobrir os buracos; Na realidade, é surreal fazer isso para todos problemas, ou até mesmo simplesmente entender todos os problemas completamente para desenvolver uma solução. Um sistema de tipos permite que você faça uma grande categoria de mudanças em bases de código de forma segura, sem precisar entender tudo logo de cara. Isso é ótimo para exploração guiada. Nesse aspecto, tipos também nos permitem não precisar desenvolver excessivamente uma API apenas para contornar armadilhas simples para os chamadores. Eles reduzem as camadas de abstração necessárias para &quot;fazer as coisas funcionarem&quot;, o que, por sua vez, reduz a carga cognitiva dos chamadores.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="record.html">← Record</a><a class="docs-next button" href="list-and-array.html">Lista &amp; Array →</a></div></div></div></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react'
              });
            </script></body></html>