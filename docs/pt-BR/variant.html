<!DOCTYPE html><html lang="pt-BR"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Variantes! · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Eis a joia da coroa de estruturas de dados do Reason!"/><meta name="docsearch:language" content="pt-BR"/><meta property="og:title" content="Variantes! · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/index.html"/><meta property="og:description" content="Eis a joia da coroa de estruturas de dados do Reason!"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/pt-BR"><img class="logo" src="/img/dummy.svg" alt="Reason"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/pt-BR/what-and-why" target="_self">Documentação</a></li><li class=""><a href="/pt-BR/try" target="_self">Tentar</a></li><li class=""><a href="/api/index" target="_self">API</a></li><li class=""><a href="/docs/pt-BR/community" target="_self">Comunidade</a></li><li class=""><a href="/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg"/>Português (Brasil)</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/ja/variant">日本語</a></li><li><a href="/docs/en/variant">English</a></li><li><a href="/docs/de/variant">Deutsch</a></li><li><a href="/docs/es-ES/variant">Español</a></li><li><a href="/docs/fr/variant">Français</a></li><li><a href="/docs/ko/variant">한국어</a></li><li><a href="/docs/ru/variant">Русский</a></li><li><a href="/docs/uk/variant">Українська</a></li><li><a href="/docs/zh-CN/variant">中文</a></li><li><a href="/docs/zh-TW/variant">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank" rel="noreferrer noopener">Ajude a Traduzir</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Noções Básicas da Linguagem</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Introdução</h3><ul><li class="navListItem"><a class="navItem" href="/docs/pt-BR/what-and-why">O quê &amp; porquê</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Setup</h3><ul><li class="navListItem"><a class="navItem" href="/docs/pt-BR/installation">Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/editor-plugins">Plugins para Editores</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/extra-goodies">Miscelânea</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Noções Básicas da Linguagem</h3><ul><li class="navListItem"><a class="navItem" href="/docs/pt-BR/overview">Visão geral</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/let-binding">Let Binding</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/type">Tipo!</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/string-and-char">String &amp; Char</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/boolean">Boolean</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/integer-and-float">Inteiro &amp; Float</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/tuple">Tupla</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/record">Record</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/pt-BR/variant">Variantes!</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/list-and-array">Lista &amp; Array</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/function">Função</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/if-else">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/fast-pipe">Fast Pipe</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/more-on-type">Mais sobre Tipos</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/destructuring">Destructuring</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/pattern-matching">Correspondência de Padrões!</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/mutation">Mutação</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/imperative-loops">Loops Imperativos</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/jsx">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/external">External</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/exception">Exceção</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/object">Objeto</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/module">Módulos</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/promise">Promise</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">JavaScript</h3><ul><li class="navListItem"><a class="navItem" href="/docs/pt-BR/interop">Interoperabilidade</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/syntax-cheatsheet">Sintaxe</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/libraries">Bibliotecas</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/converting-from-js">Convertendo de JS</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Nativo</h3><ul><li class="navListItem"><a class="navItem" href="/docs/pt-BR/native">Nativo</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/quickstart-ocaml">Introdução</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/convert-from-ocaml">Convertendo de OCaml</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Extra</h3><ul><li class="navListItem"><a class="navItem" href="/docs/pt-BR/faq">Perguntas Frequentes</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/comparison-to-ocaml">Comparação com OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/newcomer-examples">Exemplos para Iniciantes</a></li><li class="navListItem"><a class="navItem" href="/docs/pt-BR/project-structure">Estrutura de Projeto</a></li></ul></div></div></section></div><script>
            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/pt-BR" target="_blank" rel="noreferrer noopener">Translate</a><h1 class="postHeaderTitle">Variantes!</h1></header><article><div><span><p>Eis a joia da coroa de estruturas de dados do Reason!</p>
<p>A maioria das estruturas de dados na maioria das línguagens são sobre &quot;isto <strong>e</strong> aquilo&quot; Uma variante nos permite expressar &quot;isto <strong>ou</strong> aquilo&quot;.</p>
<pre><code class="hljs css languages- reason">type myResponseVariant =
  | <span class="hljs-type">Yes</span>
  | <span class="hljs-type">No</span>
  | <span class="hljs-type">PrettyMuch</span>;

<span class="hljs-keyword">let</span> areYouCrushingIt = Yes;
</code></pre>
<p><code>Yes</code>, <code>No</code> e <code>PrettyMuch</code> não são sequências de strings nem referências e nem algum tipo de dado especial. Eles são chamados de &quot;construtores&quot; (ou &quot;tag&quot;). O caractere barra <code>|</code> separa cada construtor.</p>
<p><strong>Observação</strong>: Construtores de uma variante precisam ser capitalizados.</p>
<h2><a class="anchor" aria-hidden="true" id="uso"></a><a href="#uso" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Uso</h2>
<p>Acompanhando a variante vem uma das features mais importante de Reason, a expressão <code>switch</code>.</p>
<p>Um <code>switch</code> em Reason é visivelmente similar ao <code>switch</code> em outras linguagens (em outras palavras, um <code>if/elseif/elseif...</code> extenso). Ele permite checar cada possibilidade de um variante. Para usá-lo, enumere cada construtor de variante acerca de um variante em particular, cada um seguido por <code>=&gt;</code> e uma expressão correspondente para esse caso.</p>
<pre><code class="hljs css languages- reason"><span class="hljs-keyword">let</span> message =
  <span class="hljs-keyword">switch</span> (areYouCrushingIt) {
  | <span class="hljs-function"><span class="hljs-params">No</span> =&gt;</span> <span class="hljs-string">"No worries. Keep going!"</span>
  | <span class="hljs-function"><span class="hljs-params">Yes</span> =&gt;</span> <span class="hljs-string">"Great!"</span>
  | <span class="hljs-function"><span class="hljs-params">PrettyMuch</span> =&gt;</span> <span class="hljs-string">"Nice!"</span>
  };
<span class="hljs-comment">/* message is "Great!" */</span>
</code></pre>
<p>Uma variante tem uma quantidade extremamente rica de assistência provido pelo sistema de tipos. Por exemplo, nós podemos oferecer um erro de tipo se você se esquecer de cobrir um caso de seu variante, ou se dois casos forem redundantes. Não se esqueça de ver sobre switch e pattern matching em uma <a href="/docs/pt-BR/pattern-matching">próxima seção</a>!</p>
<h3><a class="anchor" aria-hidden="true" id="variantes-precisam-de-uma-definicão-explicita"></a><a href="#variantes-precisam-de-uma-definicão-explicita" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Variantes Precisam de uma Definição Explícita</h3>
<p>Se a variante que você está usando faz parte de um arquivo diferente, traga-o ao escopo como você faria <a href="/docs/pt-BR/record#record-needs-an-explicit-definition">com um registro</a>:</p>
<pre><code class="hljs css languages- reason"><span class="hljs-comment">/* Zoo.re */</span>

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">animal</span></span> = Dog | Cat | Bird;
</code></pre>
<pre><code class="hljs css languages- reason"><span class="hljs-comment">/* example.re */</span>

<span class="hljs-keyword">let</span> pet: Zoo.<span class="hljs-attr">animal</span> = Dog; <span class="hljs-comment">/* preferred */</span>
<span class="hljs-comment">/* or */</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">pet</span> = Zoo.Dog;
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="argumentos-do-construtor"></a><a href="#argumentos-do-construtor" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Argumentos do Construtor</h3>
<p>Um construtor de uma variante pode suportar dados adicionais separados por vírgulas.</p>
<pre><code class="hljs css languages- reason"><span class="hljs-keyword">type</span> account =
  | None
  | Instagram(<span class="hljs-keyword">string</span>)
  | Facebook(<span class="hljs-keyword">string</span>, <span class="hljs-keyword">int</span>);
</code></pre>
<p>Aqui, <code>Instagram</code> possui uma <code>string</code>, e <code>Facebook</code> possui uma <code>string</code> e um <code>int</code>. Uso:</p>
<pre><code class="hljs css languages- reason"><span class="hljs-attribute">let myAccount</span> = Facebook(<span class="hljs-string">"Josh"</span>, 26);
<span class="hljs-attribute">let friendAccount</span> = Instagram(<span class="hljs-string">"Jenny"</span>);
</code></pre>
<p><strong>Percebe como usar um construtor é semelhante a chamar uma função</strong>? É como se <code>Facebook</code> fosse uma função que aceita dois parâmetros. Isso não é uma coincidência; existe uma razão pela qual os dados de um construtor são chamados &quot;argumentos do construtor&quot;.</p>
<p>Usando <code>switch</code>, você pode usar pattern-matching (casamento de padrões, como descrito em uma seção posterior) nos argumentos de um construtor:</p>
<pre><code class="hljs css languages- reason"><span class="hljs-keyword">let</span> greeting =
  switch (myAccount) {
  | <span class="hljs-type">None</span> =&gt; <span class="hljs-string">"Hi!"</span>
  | <span class="hljs-type">Facebook</span>(name, age) =&gt; <span class="hljs-string">"Hi "</span> ++ name ++ <span class="hljs-string">", you're "</span> ++ string_of_int(age) ++ <span class="hljs-string">"-year-old."</span>
  | <span class="hljs-type">Instagram</span>(name) =&gt; <span class="hljs-string">"Hello "</span> ++ name ++ <span class="hljs-string">"!"</span>
  };
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="mencões-honrosas"></a><a href="#mencões-honrosas" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Menções Honrosas</h3>
<p>A <a href="/api/index.html">biblioteca padrão</a> expõe dois importantes variantes, da qual você vai ouvir muito sobre.</p>
<h4><a class="anchor" aria-hidden="true" id="option"></a><a href="#option" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>option</code></h4>
<pre><code class="hljs css languages- reason"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">option</span></span>(<span class="hljs-symbol">'a</span>) = <span class="hljs-literal">None</span> | <span class="hljs-literal">Some</span>(<span class="hljs-symbol">'a</span>);
</code></pre>
<p>Esta é a convenção usada para simular um valor &quot;nullable&quot; (anulável, também conhecido como <code>undefined</code> ou <code>null</code>) em outras linguagens. Graças a esta conveniência de definição de tipo, Reason pode, por padrão, assumir que todos os valores são não-anuláveis. Um <code>int</code> sempre vai ser um int, nunca &quot;<code>int</code> <strong>ou</strong> <code>null</code> <strong>ou</strong> <code>undefined</code>&quot;. Caso você queira expressar um &quot;nullable int&quot;, você pode usar <code>option(int)</code>, que pode ser <code>None</code> ou <code>Some(int)</code>. <code>switch</code> força você a tratar os dois casos; porém <strong>um programa Reason não contém erros ocasionados por null</strong>.</p>
<h4><a class="anchor" aria-hidden="true" id="list"></a><a href="#list" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>list</code></h4>
<pre><code class="hljs css languages- reason"><span class="hljs-keyword">type</span> <span class="hljs-built_in">list</span>(<span class="hljs-symbol">'a</span>) = <span class="hljs-type">Empty</span> | <span class="hljs-type">Head</span>(<span class="hljs-symbol">'a</span>, <span class="hljs-built_in">list</span>(<span class="hljs-symbol">'a</span>));
</code></pre>
<p><em>Não é a definição real. Apenas uma ilustração</em>.</p>
<p>Significado: &quot;uma lista que contém valores de um tipo <code>a</code> (não importa o que é) é vazia, ou contém esses valores mais uma outra lista&quot;.</p>
<p>Reason fornece syntax sugar a <code>list</code>. <code>[1, 2, 3]</code> é conceitualmente equivalente a <code>Head(1, Head(2, Head(3, Empty)))</code>. Novamente, <code>switch</code> força você a tratar cada caso, incluindo <code>Empty</code> (aka <code>[]</code>). <strong>Isso elimina uma outra grande categoria de bugs de acesso</strong>.</p>
<h4><a class="anchor" aria-hidden="true" id="outros-tipos-variantes"></a><a href="#outros-tipos-variantes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Outros Tipos Variantes</h4>
<p>Você sabia que você pode usar <code>switch</code> em string, int, float, array e na maioria das outras estruturas de dados? Experimente!</p>
<h2><a class="anchor" aria-hidden="true" id="dicas-truques"></a><a href="#dicas-truques" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dicas &amp; Truques</h2>
<p><strong>Tenha cuidado</strong> para não confundir um construtor carregando 2 argumentos com um construtor carregando apenas 1 argumento do tipo tupla:</p>
<pre><code class="hljs css languages- reason"><span class="hljs-keyword">type</span> account =
  | Facebook(<span class="hljs-keyword">string</span>, <span class="hljs-keyword">int</span>) <span class="hljs-comment">/* 2 argumentos */</span>;
<span class="hljs-keyword">type</span> account2 =
  | Instagram((<span class="hljs-keyword">string</span>, <span class="hljs-keyword">int</span>)) <span class="hljs-comment">/* 1 argumento - passa a ser uma tupla com 2 valores */</span>;
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="variantes-devem-possuir-construtores"></a><a href="#variantes-devem-possuir-construtores" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Variantes Devem Possuir Construtores</h3>
<p>Se você vem de uma linguagem não tipada, você pode ser tentado a experimentar <code>type foo = int | string</code>. Isso não é possível em Reason; você teria que dar um construtor a cada ramificação: <code>type foo = Int(int) | String(string)</code>. Embora geralmente precisar disso pode ser um anti-padrão. A seção Decisões de Design abaixo explica mais.</p>
<h3><a class="anchor" aria-hidden="true" id="interoperabilidade-com-javascript"></a><a href="#interoperabilidade-com-javascript" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Interoperabilidade com JavaScript</h3>
<p><em>Esta seção assume conhecimento sobre <a href="https://bucklescript.github.io/docs/en/interop-overview.html">FFI</a> do BuckleScript. Skip this if you haven't felt the itch to use variants for wrapping JS functions yet</em>.</p>
<p>Poucas bibliotecas JS usam funções que podem aceitar vários tipos de argumentos. Nesses casos, é bastante tentador modelar eles como variantes. Por exemplo, imagine uma função chamada <code>myLibrary.draw</code> que recebe vários <code>number</code> ou <code>string</code>. Você pode tentar dar um bind assim:</p>
<pre><code class="hljs css languages- reason">/* reservado para uso interno */
[@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"myLibrary"</span>] <span class="hljs-keyword">external</span> draw : <span class="hljs-symbol">'a</span> =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"draw"</span>;

<span class="hljs-keyword">type</span> animal =
  | <span class="hljs-type">MyFloat</span>(<span class="hljs-built_in">float</span>)
  | <span class="hljs-type">MyString</span>(<span class="hljs-built_in">string</span>);

<span class="hljs-keyword">let</span> betterDraw = (animal) =&gt;
  switch (animal) {
  | <span class="hljs-type">MyFloat</span>(f) =&gt; draw(f)
  | <span class="hljs-type">MyString</span>(s) =&gt; draw(s)
  };
</code></pre>
<p>Você realmente pode fazer isso, mas existem formas muito melhores! Por exemplo, simplesmente dois <code>external</code>s que compilam para a mesma chamada JS:</p>
<pre><code class="hljs css languages- reason">[@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"myLibrary"</span>] <span class="hljs-keyword">external</span> drawFloat : <span class="hljs-built_in">float</span> =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"draw"</span>;
[@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"myLibrary"</span>] <span class="hljs-keyword">external</span> drawString : <span class="hljs-built_in">string</span> =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"draw"</span>;
</code></pre>
<p>BuckleScript also provides <a href="https://bucklescript.github.io/docs/en/function.html#modeling-polymorphic-function">a few other ways</a> to do this.</p>
<h3><a class="anchor" aria-hidden="true" id="tipos-variantes-são-encontrados-pelo-nome-do-campo"></a><a href="#tipos-variantes-são-encontrados-pelo-nome-do-campo" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tipos variantes são encontrados pelo nome do campo</h3>
<p>Por favor, referencie-se a isso na <a href="/docs/pt-BR/record#record-types-are-found-by-field-name">sessão sobre records</a>. As variantes são as mesmas: uma função não pode aceitar um construtor arbitrário compartilhado por duas variantes diferentes. Novamente, tal característica existe, chama-se uma variante polimórfica. Vamos falar sobre isso no futuro =).</p>
<h2><a class="anchor" aria-hidden="true" id="decisões-de-design"></a><a href="#decisões-de-design" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Decisões de Design</h2>
<p>As variantes, nas suas várias formas (variante polimórfica, variante aberta, GADT, etc.) são <em>a</em> característica de um sistema de tipo como o de Reason. A variante <code>option</code> acima mencionada, por exemplo, remove a necessidade de tipos anuláveis, uma fonte importante de bugs em outras linguagens. Filosoficamente falando, um problema é composto por muitos ramos/condições possíveis. Essas chamadas são o máximo do que chamamos de bugs. **Um sistema de tipo não elimina erros magicamente; ele aponta as condições não tratadas e pede que você as resolva. ***. A capacidade de modelar &quot;isto ou aquilo&quot; corretamente é crucial.</p>
<p>Por exemplo, algumas pessoas perguntam-se como o sistema de tipos pode impedir que dados JSON mal formatados se propaguem para seu programa. Eles não, não por si mesmos! Mas se o parser retorna um tipo <code>option</code> <code>None | Alguns (actualData)</code>, você teria que lidar com o caso <code>None</code> explicitamente em chamadas posteriores. Isso é tudo o que existe.</p>
<p>Em termos de desempenho, uma variante pode, potencialmente, acelerar enormemente a lógica do seu programa. Aqui está um pedaço de JavaScript:</p>
<pre><code class="hljs css languages- js"><span class="hljs-keyword">let</span> data = <span class="hljs-string">'dog'</span>;
<span class="hljs-keyword">if</span> (data === <span class="hljs-string">'dog'</span>) {
  ...
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data === <span class="hljs-string">'cat'</span>) {
  ...
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data === <span class="hljs-string">'bird'</span>) {
  ...
}
</code></pre>
<p>Há uma quantidade linear de verificação de ramificação aqui (<code>O(n)</code>). Compare isso usando uma variante Reason:</p>
<pre><code class="hljs css languages- reason"><span class="hljs-class"><span class="hljs-keyword">type</span> animal = <span class="hljs-type">Dog</span> | <span class="hljs-type">Cat</span> | <span class="hljs-type">Bird</span>;</span>
<span class="hljs-title">let</span> <span class="hljs-class"><span class="hljs-keyword">data</span> = <span class="hljs-type">Dog</span>;</span>
<span class="hljs-title">switch</span> (<span class="hljs-class"><span class="hljs-keyword">data</span>) {
| <span class="hljs-type">Dog</span> =&gt; ...
| <span class="hljs-type">Cat</span> =&gt; ...
| <span class="hljs-type">Bird</span> =&gt; ...
}</span>
</code></pre>
<p>O compilador vê a variante, então</p>
<ol>
<li>conceitualmente transforma-os em <code>type animal = 0 | 1 | 2</code></li>
<li>compila <code>switch</code> para um formato de tempo-constante (<code>O(1)</code>).</li>
</ol>
<p>Você pode perguntar-se por que as linguagens funcionais tipadas são usadas tantas vezes para a análise; encontrar valores em uma árvore grande de forma eficiente e segura é praticamente o melhor cenário para as variantes.</p>
<!-- TODO: playground link -->
<p>Mente confusa ainda? Variantes têm uma conexão profunda com outros campos da matemática; <a href="https://codewords.recurse.com/issues/three/algebra-and-calculus-of-algebraic-data-types">Veja aqui</a> para uma exploração interessante.</p>
<p>* Sempre é melhor retirar o problema no design invés de recorrer a um sistema de tipos para cobrir os buracos; Na realidade, é surreal fazer isso para todos problemas, ou até mesmo simplesmente entender todos os problemas completamente para desenvolver uma solução. Um sistema de tipos permite que você faça uma grande categoria de mudanças em bases de código de forma segura, sem precisar entender tudo logo de cara. Isso é ótimo para exploração guiada. Nesse aspecto, tipos também nos permitem não precisar desenvolver excessivamente uma API apenas para contornar armadilhas simples para os chamadores. Eles reduzem as camadas de abstração necessárias para &quot;fazer as coisas funcionarem&quot;, o que, por sua vez, reduz a carga cognitiva dos chamadores.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/pt-BR/record">← Record</a><a class="docs-next button" href="/docs/pt-BR/list-and-array">Lista &amp; Array →</a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#uso">Uso</a><ul class="toc-headings"><li><a href="#variantes-precisam-de-uma-definicão-explicita">Variantes Precisam de uma Definição Explícita</a></li><li><a href="#argumentos-do-construtor">Argumentos do Construtor</a></li><li><a href="#mencões-honrosas">Menções Honrosas</a></li></ul></li><li><a href="#dicas-truques">Dicas &amp; Truques</a><ul class="toc-headings"><li><a href="#variantes-devem-possuir-construtores">Variantes Devem Possuir Construtores</a></li><li><a href="#interoperabilidade-com-javascript">Interoperabilidade com JavaScript</a></li><li><a href="#tipos-variantes-são-encontrados-pelo-nome-do-campo">Tipos variantes são encontrados pelo nome do campo</a></li></ul></li><li><a href="#decisões-de-design">Decisões de Design</a></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.min.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper, .onPageNav',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:pt-BR"]}
              });
            </script></body></html>