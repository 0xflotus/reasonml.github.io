<!DOCTYPE html><html lang="de"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Module · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## Grundlagen"/><meta name="docsearch:language" content="de"/><meta property="og:title" content="Module · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/index.html"/><meta property="og:description" content="## Grundlagen"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/de"><img class="logo" src="/img/dummy.svg" alt="Reason"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/de/quickstart-javascript.html" target="_self">Dokumentation</a></li><li class=""><a href="/de/try.html" target="_self">Try</a></li><li class=""><a href="/api/index.html" target="_self">API</a></li><li class=""><a href="/docs/de/community.html" target="_self">Community</a></li><li class=""><a href="/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg"/>Deutsch</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/ja/module.html">日本語</a></li><li><a href="/docs/en/module.html">English</a></li><li><a href="/docs/es-ES/module.html">Español</a></li><li><a href="/docs/fr/module.html">Français</a></li><li><a href="/docs/ko/module.html">한국어</a></li><li><a href="/docs/pt-BR/module.html">Português (Brasil)</a></li><li><a href="/docs/ru/module.html">Русский</a></li><li><a href="/docs/uk/module.html">Українська</a></li><li><a href="/docs/zh-CN/module.html">中文</a></li><li><a href="/docs/zh-TW/module.html">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank" rel="noreferrer noopener">Beim Übersetzen helfen</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Grundlagen der Sprache</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Einführung</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/what-and-why.html">Was &amp; Wieso</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Editor-Setup</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/global-installation.html">Globale Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/de/editor-plugins.html">Editor-Plugins</a></li><li class="navListItem"><a class="navItem" href="/docs/de/extra-goodies.html">Weitere Goodies</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Grundlagen der Sprache</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/overview.html">Übersicht</a></li><li class="navListItem"><a class="navItem" href="/docs/de/let-binding.html">Let Binding</a></li><li class="navListItem"><a class="navItem" href="/docs/de/type.html">Typen!</a></li><li class="navListItem"><a class="navItem" href="/docs/de/string-and-char.html">String &amp; Char</a></li><li class="navListItem"><a class="navItem" href="/docs/de/boolean.html">Boolean</a></li><li class="navListItem"><a class="navItem" href="/docs/de/integer-and-float.html">Integer &amp; Float</a></li><li class="navListItem"><a class="navItem" href="/docs/de/tuple.html">Tuple</a></li><li class="navListItem"><a class="navItem" href="/docs/de/record.html">Record</a></li><li class="navListItem"><a class="navItem" href="/docs/de/variant.html">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/de/list-and-array.html">List &amp; Array</a></li><li class="navListItem"><a class="navItem" href="/docs/de/function.html">Funktionen</a></li><li class="navListItem"><a class="navItem" href="/docs/de/if-else.html">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/de/more-on-type.html">Mehr über Typen</a></li><li class="navListItem"><a class="navItem" href="/docs/de/destructuring.html">Destrukturierung</a></li><li class="navListItem"><a class="navItem" href="/docs/de/pattern-matching.html">Pattern-Matching!</a></li><li class="navListItem"><a class="navItem" href="/docs/de/mutation.html">Mutation</a></li><li class="navListItem"><a class="navItem" href="/docs/de/imperative-loops.html">Imperative Schleifen</a></li><li class="navListItem"><a class="navItem" href="/docs/de/jsx.html">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/de/external.html">External</a></li><li class="navListItem"><a class="navItem" href="/docs/de/exception.html">Exception</a></li><li class="navListItem"><a class="navItem" href="/docs/de/object.html">Objekt</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/de/module.html">Module</a></li><li class="navListItem"><a class="navItem" href="/docs/de/promise.html">Promise</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">JavaScript</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/quickstart-javascript.html">Schnellstart</a></li><li class="navListItem"><a class="navItem" href="/docs/de/interop.html">Interoperabilität</a></li><li class="navListItem"><a class="navItem" href="/docs/de/syntax-cheatsheet.html">Syntax Cheatsheet</a></li><li class="navListItem"><a class="navItem" href="/docs/de/libraries.html">Libraries</a></li><li class="navListItem"><a class="navItem" href="/docs/de/converting-from-js.html">Konvertieren von JS</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Nativ</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/native.html">Nativ</a></li><li class="navListItem"><a class="navItem" href="/docs/de/quickstart-ocaml.html">Schnellstart</a></li><li class="navListItem"><a class="navItem" href="/docs/de/convert-from-ocaml.html">Konvertieren von OCaml</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Weiteres</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/faq.html">Häufige Fragen</a></li><li class="navListItem"><a class="navItem" href="/docs/de/comparison-to-ocaml.html">Vergleich zu OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/de/newcomer-examples.html">Newcomer-Beispiele</a></li><li class="navListItem"><a class="navItem" href="/docs/de/project-structure.html">Projektstruktur</a></li></ul></div></div></section></div><script>
            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/de" target="_blank" rel="noreferrer noopener">Translate</a><h1 class="postHeaderTitle">Module</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="grundlagen"></a><a href="#grundlagen" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Grundlagen</h2>
<p><strong>Module sind wie Minidateien</strong>! Sie können Typdefinitionen, <code>let</code>-Bindungen, geschachtelte Module, usw. enthalten.</p>
<h3><a class="anchor" aria-hidden="true" id="erzeugung"></a><a href="#erzeugung" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Erzeugung</h3>
<p>Verwende das <code>module</code>-Schlüsselwort, um ein Modul zu erzeugen. Der Modulname muss mit einem <strong>Großbuchstaben</strong> beginnen. Was auch immer du in einer <code>.re</code>-Datei platzieren könntest, kannst du innerhalb des <code>{}</code>-Blocks einer Moduldefinition ablegen.</p>
<pre><code class="hljs css languages- reason"><span class="hljs-keyword">module</span> School = {
  <span class="hljs-keyword">type</span> profession = Teacher | Director;

  <span class="hljs-keyword">let</span> person1 = Teacher;
  <span class="hljs-keyword">let</span> getProfession = <span class="hljs-function">(<span class="hljs-params">person</span>) =&gt;</span>
    <span class="hljs-keyword">switch</span> (person) {
    | <span class="hljs-function"><span class="hljs-params">Teacher</span> =&gt;</span> <span class="hljs-string">"A teacher"</span>
    | <span class="hljs-function"><span class="hljs-params">Director</span> =&gt;</span> <span class="hljs-string">"A director"</span>
    };
};
</code></pre>
<p>Auf den Inhalt eines Moduls (einschließlich Typen!) kann ähnlich wie bei einem Record durch die <code>.</code>-Notation zugegriffen werden. Dies veranschaulicht das Hilfsfeature für Namespaces in Modulen.</p>
<pre><code class="hljs css languages- reason">let anotherPerson: <span class="hljs-keyword">School.profession </span>= <span class="hljs-keyword">School.Teacher;
</span>print_endline(<span class="hljs-keyword">School.getProfession(anotherPerson)); </span><span class="hljs-comment">/* "A teacher" */</span>
</code></pre>
<p>Verschachtelte Module funktionieren auch.</p>
<pre><code class="hljs css languages- reason">module <span class="hljs-attr">MyModule</span> = {
  module <span class="hljs-attr">NestedModule</span> = {
    <span class="hljs-keyword">let</span> <span class="hljs-attr">message</span> = <span class="hljs-string">"hello"</span>;
  };
};

<span class="hljs-keyword">let</span> <span class="hljs-attr">message</span> = MyModule.NestedModule.message;
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="ein-modul-mit-open-offnen"></a><a href="#ein-modul-mit-open-offnen" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Ein Modul mit <code>open</code> öffnen</h3>
<p>Es kann mühsam sein, sich ständig auf einen Wert / Typ in einem Modul zu beziehen. Wir können die Definition eines Moduls öffnen und auf seinen Inhalt Bezug nehmen, ohne den Modulnamen voranzustellen. Zwei Wege:</p>
<p>Lokales Öffnen.</p>
<pre><code class="hljs css languages- reason"><span class="hljs-keyword">let</span> message =
  School.(
    <span class="hljs-keyword">switch</span> (person1) {
    | <span class="hljs-function"><span class="hljs-params">Teacher</span> =&gt;</span> <span class="hljs-string">"Hello teacher!"</span>
    | <span class="hljs-function"><span class="hljs-params">Director</span> =&gt;</span> <span class="hljs-string">"Hello director!"</span>
    }
  );
</code></pre>
<p>Globales Öffnen. <strong>Verwende dies sparsam, da es Bequemlichkeit auf Kosten der Einfachheit der Nachvollziehbarkeit ermöglicht</strong>:</p>
<pre><code class="hljs css languages- reason">open <span class="hljs-keyword">School;
</span>let anotherPerson: profession = Teacher<span class="hljs-comment">;</span>
printProfession(anotherPerson)<span class="hljs-comment">;</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="module-erweitern"></a><a href="#module-erweitern" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Module erweitern</h3>
<p>Die Verwendung von <code>include</code> in einem Modul „streut“ den Inhalt eines Moduls statisch in einen neuen und erfüllt damit oft die Rolle von „Vererbung“ oder „Mixin“.</p>
<pre><code class="hljs css languages- reason"><span class="hljs-keyword">module</span> BaseComponent = {
  <span class="hljs-keyword">let</span> defaultGreeting = <span class="hljs-string">"Hello"</span>;
  <span class="hljs-keyword">let</span> getAudience = <span class="hljs-function">(<span class="hljs-params">~excited</span>) =&gt;</span> excited ? <span class="hljs-string">"world!"</span> : <span class="hljs-string">"world"</span>;
};

<span class="hljs-keyword">module</span> ActualComponent = {
  <span class="hljs-comment">/* the content is copied over */</span>
  include BaseComponent;
  <span class="hljs-comment">/* overrides BaseComponent.defaultGreeting */</span>
  <span class="hljs-keyword">let</span> defaultGreeting = <span class="hljs-string">"Hey"</span>;
  <span class="hljs-keyword">let</span> render = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> defaultGreeting ++ <span class="hljs-string">" "</span> ++ getAudience(~excited=<span class="hljs-literal">true</span>);
};
</code></pre>
<p><strong>Hinweis</strong>: <code>open</code> und <code>include</code> sind sehr verschieden! Ersterer bringt den Inhalt eines Moduls in deinen aktuellen Sichtbarkeitsbereich, so dass du auf einen Wert zugreifen kannst ohne jedes Mal den Namen des Moduls voranzustellen. Letztere <strong>kopiert</strong> die Definition eines Moduls statisch.</p>
<h3><a class="anchor" aria-hidden="true" id="jede-re-datei-ist-ein-modul"></a><a href="#jede-re-datei-ist-ein-modul" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Jede <code>.re</code>-Datei ist ein Modul</h3>
<p>Eine OCaml- / Reason-Datei wird einem Modul zugeordnet. Dadurch wird eine interessante Expressivität freigeschaltet, die zuvor Code-Generierung in anderen Sprachen erforderte. Die Datei <code>React.re</code> bildet implizit ein Modul <code>React</code>, das von anderen Quelldateien gesehen wird.</p>
<pre><code class="hljs css languages- reason"><span class="hljs-comment">/* FileA.re. This typically compiles to module FileA below */</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">a</span> = <span class="hljs-number">1</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">b</span> = <span class="hljs-number">2</span>;

<span class="hljs-comment">/* FileB.re */</span>
<span class="hljs-comment">/* Maps FileA's implementation to a new API */</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">alpha</span> = FileA.a;
<span class="hljs-keyword">let</span> <span class="hljs-attr">beta</span> = FileA.b;
</code></pre>
<p>Dieses künstliche Beispiel drückt das „Kopieren“ einer Datei aus:</p>
<pre><code class="hljs css languages- reason"><span class="hljs-comment">/* FileA.re. This typically compiles to module FileA below */</span>
let a = <span class="hljs-number">1</span><span class="hljs-comment">;</span>
let <span class="hljs-keyword">b </span>= <span class="hljs-number">2</span><span class="hljs-comment">;</span>

<span class="hljs-comment">/* FileB.re */</span>
<span class="hljs-comment">/* compiles to exactly fileA.re's content with no runtime overhead! */</span>
include FileA<span class="hljs-comment">;</span>
</code></pre>
<p><strong>Bemerkung</strong>: Weil Dateien Module sind, sollten Dateinamen per Konvention groß geschrieben werden, so dass sie ihren Modulnamen entsprechen. Klein geschriebene Dateinamen sind nicht ungültig, werden jedoch in einen Modulnamen mit Großschreibung umgewandelt. D. h. <code>file.re</code> wird zu dem Module <code>File</code> kompiliert. Um die Trennung hier zu vereinfachen und zu minimieren, besteht die Konvention daher auch, Dateinamen groß zu schreiben.</p>
<h2><a class="anchor" aria-hidden="true" id="signaturen"></a><a href="#signaturen" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Signaturen</h2>
<p>Das Typsystem eines Moduls heißt „Signatur“ und kann explizit ausgeschrieben werden. Wenn ein Modul wie eine <code>.re</code>-(Implementierungs-)-Datei ist, dann entspricht die Signatur eines Moduls einer <code>.rei</code>-(Interface)-Datei.</p>
<h3><a class="anchor" aria-hidden="true" id="erzeugung-1"></a><a href="#erzeugung-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Erzeugung</h3>
<p>Verwende das Schlüsselwort <code>module type</code>, um eine Signatur zu erstellen. Der Signaturname muss mit einem <strong>Großbuchstaben</strong> beginnen. Was auch immer du in einer <code>.rei</code>-Datei platzieren könntest, kannst du auch in dem <code>{}</code>-Block einer Signaturdefinition ablegen.</p>
<pre><code class="hljs css languages- reason"><span class="hljs-comment">/* Fortsetzung des Beispiels von oben */</span>
<span class="hljs-keyword">module</span> type EstablishmentType = {
  <span class="hljs-keyword">type</span> profession;
  <span class="hljs-keyword">let</span> getProfession: <span class="hljs-function"><span class="hljs-params">profession</span> =&gt;</span> <span class="hljs-built_in">string</span>;
};
</code></pre>
<p>Eine Signatur definiert die Liste der Anforderungen, die ein Modul der Reihe nach erfüllen muss, damit das Modul der Signatur entspricht. Diese Anforderungen haben die Form:</p>
<ul>
<li><code>let x: int;</code> benötigt eine <code>let</code>-Bindung namens <code>x</code> des Typs <code>int</code>.</li>
<li><code>type t = someType;</code> verlangt, dass ein Feldtyp <code>t</code> einem <code>someType</code> gleicht.</li>
<li><code>type t;</code> benötigt ein Feldtyp <code>t</code> aber ohne irgendwelche Anforderungen an den tatsächlichen, konkreten Typ von <code>t</code> zu stellen. Wir würden <code>t</code> in anderen Einträgen in der Signatur verwenden, um Beziehungen zu beschreiben, z. B. <code>let makePair: t =&gt; (t, t)</code> aber wir können z. B. nicht davon ausgehen, dass <code>t</code> ein <code>int</code> ist. Das gibt uns großartige, erzwungene Abstraktionsfähigkeiten.</li>
</ul>
<p>Um die verschiedenen Arten von Typeneinträgen zu veranschaulichen, betrachte die obige Signatur <code>EstablishmentType</code>, die von einem Modul folgendes verlangt:</p>
<ul>
<li>Deklariere einen Typen namens <code>profession</code>.</li>
<li>Muss eine Funktion enthalten, die einen Wert vom Typ <code>profession</code> annimmt und einen String zurückgibt.</li>
</ul>
<p><strong>Hinweis</strong>:</p>
<p>Module des Typs <code>EstablishmentType</code> können mehr Felder enthalten als die Signatur deklariert, so wie das Modul <code>School</code> im vorigen Abschnitt (wenn wir uns entschließen, ihm den Typ <code>EstablishmentType</code> zuzuweisen. Andererseits stellt <code>School</code> jedes Feld bereit). Dadurch wird das <code>person1</code>-Feld zu einem erzwungenen Implementierungsdetail! Außenstehende können nicht darauf zugreifen, da es nicht in der Signatur enthalten ist. Die Signatur <strong>schränkt ein</strong>, auf was andere zugreifen können.</p>
<p>Der Typ <code>EstablementType.profession</code> ist <strong>abstract</strong>: er hat keinen konkreten Typ. Es drückt aus: „Es ist mir egal, was der tatsächliche Typ ist, aber er wird als Eingabe für <code>getProfession</code>“ verwendet. Dies ist nützlich, um viele Module unter demselben Interface zu platzieren:</p>
<pre><code class="hljs css languages- reason">module Company: EstablishmentType = {
 <span class="hljs-built_in"> type </span>profession = CEO | Designer | Engineer | <span class="hljs-built_in">..</span>.;

  let getProfession = (person) =&gt; <span class="hljs-built_in">..</span>.;
  let person1 = <span class="hljs-built_in">..</span>.;
  let person2 = <span class="hljs-built_in">..</span>.;
};
</code></pre>
<p>Es ist auch nützlich, den zugrunde liegenden Typ als Implementierungsdetail für andere zu verbergen, damit sich diese nicht darauf verlassen können. Wenn du fragst, was der Typ von <code>Company.profession</code> ist, wird dir nur mitgeteilt, dass „es sich um <code>Company.profession</code> handelt“, anstatt die Variante bereitzustellen.</p>
<h3><a class="anchor" aria-hidden="true" id="modulsignaturen-erweitern"></a><a href="#modulsignaturen-erweitern" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Modulsignaturen erweitern</h3>
<p>Wie Module selbst können Modulsignaturen auch durch <code>include module type of Foo</code> erweitert werden:</p>
<pre><code class="hljs css languages- reason"><span class="hljs-keyword">module</span> <span class="hljs-keyword">type</span> <span class="hljs-type">BaseComponent</span> = {
  <span class="hljs-keyword">let</span> defaultGreeting: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">let</span> getAudience: (~excited: <span class="hljs-built_in">bool</span>) =&gt; <span class="hljs-built_in">string</span>;
};

<span class="hljs-keyword">module</span> <span class="hljs-keyword">type</span> <span class="hljs-type">ActualComponent</span> = {
  /* the signature is copied over */
  <span class="hljs-keyword">include</span> (<span class="hljs-keyword">module</span> <span class="hljs-keyword">type</span> <span class="hljs-keyword">of</span> <span class="hljs-type">BaseComponent</span>);
  <span class="hljs-keyword">let</span> render: <span class="hljs-built_in">unit</span> =&gt; <span class="hljs-built_in">string</span>;
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="jede-rei-datei-ist-eine-signatur"></a><a href="#jede-rei-datei-ist-eine-signatur" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Jede <code>.rei</code>-Datei ist eine Signatur</h3>
<p>Ähnlich wie eine <code>React.re</code>-Datei implizit ein Modul <code>React</code> definiert, definiert <code>React.rei</code> implizit eine Signatur für <code>React</code>. Wenn <code>React.rei</code> nicht vorhanden ist, wird die Signatur von <code>React.re</code> standardmäßig alle Felder des Moduls bereitstellen. Da sie keine Implementierungsdateien enthalten, werden <code>.rei</code>-Dateien im Ökosystem verwendet, um auch die öffentliche API ihrer entsprechenden Module zu dokumentieren.</p>
<pre><code class="hljs css languages- reason">/* file <span class="hljs-type">React</span>.re (implementation. <span class="hljs-type">Compiles</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">module</span> <span class="hljs-type">React</span>) */
<span class="hljs-keyword">type</span> state = <span class="hljs-built_in">int</span>;
<span class="hljs-keyword">let</span> render = (str) =&gt; str;
</code></pre>
<pre><code class="hljs css languages- reason">/* file <span class="hljs-type">React</span>.rei (interface. <span class="hljs-type">Compiles</span> <span class="hljs-keyword">to</span> signature <span class="hljs-keyword">of</span> <span class="hljs-keyword">module</span> <span class="hljs-type">React</span>) */
<span class="hljs-keyword">type</span> state = <span class="hljs-built_in">int</span>;
<span class="hljs-keyword">let</span> render: str =&gt; str;
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="modulfunktionen-functors"></a><a href="#modulfunktionen-functors" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Modulfunktionen (functors)</h2>
<p>Module können an Funktionen übergeben werden! Es wäre vergleichbar mit der Übergabe einer Datei als „first-class“-Element. Module befinden sich jedoch auf einer anderen „Ebene“ der Sprache als andere gängige Konzepte, so dass wir sie nicht an <em>reguläre</em> Funktionen übergeben können. Statt dessen übergeben wir sie an spezielle Funktionen, die „Funktoren“ (functors) genannt werden.</p>
<p>Die Syntax zum Definieren und Verwenden von Funktoren ähnelt sehr der Syntax zum Definieren und Verwenden von regulären Funktionen. Die Hauptunterschiede sind:</p>
<ul>
<li>Funktoren verwenden das <code>module</code>-Schlüsselwort anstatt <code>let</code>.</li>
<li>Funktoren nehmen Module als Argumente an und liefern ein Modul zurück.</li>
<li>Funktoren <em>benötigen</em> annotierte Argumente.</li>
<li>Funktoren müssen mit einem Großbuchstaben beginnen (so wie Module/Signaturen).</li>
</ul>
<p>Hier ist ein Beispiel für einen Funktor <code>MakeSet</code>, der ein Modul vom Typ <code>Comparable</code> akzeptiert und eine neue Menge zurückgibt, die solche vergleichbaren Elemente enthalten kann.</p>
<pre><code class="hljs css languages- reason"><span class="hljs-keyword">module</span> type Comparable = {
  <span class="hljs-keyword">type</span> t;
  <span class="hljs-keyword">let</span> equal: <span class="hljs-function">(<span class="hljs-params">t, t</span>) =&gt;</span> bool;
};

<span class="hljs-keyword">module</span> MakeSet = (Item: Comparable) =&gt; {
  <span class="hljs-comment">/* lass uns eine Liste als unsere naive Grunddatenstruktur verwenden */</span>
  <span class="hljs-keyword">type</span> backingType = list(Item.t);
  <span class="hljs-keyword">let</span> empty = [];
  <span class="hljs-keyword">let</span> add = (currentSet: backingType, newItem: Item.t) : <span class="hljs-function"><span class="hljs-params">backingType</span> =&gt;</span>
    <span class="hljs-comment">/* wenn item existiert */</span>
    <span class="hljs-keyword">if</span> (List.exists(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> Item.equal(x, newItem), currentSet)) {
      currentSet <span class="hljs-comment">/* return the same (immutable) set (a list really) */</span>
    } <span class="hljs-keyword">else</span> {
      [
        newItem,
        ...currentSet <span class="hljs-comment">/* füge vorne in der Menge ein und gebe sie zurück */</span>
      ]
    };
};
</code></pre>
<p>Funktoren können mithilfe der Syntax eines Funktionsaufrufes ausgeführt werden. In diesem Fall erstellen wir eine Menge, deren Elemente Paare von ganzen Zahlen sind.</p>
<pre><code class="hljs css languages- reason"><span class="hljs-keyword">module</span> IntPair = {
  <span class="hljs-keyword">type</span> t = (int, int);
  <span class="hljs-keyword">let</span> equal = <span class="hljs-function">(<span class="hljs-params">(<span class="hljs-params">x1, y1</span>), (<span class="hljs-params">x2, y2</span>)</span>) =&gt;</span> x1 == x2 &amp;&amp; y1 == y2;
  <span class="hljs-keyword">let</span> create = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> (x, y);
};

<span class="hljs-comment">/* IntPair genügt der Comparable-Signatur wie von MakeSet verlangt */</span>
<span class="hljs-keyword">module</span> SetOfIntPairs = MakeSet(IntPair);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="typen-von-modulfunktionen"></a><a href="#typen-von-modulfunktionen" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Typen von Modulfunktionen</h3>
<p>Wie bei Modultypen sind Funktortypen auch verwendbar, um zu beschränken und zu verbergen, was wir von Funktoren annehmen können. Die Syntax für Funktortypen ist konsistent mit denen für Funktionstypen, aber mit Typen, die großgeschrieben sind, um die Signaturen von Modulen darzustellen, die der Funktor als Argumente und Rückgabewerte akzeptiert. Im vorherigen Beispiel haben wir den zugrundeliegenden Typ einer Menge bereitgestellt. Indem wir <code>MakeSet</code> eine Funktorsignatur geben, können wir die zugrunde liegende Datenstruktur verbergen!</p>
<pre><code class="hljs css languages- reason">module<span class="hljs-built_in"> type </span>Comparable = <span class="hljs-built_in">..</span>.

module<span class="hljs-built_in"> type </span>MakeSetType = (Item: Comparable) =&gt; {
 <span class="hljs-built_in"> type </span>backingType;
  let empty: backingType;
  let add: (backingType, Item.t) =&gt; backingType;
};

module MakeSet: MakeSetType = (Item: Comparable) =&gt; {
  <span class="hljs-built_in">..</span>.
};
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="nachteile"></a><a href="#nachteile" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Nachteile</h2>
<p>Module und Funktoren sind auf einer anderen „Sprachebene“ als der Rest (Funktionen, let-Bindungen, Datenstrukturen usw.). Zum Beispiel kannst du sie nicht einfach in einem Tupel oder Record verwenden. Wäge ihre Verwendung ab! In vielen Fällen ist ein Record oder eine Funktion ausreichend.</p>
<pre><code class="hljs css languages- reason">module <span class="hljs-type">School</span> = <span class="hljs-meta">{...}</span>;

/* dies wird dir sofort einen <span class="hljs-type">Syntaxfehler</span> geben! */
<span class="hljs-keyword">let</span> schools = (<span class="hljs-type">School</span>, <span class="hljs-type">School</span>);
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/de/object.html">← Objekt</a><a class="docs-next button" href="/docs/de/promise.html">Promise →</a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#grundlagen">Grundlagen</a><ul class="toc-headings"><li><a href="#erzeugung">Erzeugung</a></li><li><a href="#ein-modul-mit-open-offnen">Ein Modul mit <code>open</code> öffnen</a></li><li><a href="#module-erweitern">Module erweitern</a></li><li><a href="#jede-re-datei-ist-ein-modul">Jede <code>.re</code>-Datei ist ein Modul</a></li></ul></li><li><a href="#signaturen">Signaturen</a><ul class="toc-headings"><li><a href="#erzeugung-1">Erzeugung</a></li><li><a href="#modulsignaturen-erweitern">Modulsignaturen erweitern</a></li><li><a href="#jede-rei-datei-ist-eine-signatur">Jede <code>.rei</code>-Datei ist eine Signatur</a></li></ul></li><li><a href="#modulfunktionen-functors">Modulfunktionen (functors)</a><ul class="toc-headings"><li><a href="#typen-von-modulfunktionen">Typen von Modulfunktionen</a></li></ul></li><li><a href="#nachteile">Nachteile</a></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.min.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper, .onPageNav',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:de"]}
              });
            </script></body></html>