<!DOCTYPE html><html lang="de"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Konvertieren von OCaml · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Da Reason nur eine weitere Syntax für OCaml ist, ist die Konvertierung eines OCaml-Projekts einfach und erfordert keine semantischen Änderungen. Es sind jedoch Änderungen einiger Build-Einstellungen und weitere Anpassungen erforderlich."/><meta name="docsearch:language" content="de"/><meta property="og:title" content="Konvertieren von OCaml · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/index.html"/><meta property="og:description" content="Da Reason nur eine weitere Syntax für OCaml ist, ist die Konvertierung eines OCaml-Projekts einfach und erfordert keine semantischen Änderungen. Es sind jedoch Änderungen einiger Build-Einstellungen und weitere Anpassungen erforderlich."/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/de"><img class="logo" src="/img/dummy.svg" alt="Reason"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/de/what-and-why" target="_self">Dokumentation</a></li><li class=""><a href="/de/try" target="_self">Try</a></li><li class=""><a href="/api/index" target="_self">API</a></li><li class=""><a href="/docs/de/community" target="_self">Community</a></li><li class=""><a href="/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg"/>Deutsch</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/ja/convert-from-ocaml">日本語</a></li><li><a href="/docs/en/convert-from-ocaml">English</a></li><li><a href="/docs/es-ES/convert-from-ocaml">Español</a></li><li><a href="/docs/fr/convert-from-ocaml">Français</a></li><li><a href="/docs/ko/convert-from-ocaml">한국어</a></li><li><a href="/docs/pt-BR/convert-from-ocaml">Português (Brasil)</a></li><li><a href="/docs/ru/convert-from-ocaml">Русский</a></li><li><a href="/docs/uk/convert-from-ocaml">Українська</a></li><li><a href="/docs/zh-CN/convert-from-ocaml">中文</a></li><li><a href="/docs/zh-TW/convert-from-ocaml">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank" rel="noreferrer noopener">Beim Übersetzen helfen</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Nativ</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Einführung</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/what-and-why">Was &amp; Wieso</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Setup</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/installation">Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/de/editor-plugins">Editor-Plugins</a></li><li class="navListItem"><a class="navItem" href="/docs/de/extra-goodies">Weitere Goodies</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Grundlagen der Sprache</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/overview">Übersicht</a></li><li class="navListItem"><a class="navItem" href="/docs/de/let-binding">Let Binding</a></li><li class="navListItem"><a class="navItem" href="/docs/de/type">Typen!</a></li><li class="navListItem"><a class="navItem" href="/docs/de/string-and-char">String &amp; Char</a></li><li class="navListItem"><a class="navItem" href="/docs/de/boolean">Boolean</a></li><li class="navListItem"><a class="navItem" href="/docs/de/integer-and-float">Integer &amp; Float</a></li><li class="navListItem"><a class="navItem" href="/docs/de/tuple">Tuple</a></li><li class="navListItem"><a class="navItem" href="/docs/de/record">Record</a></li><li class="navListItem"><a class="navItem" href="/docs/de/variant">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/de/null-undefined-option">Null, Undefined &amp; Option</a></li><li class="navListItem"><a class="navItem" href="/docs/de/list-and-array">List &amp; Array</a></li><li class="navListItem"><a class="navItem" href="/docs/de/function">Funktionen</a></li><li class="navListItem"><a class="navItem" href="/docs/de/if-else">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/de/fast-pipe">Fast Pipe</a></li><li class="navListItem"><a class="navItem" href="/docs/de/more-on-type">Mehr über Typen</a></li><li class="navListItem"><a class="navItem" href="/docs/de/destructuring">Destrukturierung</a></li><li class="navListItem"><a class="navItem" href="/docs/de/pattern-matching">Pattern-Matching!</a></li><li class="navListItem"><a class="navItem" href="/docs/de/mutation">Mutation</a></li><li class="navListItem"><a class="navItem" href="/docs/de/imperative-loops">Imperative Schleifen</a></li><li class="navListItem"><a class="navItem" href="/docs/de/jsx">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/de/external">External</a></li><li class="navListItem"><a class="navItem" href="/docs/de/exception">Exception</a></li><li class="navListItem"><a class="navItem" href="/docs/de/object">Objekt</a></li><li class="navListItem"><a class="navItem" href="/docs/de/module">Module</a></li><li class="navListItem"><a class="navItem" href="/docs/de/promise">Promise</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">JavaScript</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/interop">Interoperabilität</a></li><li class="navListItem"><a class="navItem" href="/docs/de/syntax-cheatsheet">Syntax Cheatsheet</a></li><li class="navListItem"><a class="navItem" href="/docs/de/libraries">Libraries</a></li><li class="navListItem"><a class="navItem" href="/docs/de/converting-from-js">Konvertieren von JS</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Nativ</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/native">Nativ</a></li><li class="navListItem"><a class="navItem" href="/docs/de/quickstart-ocaml">Schnellstart</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/de/convert-from-ocaml">Konvertieren von OCaml</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Weiteres</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/faq">Häufige Fragen</a></li><li class="navListItem"><a class="navItem" href="/docs/de/comparison-to-ocaml">Vergleich zu OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/de/newcomer-examples">Newcomer-Beispiele</a></li><li class="navListItem"><a class="navItem" href="/docs/de/project-structure">Projektstruktur</a></li></ul></div></div></section></div><script>
            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/de" target="_blank" rel="noreferrer noopener">Translate</a><h1 class="postHeaderTitle">Konvertieren von OCaml</h1></header><article><div><span><p>Da Reason nur eine weitere Syntax für OCaml ist, ist die Konvertierung eines OCaml-Projekts einfach und erfordert keine semantischen Änderungen. Es sind jedoch Änderungen einiger Build-Einstellungen und weitere Anpassungen erforderlich.</p>
<h2><a class="anchor" aria-hidden="true" id="ocamlbuild-rebuild"></a><a href="#ocamlbuild-rebuild" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>OCamlBuild -&gt; Rebuild</h2>
<p>Reason kommt mit einem direkten Ersatz für <code>ocamlbuild</code> namens <code>rebuild</code>, der automatisch jede Reason-Datei mit deinen OCaml-Dateien ohne zusätzliche Konfiguration zusammenbauen wird. Auf diese Weise kannst du deinem vorhandenen OCaml-Projekt Schritt für Schritt Reason-Dateien hinzufügen. Wo immer sich dein Skript auf <code>ocamlbuild</code> bezieht, ersetze es einfach durch <code>rebuild</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="makefile"></a><a href="#makefile" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Makefile</h2>
<p>Wenn dein Build-System explizite Build-Befehle ausführt, kannst du Reason mit <code>ocamlopt/ocamlc</code> am einfachsten verwenden, indem du jedem Kompilierungsschritt die folgenden Flags hinzufügst:</p>
<pre><code class="hljs css languages- sh"><span class="hljs-comment"># intf-suffix sagt dem Kompiler wo er die entsprechenden Interface-Dateien finden kann</span>
ocamlopt -pp refmt -intf-suffix rei -impl myFile.re
ocamlopt -pp refmt -intf myFile.rei
</code></pre>
<p>Wenn du <code>ocamlbuild</code> ohne <code>rebuild</code> verwendest, dann füge deiner <code>_tags</code>-Dateo folgendes hinzu, aber dies wird wahrscheinlich nicht ausreichen, weil <code>ocamlc</code>/<code>ocamlopt</code> die <code>-intf/-impl/-intf-suffix</code>-Flags benötigen wird:</p>
<pre><code class="hljs">&lt;**/*.{re,.rei}&gt;: package(reason), syntax(utf8)
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="fix-fur-die-konstruktorsyntax"></a><a href="#fix-fur-die-konstruktorsyntax" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fix für die Konstruktorsyntax</h2>
<p>Der konvertierte Reason-Code könnte an Variantenkonstruktoren <code>[@implicit_arity]</code> anhängen, wie etwa <code>C 1 2 [@implicit_arity]</code>. Dies liegt an der Tatsache, dass OCaml die mehrdeutige Syntax hat, bei der ein Konstruktor mit mehreren Argumenten ein Argument in Tupelform erwartet. Daher wissen wir zum Zeitpunkt des Parsens nicht, ob <code>C(1, 2)</code> in OCaml als <code>C(1, 2)</code> oder <code>C 1 2</code> in Reason übersetzt werden sollte. Standardmäßig werden wir es in <code>C 1 2 [@implicit_arity]</code> umwandeln, was dem Compiler sagt, dass dies entweder <code>C 1 2</code> oder <code>C(1, 2)</code> sein kann.</p>
<p>Um zu verhindern, dass <code>[@implicit_arity]</code> generiert wird, kann man <code>refmt</code> mit <code>--assume-explicit-arity</code> ausführen. Dies zwingt den Formatierer, <code>C 1 2</code> anstatt <code>C 1 2[@implicit_arity]</code> zu generieren.</p>
<p>Da jedoch <code>C 1 2</code> mehrere Argumente erfordert, kann die Kompilierung fehlschlagen, wenn es sich tatsächlich um einen Konstruktor mit einem einzelnen Tupel als Argument handelt (z. B. <code>Some</code>). Wir haben bereits einige interne Ausnahmeregeln für die gewöhnlichen Konstruktoren, die ein einzelnes Tupel als Argument benötigen, damit sie korrekt konvertiert werden (z. B. wird <code>Some (1, 2)</code> in <code>Some (1, 2)</code> konvertiert anstelle von <code>Some 1 2</code>, was nicht kompiliert werden kann).</p>
<p>Um eine eigene Ausnahmeliste bereitzustellen, erstelle eine zeilengetrennte Datei, die alle Konstruktoren (ohne Modulpräfix) in deinem Projekt enthält, die ein einzelnes Tupel als Argument erwarten, und verwende <code>--heuristics-file &lt;filename&gt;</code>, um <code>refmt</code> zu sagen, dass alle Konstruktoren in der Datei als Konstruktor mit einem einzigen Tupelargument behandelt werden:</p>
<pre><code class="hljs css languages- sh">&gt; cat heuristics.txt
  TupleConstructor
  And
  Or
</code></pre>
<pre><code class="hljs css languages- sh">&gt; cat test.ml
</code></pre>
<pre><code class="hljs css languages- ocaml"><span class="hljs-keyword">type</span> tm =
  <span class="hljs-type">TupleConstructor</span> <span class="hljs-keyword">of</span> (<span class="hljs-built_in">int</span> * <span class="hljs-built_in">int</span>)
| <span class="hljs-type">MultiArgumentsConstructor</span> <span class="hljs-keyword">of</span> <span class="hljs-built_in">int</span> * <span class="hljs-built_in">int</span>
<span class="hljs-keyword">let</span> x = <span class="hljs-type">TupleConstructor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
<span class="hljs-keyword">let</span> y = <span class="hljs-type">MultiArgumentsConstructor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
<span class="hljs-keyword">module</span> <span class="hljs-type">Test</span> = <span class="hljs-keyword">struct</span>
  <span class="hljs-keyword">type</span> a = | <span class="hljs-type">And</span> <span class="hljs-keyword">of</span> (<span class="hljs-built_in">int</span> * <span class="hljs-built_in">int</span>) | <span class="hljs-type">Or</span> <span class="hljs-keyword">of</span> (<span class="hljs-built_in">int</span> * <span class="hljs-built_in">int</span>)
<span class="hljs-keyword">end</span>;;
<span class="hljs-keyword">let</span> a = <span class="hljs-type">Test</span>.<span class="hljs-type">And</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
<span class="hljs-keyword">let</span> b = <span class="hljs-type">Test</span>.<span class="hljs-type">Or</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
<span class="hljs-keyword">let</span> c = <span class="hljs-type">Some</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
</code></pre>
<p>Dann wird angenommen, dass nur die Konstruktorbezeichner, die aufgelistet wurden, Tupel anstelle von mehreren Argumenten akzeptieren.</p>
<pre><code class="hljs css languages- sh">&gt; refmt --heuristics-file \
    ./heuristics.txt --assume-explicit-arity \
    --parse ml --<span class="hljs-built_in">print</span> re test.ml
</code></pre>
<pre><code class="hljs css languages- reason">type tm =
  | TupleConstructor((<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>))
  | MultiArgumentsConstructor(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>);

<span class="hljs-keyword">let</span> x = TupleConstructor((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));

<span class="hljs-keyword">let</span> y = MultiArgumentsConstructor(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);

module Test = {
  type a =
    | <span class="hljs-keyword">And</span>((<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>))
    | <span class="hljs-keyword">Or</span>((<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>));
};

<span class="hljs-keyword">let</span> a = Test.<span class="hljs-keyword">And</span>((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));

<span class="hljs-keyword">let</span> b = Test.<span class="hljs-keyword">Or</span>((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));

<span class="hljs-keyword">let</span> c = Some((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/de/quickstart-ocaml">← Schnellstart</a><a class="docs-next button" href="/docs/de/faq">Häufige Fragen →</a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#ocamlbuild-rebuild">OCamlBuild -&gt; Rebuild</a></li><li><a href="#makefile">Makefile</a></li><li><a href="#fix-fur-die-konstruktorsyntax">Fix für die Konstruktorsyntax</a></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.min.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper, .onPageNav',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:de"]}
              });
            </script></body></html>