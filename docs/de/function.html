<!DOCTYPE html><html lang="de"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Funktionen · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Funktionen · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/index.html"/><meta property="og:description" content="*Am Ende gibt es ein Cheat Sheet für die vollständige Funktionssyntax*"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/arduino-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><script type="text/javascript" src="/js/pjax-api.min.js"></script><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible doc separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/de"><img class="logo" src="/img/dummy.svg" alt="Reason"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/de/quickstart-javascript.html" target="_self">Dokumentation</a></li><li class=""><a href="/de/try.html" target="_self">Try</a></li><li class=""><a href="/api/index.html" target="_self">API</a></li><li class=""><a href="/docs/de/community.html" target="_self">Community</a></li><li class=""><a href="/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg"/>Deutsch</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/ja">日本語</a></li><li><a href="/en">English</a></li><li><a href="/es-ES">Español</a></li><li><a href="/fr">Français</a></li><li><a href="/ko">한국어</a></li><li><a href="/pt-BR">Português (Brasil)</a></li><li><a href="/ru">Русский</a></li><li><a href="/uk">Українська</a></li><li><a href="/zh-CN">中文</a></li><li><a href="/zh-TW">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank" rel="noreferrer noopener">Beim Übersetzen helfen</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Grundlagen der Sprache</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Einführung</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/what-and-why.html">Was &amp; Wieso</a></li></ul></div><div class="navGroup navGroupActive"><h3>Editor-Setup</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/global-installation.html">Globale Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/de/editor-plugins.html">Editor-Plugins</a></li><li class="navListItem"><a class="navItem" href="/docs/de/extra-goodies.html">Weitere Goodies</a></li></ul></div><div class="navGroup navGroupActive"><h3>Grundlagen der Sprache</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/overview.html">Übersicht</a></li><li class="navListItem"><a class="navItem" href="/docs/de/let-binding.html">Let Binding</a></li><li class="navListItem"><a class="navItem" href="/docs/de/type.html">Typen!</a></li><li class="navListItem"><a class="navItem" href="/docs/de/string-and-char.html">String &amp; Char</a></li><li class="navListItem"><a class="navItem" href="/docs/de/boolean.html">Boolean</a></li><li class="navListItem"><a class="navItem" href="/docs/de/integer-and-float.html">Integer &amp; Float</a></li><li class="navListItem"><a class="navItem" href="/docs/de/tuple.html">Tuple</a></li><li class="navListItem"><a class="navItem" href="/docs/de/record.html">Record</a></li><li class="navListItem"><a class="navItem" href="/docs/de/variant.html">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/de/list-and-array.html">List &amp; Array</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/docs/de/function.html">Funktionen</a></li><li class="navListItem"><a class="navItem" href="/docs/de/if-else.html">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/de/more-on-type.html">Mehr über Typen</a></li><li class="navListItem"><a class="navItem" href="/docs/de/destructuring.html">Destrukturierung</a></li><li class="navListItem"><a class="navItem" href="/docs/de/pattern-matching.html">Pattern-Matching!</a></li><li class="navListItem"><a class="navItem" href="/docs/de/mutation.html">Mutation</a></li><li class="navListItem"><a class="navItem" href="/docs/de/imperative-loops.html">Imperative Schleifen</a></li><li class="navListItem"><a class="navItem" href="/docs/de/jsx.html">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/de/external.html">External</a></li><li class="navListItem"><a class="navItem" href="/docs/de/exception.html">Exception</a></li><li class="navListItem"><a class="navItem" href="/docs/de/object.html">Objekt</a></li><li class="navListItem"><a class="navItem" href="/docs/de/module.html">Module</a></li><li class="navListItem"><a class="navItem" href="/docs/de/promise.html">Promise</a></li></ul></div><div class="navGroup navGroupActive"><h3>JavaScript</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/quickstart-javascript.html">Schnellstart</a></li><li class="navListItem"><a class="navItem" href="/docs/de/interop.html">Interoperabilität</a></li><li class="navListItem"><a class="navItem" href="/docs/de/syntax-cheatsheet.html">Syntax Cheatsheet</a></li><li class="navListItem"><a class="navItem" href="/docs/de/libraries.html">Libraries</a></li><li class="navListItem"><a class="navItem" href="/docs/de/converting-from-js.html">Konvertieren von JS</a></li></ul></div><div class="navGroup navGroupActive"><h3>Nativ</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/native.html">Nativ</a></li><li class="navListItem"><a class="navItem" href="/docs/de/quickstart-ocaml.html">Schnellstart</a></li><li class="navListItem"><a class="navItem" href="/docs/de/convert-from-ocaml.html">Konvertieren von OCaml</a></li></ul></div><div class="navGroup navGroupActive"><h3>Weiteres</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/faq.html">Häufige Fragen</a></li><li class="navListItem"><a class="navItem" href="/docs/de/comparison-to-ocaml.html">Vergleich zu OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/de/newcomer-examples.html">Newcomer-Beispiele</a></li><li class="navListItem"><a class="navItem" href="/docs/de/project-structure.html">Projektstruktur</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/de" target="_blank" rel="noreferrer noopener">Translate</a><h1>Funktionen</h1></header><article><div><span><p><em>Am Ende gibt es ein Cheat Sheet für die vollständige Funktionssyntax</em></p>
<p>Kannst du dir vorstellen, dass wir Funktionen bis jetzt nicht behandelt haben?</p>
<p>Funktionen werden mit einem Pfeil deklariert und geben den Ausdruck zurück.</p>
<pre><code class="hljs css reason">let greet = <span class="hljs-function"><span class="hljs-params">(name)</span> =&gt;</span> <span class="hljs-string">"Hello "</span> ++ name;
</code></pre>
<p>Dies deklariert eine Funktion mit dem Namen <code>greet</code>, die du so aufrufen kannst:</p>
<pre><code class="hljs css reason"><span class="hljs-selector-tag">greet</span>(<span class="hljs-string">"world!"</span>); <span class="hljs-comment">/* "Hello world!" */</span>
</code></pre>
<p>Funktionen mit mehreren Argumenten trennen diese mit Kommas voneinander:</p>
<pre><code class="hljs css reason">let <span class="hljs-keyword">add</span><span class="bash"> = (x, y, z) =&gt; x + y + z;
</span><span class="hljs-keyword">add</span><span class="bash">(1, 2, 3); /* 6 */
</span></code></pre>
<p>Bei längeren Funktionen würdest du den Rumpf mit einem Block umgeben:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> greetMore = <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> {
  <span class="hljs-keyword">let</span> part1 = <span class="hljs-string">"Hello"</span>;
  part1 ++ <span class="hljs-string">" "</span> ++ name
};
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="kein-argument"></a><a href="#kein-argument" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Kein Argument</h2>
<p>Eine Funktion erhält immer ein Argument. Aber manchmal würden wir sie z. B. für Seiteneffekte nutzen und haben nichts, was wir ihr übergeben könnten. In anderen Sprachen würden wir konzeptuell „kein Argument“ übergeben. In Reason erhält jede Funktion ein Argument. Dafür würden wir konzeptuell den Wert <code>()</code> übergeben, der „unit“ heißt.</p>
<pre><code class="hljs css reason"><span class="hljs-comment">/* erhalte &amp; destrukturiere das unit-Argument */</span>
<span class="hljs-keyword">let</span> logSomething = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  print_endline(<span class="hljs-string">"hello"</span>);
  print_endline(<span class="hljs-string">"world"</span>)
};

<span class="hljs-comment">/* rufe die Funktion mit dem Wert des Typs unit auf */</span>
logSomething();
</code></pre>
<p><code>()</code> ist ein total normaler Wert, nämlich der einzige mögliche Wert von <code>unit</code>. Reason gab ihm eine spezielle Syntax als bequeme Konvention.</p>
<h2><a class="anchor" aria-hidden="true" id="benannte-argumente"></a><a href="#benannte-argumente" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Benannte Argumente</h2>
<p>Funktionen mit mehreren Argumenten, besonders die deren Argumente den gleichen Typ haben, können beim Aufruf unübersichtlich sein.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> addCoordinates = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> {
  <span class="hljs-comment">/* use x and y here */</span>
};
<span class="hljs-comment">/* ... */</span>
addCoordinates(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>); <span class="hljs-comment">/* which is x, which is y? */</span>
</code></pre>
<p>In OCaml/Reason kannst du die Argumente mit Namen erweitern:</p>
<pre><code class="hljs css reason">let <span class="hljs-keyword">addCoordinates </span>= (~x, ~y) =&gt; {
  <span class="hljs-comment">/* use x and y here */</span>
}<span class="hljs-comment">;</span>
<span class="hljs-comment">/* ... */</span>
<span class="hljs-keyword">addCoordinates(~x=5, </span>~y=<span class="hljs-number">6</span>)<span class="hljs-comment">;</span>
</code></pre>
<p>Da uns Currying zur Verfügung steht (mehr dazu unten), können wir die Argumente in <strong>beliebiger Reihenfolge</strong> angeben:</p>
<pre><code class="hljs css reason">addCoordinates(~<span class="hljs-attribute">y</span>=6, ~<span class="hljs-attribute">x</span>=5);
</code></pre>
<p>Der <code>~x</code>-Teil in der Deklaration bedeutet, dass die Funktion ein Argument namens <code>x</code> akzeptiert und auf dieses im Funktionsrumpf mit dem selben Namen zugreifen kann. Du kannst auf die Argumente innerhalb des Funktionsrumpfs auch auf prägnante Art mit anderen Namen zugreifen:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> drawCircle = <span class="hljs-function">(<span class="hljs-params">~radius <span class="hljs-keyword">as</span> r, ~color <span class="hljs-keyword">as</span> c</span>) =&gt;</span> {
  setColor(c);
  startAt(r, r);
  <span class="hljs-comment">/* ... */</span>
};

drawCircle(~radius=<span class="hljs-number">10</span>, ~color=<span class="hljs-string">"red"</span>);
</code></pre>
<p>In der Tat ist <code>(~radius)</code> bloß eine Abkürzung (names <strong>punning</strong>) für <code>(~radius as radius)</code>.</p>
<p>Hier ist die Syntax für die Typisierung der Argumente:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> drawCircle = (~radius <span class="hljs-keyword">as</span> r: <span class="hljs-built_in">int</span>, ~color <span class="hljs-keyword">as</span> c: <span class="hljs-built_in">string</span>) =&gt; ...;
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="currying"></a><a href="#currying" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Currying</h3>
<p>Reason-Funktionen können automatisch <strong>partiell</strong> aufgerufen werden:</p>
<pre><code class="hljs css reason"><span class="hljs-attribute">let add</span> = (x, y) =&gt; x + y;
<span class="hljs-attribute">let addFive</span> = add(5);
<span class="hljs-attribute">let eleven</span> = addFive(6);
<span class="hljs-attribute">let twelve</span> = addFive(7);
</code></pre>
<p>Tatsächlin ist das obige <code>add</code> nichts anderes als syntaktischer Zucker hierfür:</p>
<pre><code class="hljs css reason">let add = (<span class="hljs-name">x</span>) =&gt; (<span class="hljs-name">y</span>) =&gt; x + y<span class="hljs-comment">;</span>
</code></pre>
<p>OCaml optimiert dies, um <a href="/try/?reason=DYUwLgBAhgJjEF4IAoAeBKRA+FBPTCOqEA1BLgNwBQVA9AFQTAD2zA1tJGABYgTMBXMAAchAQmhwAYgEsAbnxkBnaBAD6SmQDsA5qDUQAZgK0BjMDOZaIpqMGAT6tKqEiwYshYkkxkAVnRqF3AITWIkd08QZABGQKA">die unnötige Funktionserstellung</a> (hier 2 Funktionen, naiv ausgedrückt) wann immer es möglich ist! Dadurch erhalten wir</p>
<ul>
<li>Angenehme Syntax</li>
<li>Gratis Currying (jede Funktion erhält tatsächlich ein einziges Argument!)</li>
<li>Keine Performance-Kosten</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="optional-benannte-argumente"></a><a href="#optional-benannte-argumente" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Optional benannte Argumente</h2>
<p>Benannte Funktionsargumente können bei der Deklaration optional gemacht werden. Du kannst sie dann beim Funktionsaufruf weglassen.</p>
<pre><code class="hljs css reason"><span class="hljs-comment">/* radius kann weggelassen werden */</span>
<span class="hljs-keyword">let</span> drawCircle = <span class="hljs-function">(<span class="hljs-params">~color, ~radius=?, (<span class="hljs-params"></span>)</span>) =&gt;</span> {
  setColor(color);
  <span class="hljs-keyword">switch</span> (radius) {
  | <span class="hljs-function"><span class="hljs-params">None</span> =&gt;</span> startAt(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)
  | Some(r_) =&gt; startAt(r_, r_)
  }
};
</code></pre>
<p>Wenn in dieser Syntax angegeben, dann wird <code>radius</code> als <code>option</code>-Typ der Standardbibliothek <strong>verpackt</strong> und ist standardmäßig <code>None</code>. Falls angegeben, dann wird der Wert in einem <code>Some</code> verpackt. Damit ist hier der Typ von <code>radius</code> entweder <code>None</code> oder <code>Some(int)</code>.</p>
<p><strong>Bemerkung</strong>: <code>None | Some(foo)</code> ist ein Datenstrukturtyp namens Variante, wie <a href="/docs/de/variant.html">zuvor</a> beschrieben. Dieser bestimmte Variantentyp wird durch die Standardbibliothek bereitgestellt. Er heißt <code>option</code>. Seine Definition: <code>type option('a) = None | Some('a)</code>.</p>
<p><strong>Beachte</strong> die unit <code>()</code> am Ende von <code>drawCircle</code>. Da sowohl <code>radius</code> als auch <code>color</code> benannt sind, mit Currying versehen und in beliebiger Reihenfolge verwendet werden können, ist es ohne diese unklar, was das folgende bedeutet:</p>
<pre><code class="hljs css reason"><span class="hljs-attribute">let whatIsThis</span> = drawCircle(~color);
</code></pre>
<p>Ist <code>whatIsThis</code> eine Version der Funktion <code>drawCircle</code> auf die Currying angewendet wurde, welche den optionalen <code>radius</code> erwartet? Oder ist der Aufruf vollständig? Um diese Unklarheit zu beseitigen, ergänze <code>drawCircle</code> mit einem unbenannten Argument (die Konvention ist <code>()</code>) und OCaml wird als Faustregel annehmen, dass das optionale Argument weggelassen wurde, wenn das unbenannte Argument angegeben wird.</p>
<pre><code class="hljs css reason"><span class="hljs-attribute">let curriedFunction</span> = drawCircle(~color);
<span class="hljs-attribute">let actualResultWithoutProvidingRadius</span> = drawCircle(~color, ());
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="explizit-ubergebenes-optionales-argument"></a><a href="#explizit-ubergebenes-optionales-argument" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Explizit übergebenes optionales Argument</h3>
<p>Manchmal möchtest du vielleicht einer Funktion einen Wert übergeben können ohne zu wissen, ob der Wert <code>None</code> oder <code>Some(a)</code> ist. Die naive Weise wäre:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> result =
  switch (payloadRadius) {
  | <span class="hljs-type">None</span> =&gt; drawCircle(~color, ())
  | <span class="hljs-type">Some</span>(r) =&gt; drawCircle(~color, ~radius=r, ())
  };
</code></pre>
<p>Dies wird schnell umständlich. Wir stellen eine Abkürzung bereit:</p>
<pre><code class="hljs css reason"><span class="hljs-built_in">let</span> result = drawCircle(~<span class="hljs-built_in">color</span>, ~<span class="hljs-built_in">radius</span>=?payloadRadius, ());
</code></pre>
<p>Dies bedeutet „Mit ist klar, dass <code>radius</code> optional ist und dass er ein <code>int</code> sein muss, wenn ich ihm einen Wert übergebe, aber ich weiß nicht ob der Wert, den ich übergebe, <code>None</code> oder <code>Some(val)</code> ist, und daher übergebe ich den ganzen, verpackten <code>option</code>-Wert“.</p>
<h3><a class="anchor" aria-hidden="true" id="optional-mit-default-wert"></a><a href="#optional-mit-default-wert" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Optional mit Default-Wert</h3>
<p>Optional benannte Argumente können auch einen Default-Wert erhalten. In diesen Fall werden sie nicht mit einem <code>option</code>-Typ verpackt.</p>
<pre><code class="hljs css reason"><span class="hljs-built_in">let</span> drawCircle = (~<span class="hljs-built_in">radius</span>=<span class="hljs-number">1</span>, ~<span class="hljs-built_in">color</span>, ()) =&gt; {
  setColor(<span class="hljs-built_in">color</span>);
  startAt(<span class="hljs-built_in">radius</span>, <span class="hljs-built_in">radius</span>)
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="rekursive-funktionen"></a><a href="#rekursive-funktionen" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Rekursive Funktionen</h3>
<p>Standardmäßig kann ein Wert nicht die Bindung sehen, auf die sie zeigt, aber durch Hinzufügen des Schlüsselworts <code>rec</code> in einer <code>let</code>-Bindung wird dies möglich. Dies gestattet Funktionen, sich selbst zu sehen und aufzurufen, wodurch wir die Macht der Rekursion erhalten.</p>
<pre><code class="hljs css reason">let rec neverTerminate = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> neverTerminate();
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="gegenseitig-rekursive-funktionen"></a><a href="#gegenseitig-rekursive-funktionen" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Gegenseitig rekursive Funktionen</h3>
<p>Gegenseitig rekursive Funktionen beginnen wie eine einzige rekursive Funktion mit dem Schlüsselwort <code>rec</code> und werden dann mit <code>and</code> verkettet:</p>
<pre><code class="hljs css reason">let rec callSecond = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> callFirst()
<span class="hljs-keyword">and</span> callFirst = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> callSecond();
</code></pre>
<p><strong>Beachte</strong> dass am Ende der ersten Zeile kein Semikolon steht und dass in der zweiten Zeile kein <code>let</code> zu finden ist.</p>
<h2><a class="anchor" aria-hidden="true" id="tips-tricks"></a><a href="#tips-tricks" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tips &amp; Tricks</h2>
<p>Cheat Sheet für die Funktionssyntax:</p>
<h3><a class="anchor" aria-hidden="true" id="deklaration"></a><a href="#deklaration" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Deklaration</h3>
<pre><code class="hljs css reason"><span class="hljs-comment">/* Anonyme Funktion. Nur zur Vollständigkeit aufgeführt */</span>
(x) =&gt; <span class="hljs-function">(<span class="hljs-params">y</span>) =&gt;</span> <span class="hljs-number">1</span>;
<span class="hljs-comment">/* syntaktischer Zucker für obiges */</span>
(x, y) =&gt; <span class="hljs-number">1</span>;
<span class="hljs-comment">/* weise einem Namen zu */</span>
<span class="hljs-keyword">let</span> add = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> <span class="hljs-number">1</span>;

<span class="hljs-comment">/* benannt */</span>
<span class="hljs-keyword">let</span> add = <span class="hljs-function">(<span class="hljs-params">~first <span class="hljs-keyword">as</span> x, ~second <span class="hljs-keyword">as</span> y</span>) =&gt;</span> x + y;
<span class="hljs-comment">/* mit punning als syntaktischem Zucker */</span>
<span class="hljs-keyword">let</span> add = <span class="hljs-function">(<span class="hljs-params">~first, ~second</span>) =&gt;</span> first + second;

<span class="hljs-comment">/* benannt mit Default-Wert */</span>
<span class="hljs-keyword">let</span> add = <span class="hljs-function">(<span class="hljs-params">~first <span class="hljs-keyword">as</span> x=<span class="hljs-number">1</span>, ~second <span class="hljs-keyword">as</span> y=<span class="hljs-number">2</span></span>) =&gt;</span> x + y;
<span class="hljs-comment">/* mit punning */</span>
<span class="hljs-keyword">let</span> add = <span class="hljs-function">(<span class="hljs-params">~first=<span class="hljs-number">1</span>, ~second=<span class="hljs-number">2</span></span>) =&gt;</span> first + second;

<span class="hljs-comment">/* optional */</span>
<span class="hljs-keyword">let</span> add = <span class="hljs-function">(<span class="hljs-params">~first <span class="hljs-keyword">as</span> x=?, ~second <span class="hljs-keyword">as</span> y=?</span>) =&gt;</span> <span class="hljs-keyword">switch</span> (x) {...};
<span class="hljs-comment">/* mit punning */</span>
<span class="hljs-keyword">let</span> add = <span class="hljs-function">(<span class="hljs-params">~first=?, ~second=?</span>) =&gt;</span> <span class="hljs-keyword">switch</span> (first) {...};
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="mit-typannotation"></a><a href="#mit-typannotation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mit Typannotation</h4>
<pre><code class="hljs css reason"><span class="hljs-comment">/* anonyme Funktion */</span>
(<span class="hljs-string">x:</span> <span class="hljs-keyword">int</span>) =&gt; (<span class="hljs-string">y:</span> <span class="hljs-keyword">int</span>): <span class="hljs-keyword">int</span> =&gt; <span class="hljs-number">1</span>;
<span class="hljs-comment">/* syntaktischer Zucker für obiges */</span>
(<span class="hljs-string">x:</span> <span class="hljs-keyword">int</span>, <span class="hljs-string">y:</span> <span class="hljs-keyword">int</span>): <span class="hljs-keyword">int</span> =&gt; <span class="hljs-number">1</span>;
<span class="hljs-comment">/* weise einem Namen zu */</span>
let add = (<span class="hljs-string">x:</span> <span class="hljs-keyword">int</span>, <span class="hljs-string">y:</span> <span class="hljs-keyword">int</span>): <span class="hljs-keyword">int</span> =&gt; <span class="hljs-number">1</span>;

<span class="hljs-comment">/* benannt */</span>
let add = (~first <span class="hljs-keyword">as</span> <span class="hljs-string">x:</span> <span class="hljs-keyword">int</span>, ~second <span class="hljs-keyword">as</span> <span class="hljs-string">y:</span> <span class="hljs-keyword">int</span>) : <span class="hljs-keyword">int</span> =&gt; x + y;
<span class="hljs-comment">/* mit punning als syntaktischem Zucker */</span>
let add = (~<span class="hljs-string">first:</span> <span class="hljs-keyword">int</span>, ~<span class="hljs-string">second:</span> <span class="hljs-keyword">int</span>) : <span class="hljs-keyword">int</span> =&gt; first + second;

<span class="hljs-comment">/* benannt mit Default-Wert */</span>
let add = (~first <span class="hljs-keyword">as</span> <span class="hljs-string">x:</span> <span class="hljs-keyword">int</span>=<span class="hljs-number">1</span>, ~second <span class="hljs-keyword">as</span> <span class="hljs-string">y:</span> <span class="hljs-keyword">int</span>=<span class="hljs-number">2</span>) : <span class="hljs-keyword">int</span> =&gt; x + y;
<span class="hljs-comment">/* mit punning */</span>
let add = (~<span class="hljs-string">first:</span> <span class="hljs-keyword">int</span>=<span class="hljs-number">1</span>, ~<span class="hljs-string">second:</span> <span class="hljs-keyword">int</span>=<span class="hljs-number">2</span>) : <span class="hljs-keyword">int</span> =&gt; first + second;

<span class="hljs-comment">/* optional */</span>
let add = (~first <span class="hljs-keyword">as</span> <span class="hljs-string">x:</span> option(<span class="hljs-keyword">int</span>)=?, ~second as y: option(<span class="hljs-keyword">int</span>)=?) : <span class="hljs-keyword">int</span> =&gt; <span class="hljs-keyword">switch</span> (x) {...};
<span class="hljs-comment">/* mit punning */</span>
<span class="hljs-comment">/* beachte dass beim Aufruf ein `int` und kein `option int` übergeben wird */</span>
<span class="hljs-comment">/* innerhalb der Funktion sind `first` und `second` jeweils `option int`. */</span>
let add = (~<span class="hljs-string">first:</span> option(<span class="hljs-keyword">int</span>)=?, ~second: option(<span class="hljs-keyword">int</span>)=?) : <span class="hljs-keyword">int</span> =&gt; <span class="hljs-keyword">switch</span> (first) {...};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="anwendung"></a><a href="#anwendung" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Anwendung</h3>
<pre><code class="hljs css reason">/* Anonyme Anwendung. Nur zur Vollständigkeit aufgelistet */
<span class="hljs-keyword">add</span><span class="bash">(x)(y);
</span>/* syntaktischer Zucker für obiges */
<span class="hljs-keyword">add</span><span class="bash">(x, y);
</span>
/* benannt */
<span class="hljs-keyword">add</span><span class="bash">(~first=1, ~second=2);
</span>/* mit punning als syntaktischem Zucker */
<span class="hljs-keyword">add</span><span class="bash">(~first, ~second);
</span>
/* Anwendung mit Default-Wert. Wie die normale Anwendung */
<span class="hljs-keyword">add</span><span class="bash">(~first=1, ~second=2);
</span>
/* Explizite optionale Anwendung */
<span class="hljs-keyword">add</span><span class="bash">(~first=?Some(1), ~second=?Some(2));
</span>/* mit punning */
<span class="hljs-keyword">add</span><span class="bash">(~first?, ~second?);
</span></code></pre>
<h4><a class="anchor" aria-hidden="true" id="mit-typannotation-1"></a><a href="#mit-typannotation-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mit Typannotation</h4>
<pre><code class="hljs css reason"><span class="hljs-comment">/* Anonyme Anwendung */</span>
<span class="hljs-built_in">add</span>(x: <span class="hljs-built_in">int</span>)(y: <span class="hljs-built_in">int</span>);

<span class="hljs-comment">/* benannt */</span>
<span class="hljs-built_in">add</span>(~first=<span class="hljs-number">1</span>: <span class="hljs-built_in">int</span>, ~<span class="hljs-built_in">second</span>=<span class="hljs-number">2</span>: <span class="hljs-built_in">int</span>);
<span class="hljs-comment">/* mit punning als syntaktischem Zucker */</span>
<span class="hljs-built_in">add</span>(~first: <span class="hljs-built_in">int</span>, ~<span class="hljs-built_in">second</span>: <span class="hljs-built_in">int</span>);

<span class="hljs-comment">/* Anwendung mit Default-Wert. Wie die normale Anwendung */</span>
<span class="hljs-built_in">add</span>(~first=<span class="hljs-number">1</span>: <span class="hljs-built_in">int</span>, ~<span class="hljs-built_in">second</span>=<span class="hljs-number">2</span>: <span class="hljs-built_in">int</span>);

<span class="hljs-comment">/* explizite optionale Anwendung */</span>
<span class="hljs-built_in">add</span>(~first=?Some(<span class="hljs-number">1</span>): option(<span class="hljs-built_in">int</span>), ~<span class="hljs-built_in">second</span>=?Some(<span class="hljs-number">2</span>): option(<span class="hljs-built_in">int</span>));
<span class="hljs-comment">/* mit punning als syntaktischem Zucker */</span>
<span class="hljs-built_in">add</span>(~first: option(<span class="hljs-built_in">int</span>)?, ~<span class="hljs-built_in">second</span>: option(<span class="hljs-built_in">int</span>)?);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="alleinstehende-typsignatur"></a><a href="#alleinstehende-typsignatur" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Alleinstehende Typsignatur</h3>
<pre><code class="hljs css reason"><span class="hljs-comment">/* erster Argtyp, zweiter Argtyp, return Typ */</span>
type foo = <span class="hljs-built_in">int</span> =&gt; <span class="hljs-built_in">int</span> =&gt; <span class="hljs-built_in">int</span>;
<span class="hljs-comment">/* syntaktischer Zucker für obiges */</span>
type foo = (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>) =&gt; <span class="hljs-built_in">int</span>;

<span class="hljs-comment">/* benannt */</span>
type foo = (~first: <span class="hljs-built_in">int</span>, ~second: <span class="hljs-built_in">int</span>) =&gt; <span class="hljs-built_in">int</span>;

<span class="hljs-comment">/* benannt mit Default-Wert */</span>
type foo = (~first: <span class="hljs-built_in">int</span>=?, ~second: <span class="hljs-built_in">int</span>=?) =&gt; <span class="hljs-built_in">int</span>;
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="in-interface-dateien"></a><a href="#in-interface-dateien" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>In Interface-Dateien</h4>
<p>Um eine Funktion aus der Implentierungsdatei zu annotieren (<code>.re</code>):</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> add: <span class="hljs-keyword">int</span> =&gt; <span class="hljs-keyword">int</span> =&gt; <span class="hljs-keyword">int</span>;
<span class="hljs-comment">/* syntaktischer Zucker für obiges */</span>
<span class="hljs-keyword">let</span> add: (<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>) =&gt; <span class="hljs-keyword">int</span>;
</code></pre>
<p>Es gelten die gleichen Regel wie im vorigen Abschnitt, außer dass <code>type foo = bar</code> mit <code>let add: bar</code> ersetzt wird.</p>
<p>Verwechsle dies <strong>nicht</strong> mit der eigentlichen Typexportierung in der Interface-Datei. <code>let add: bar</code> annotiert einen existierenden Wert <code>bar</code> aus der Implementierungsdatei. <code>type foo = bar</code> exportiert einen Typ der gleichen Form wie aus der Implementierungsdatei.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="list-and-array.html">← List &amp; Array</a><a class="docs-next button" href="if-else.html">If-Else →</a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#kein-argument">Kein Argument</a></li><li><a href="#benannte-argumente">Benannte Argumente</a><ul class="toc-headings"><li><a href="#currying">Currying</a></li></ul></li><li><a href="#optional-benannte-argumente">Optional benannte Argumente</a><ul class="toc-headings"><li><a href="#explizit-ubergebenes-optionales-argument">Explizit übergebenes optionales Argument</a></li><li><a href="#optional-mit-default-wert">Optional mit Default-Wert</a></li><li><a href="#rekursive-funktionen">Rekursive Funktionen</a></li><li><a href="#gegenseitig-rekursive-funktionen">Gegenseitig rekursive Funktionen</a></li></ul></li><li><a href="#tips-tricks">Tips &amp; Tricks</a><ul class="toc-headings"><li><a href="#deklaration">Deklaration</a></li><li><a href="#anwendung">Anwendung</a></li><li><a href="#alleinstehende-typsignatur">Alleinstehende Typsignatur</a></li></ul></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper, .onPageNav',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react'
              });
            </script></body></html>