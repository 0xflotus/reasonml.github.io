<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>Vergleich zu OCaml · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Vergleich zu OCaml · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/index.html"/><meta property="og:description" content="Wenn du von OCaml kommst oder als ein Neueinsteiger ein Tutorial über OCaml liest, ist diese Anleitung für dich! Aber vergiss nicht, dass [reason-tools](https://github.com/reasonml/reason-tools) spontan zwischen OCaml- und Reason-Syntax konvertieren können."/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/arduino-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/dummy.svg"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/docs/de/quickstart-javascript.html" target="_self">Dokumentation</a></li><li><a href="/de/try.html" target="_self">Try</a></li><li><a href="/api/index.html" target="_self">API</a></li><li><a href="/docs/de/community.html" target="_self">Community</a></li><li><a href="/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg"/>Deutsch</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/ja">日本語</a></li><li><a href="/en">English</a></li><li><a href="/es-ES">Español</a></li><li><a href="/fr">Français</a></li><li><a href="/ko">한국어</a></li><li><a href="/pt-BR">Português (Brasil)</a></li><li><a href="/ru">Русский</a></li><li><a href="/uk">Українська</a></li><li><a href="/zh-CN">中文</a></li><li><a href="/zh-TW">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank">Beim Übersetzen helfen</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Extra</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Einführung</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/what-and-why.html">Was &amp; Wieso</a></li></ul></div><div class="navGroup navGroupActive"><h3>Editor-Setup</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/global-installation.html">Globale Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/de/editor-plugins.html">Editor-Plugins</a></li><li class="navListItem"><a class="navItem" href="/docs/de/extra-goodies.html">Weitere Goodies</a></li></ul></div><div class="navGroup navGroupActive"><h3>Grundlagen der Sprache</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/overview.html">Übersicht</a></li><li class="navListItem"><a class="navItem" href="/docs/de/let-binding.html">Let Binding</a></li><li class="navListItem"><a class="navItem" href="/docs/de/type.html">Typen!</a></li><li class="navListItem"><a class="navItem" href="/docs/de/string-and-char.html">String &amp; Char</a></li><li class="navListItem"><a class="navItem" href="/docs/de/boolean.html">Boolean</a></li><li class="navListItem"><a class="navItem" href="/docs/de/integer-and-float.html">Integer &amp; Float</a></li><li class="navListItem"><a class="navItem" href="/docs/de/tuple.html">Tuple</a></li><li class="navListItem"><a class="navItem" href="/docs/de/record.html">Record</a></li><li class="navListItem"><a class="navItem" href="/docs/de/variant.html">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/de/list-and-array.html">List &amp; Array</a></li><li class="navListItem"><a class="navItem" href="/docs/de/function.html">Funktionen</a></li><li class="navListItem"><a class="navItem" href="/docs/de/if-else.html">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/de/more-on-type.html">Mehr über Typen</a></li><li class="navListItem"><a class="navItem" href="/docs/de/destructuring.html">Destrukturierung</a></li><li class="navListItem"><a class="navItem" href="/docs/de/pattern-matching.html">Pattern-Matching!</a></li><li class="navListItem"><a class="navItem" href="/docs/de/mutation.html">Mutation</a></li><li class="navListItem"><a class="navItem" href="/docs/de/imperative-loops.html">Imperative Schleifen</a></li><li class="navListItem"><a class="navItem" href="/docs/de/jsx.html">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/de/external.html">External</a></li><li class="navListItem"><a class="navItem" href="/docs/de/exception.html">Exception</a></li><li class="navListItem"><a class="navItem" href="/docs/de/object.html">Objekt</a></li><li class="navListItem"><a class="navItem" href="/docs/de/module.html">Module</a></li><li class="navListItem"><a class="navItem" href="/docs/de/promise.html">Promise</a></li></ul></div><div class="navGroup navGroupActive"><h3>JavaScript</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/quickstart-javascript.html">Schnellstart</a></li><li class="navListItem"><a class="navItem" href="/docs/de/interop.html">Interoperabilität</a></li><li class="navListItem"><a class="navItem" href="/docs/de/syntax-cheatsheet.html">Syntax Cheatsheet</a></li><li class="navListItem"><a class="navItem" href="/docs/de/libraries.html">Libraries</a></li><li class="navListItem"><a class="navItem" href="/docs/de/converting-from-js.html">Konvertieren von JS</a></li></ul></div><div class="navGroup navGroupActive"><h3>Nativ</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/native.html">Nativ</a></li><li class="navListItem"><a class="navItem" href="/docs/de/quickstart-ocaml.html">Schnellstart</a></li><li class="navListItem"><a class="navItem" href="/docs/de/convert-from-ocaml.html">Konvertieren von OCaml</a></li></ul></div><div class="navGroup navGroupActive"><h3>Weiteres</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/faq.html">Häufige Fragen</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/docs/de/comparison-to-ocaml.html">Vergleich zu OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/de/newcomer-examples.html">Newcomer-Beispiele</a></li><li class="navListItem"><a class="navItem" href="/docs/de/project-structure.html">Projektstruktur</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/de" target="_blank">Translate</a><h1>Vergleich zu OCaml</h1></header><article><div><span><p>Wenn du von OCaml kommst oder als ein Neueinsteiger ein Tutorial über OCaml liest, ist diese Anleitung für dich! Aber vergiss nicht, dass <a href="https://github.com/reasonml/reason-tools">reason-tools</a> spontan zwischen OCaml- und Reason-Syntax konvertieren können.</p>
<h2><a class="anchor" aria-hidden="true" name="kommentare"></a><a href="#kommentare" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Kommentare</h2>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>(* OCaml (*nest*) *)</code></td><td><code>/* Reason /*nest*/ */</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" name="umbenennung-von-operatoren"></a><a href="#umbenennung-von-operatoren" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Umbenennung von Operatoren</h2>
<p>Reason hat alle Infix-Operatoren von OCaml, aber einige Operatoren werden anders ausgedrückt. In Reason wird strukturelle Gleichheit als <code>==</code> und referenzielle (physikalische) Gleichheit wird als <code>===</code> geschrieben. In Reason, um die entsprechende Ungleichheit zu erhalten, ersetze das erste Zeichen mit einem <code>!</code>-Zeichen. (<code>!=</code> für strukturelle Ungleichheit und <code>!==</code> für referenzielle Ungleichheit).</p>
<table>
<thead>
<tr><th>Gleichheit</th><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td>Strukturell</td><td><code>x = y</code></td><td><code>x == y</code></td></tr>
<tr><td>Referenz</td><td><code>x == y</code></td><td><code>x === y</code></td></tr>
</tbody>
</table>
<table>
<thead>
<tr><th>Ungleichheit</th><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td>Strukturell</td><td><code>x &lt;&gt; y</code></td><td><code>x != y</code></td></tr>
<tr><td>Referenz</td><td><code>x != y</code></td><td><code>x !== y</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" name="lokaler-sichtbarkeitsbereich"></a><a href="#lokaler-sichtbarkeitsbereich" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lokaler Sichtbarkeitsbereich</h2>
<p>Die lexikalische Sichtbarkeit in Reason (<em>lexical scope</em>) ist genau die gleiche wie in OCaml, aber let-Bindungen ähneln auf syntaktische Weise „<em>block scope</em>“, der vielen Entwicklern vertrauter ist. In Reason werden sie mit <code>{}</code>-Klammern erstellt, welche sowohl <code>let</code>-Bindungen und imperative Anweisungen enthalten dürfen, getrennt durch <code>;</code>. Alle Blöcke werden bis zur letzten Zeile ausgewertet und das Semikolon in der letzten Zeile ist optional. <code>{}</code>-Klammern werden nur benötigt wenn du mehr als ein Element zu mit <code>;</code> zu verketten hast.</p>
<table>
  <tr>
    <th>
      <p>
        OCaml
      </p>
    </th>
<pre><code class="hljs">&lt;th&gt;
  &lt;p&gt;
    Reason
  &lt;/p&gt;
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <code>&lt;pre>
let _ =
  let msg = "Hello" in
  print_string msg;
  let msg2 = "Goodbye" in
  print_string msg2&lt;/pre></code>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>{
let msg = &quot;Hello&quot;;
print_string(msg);
let msg2 = &quot;Goodbye&quot;;
print_string(msg2)
};&lt;/pre&gt;</code>
</td></p>
  </tr>
</table>
<p>Reasons <code>{}</code>-Syntax entfernt viele allgemein berichtete Schmerzpunkte in OCamls Syntax:</p>
<ul>
<li>Doppelte Semikolons werden vollständig entfernt.</li>
<li><code>begin</code>/<code>end</code> werden vollständig entfernt.</li>
<li>Berüchtigte imperative Parsing-<a href="https://github.com/ocaml/ocaml/pull/278">Probleme</a> sind verschwunden.</li>
<li>Modulrümpfe und lokaler Sichtbarkeitsbereich wurden vereinheitlicht.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" name="lokaler-bereich-vs-modulrumpf"></a><a href="#lokaler-bereich-vs-modulrumpf" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lokaler Bereich vs. Modulrumpf</h2>
<p>In Reason: alles, was zwischen <code>{}</code> in <a href="#local-scope">lokalen Sichtbarkeitsbereichen</a> und in Modulrümpfen sein kann. Du kannst Code normalerweise zwischen den beiden Kontexten ausschneiden/einfügen. In OCaml sind die Syntaxen für die beiden Kontexte sehr unterschiedlich. Lokaler Sichtbarkeitsbereich erfordert ein abschließendes <code>in</code>, aber Modulrümpfe nicht und einige imperative Anweisungen müssen <code>_</code> oder <code>()</code> zugewiesen werden, oder verwende double <code>;;</code>.</p>
<table>
  <tr>
    <th>
      <p>
        OCaml Modulrumpf
      </p>
    </th>
<pre><code class="hljs">&lt;th&gt;
  &lt;p&gt;
    Reason Modulrumpf
  &lt;/p&gt;
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <code>&lt;pre>
let ten = 10
let () = imperativeFunc ten ten
let () = imperativeFunc 0 0&lt;/pre></code>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let ten = 10;
imperativeFunc(ten, ten);
imperativeFunc(0, 0);&lt;/pre&gt;</code>
</td></p>
  </tr>
  <tr>
    <td>
      <code>&lt;pre>
let ten = 10;;
imperativeFunc ten ten;;
imperativeFunc 0 0;;&lt;/pre></code>
    </td>
<pre><code class="hljs">&lt;td&gt;
  Wie oben
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <th>
      <p>
        OCaml lokaler Bereich
      </p>
    </th>
<pre><code class="hljs">&lt;th&gt;
  &lt;p&gt;
    Reason lokaler Bereich
  &lt;/p&gt;
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <code>&lt;pre>
let ten = 10 in
let _ = imperativeFunc ten ten in
imperativeFunc 0 0&lt;/pre></code>
    </td>
<pre><code class="hljs">&lt;td&gt;
  wie oben
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <code>&lt;pre>
let ten = 10 in begin
  imperativeFunc ten ten;
  imperativeFunc 0 0
end&lt;/pre></code>
    </td>
<pre><code class="hljs">&lt;td&gt;
  wie oben
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <code>&lt;pre>
let ten = 10 in (
  imperativeFunc ten ten;
  imperativeFunc 0 0
)&lt;/pre></code>
    </td>
<pre><code class="hljs">&lt;td&gt;
  wie oben
&lt;/td&gt;
</code></pre>
  </tr>
</table>
<h2><a class="anchor" aria-hidden="true" name="tupel-und-record"></a><a href="#tupel-und-record" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tupel und Record</h2>
<p>In Reason benötigen Tupel immer Klammern.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let tup = 4, 5</code></td><td><code>let tup = (4, 5);</code></td></tr>
<tr><td><code>let tup = ((1: int), (2:int))</code></td><td><code>let tup = (1: int, 2:int);</code></td></tr>
<tr><td><code>fun ((a: int), (b: int)) -&gt; a</code></td><td><code>((a: int, b: int)) =&gt; a;</code></td></tr>
</tbody>
</table>
<p>In Reason ähneln Record-Werte JavaScript mit <code>:</code> anstelle von <code>=</code>.</p>
<table>
  <tr>
    <th>
      <p>
        OCaml
      </p>
    </th>
<pre><code class="hljs">&lt;th&gt;
  &lt;p&gt;
    Reason
  &lt;/p&gt;
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <code>&lt;pre>
let myRec = {x = 0; y = 10}&lt;/pre></code>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let myRec = {x: 0, y: 10};&lt;/pre&gt;</code>
</td></p>
  </tr>
  <tr>
    <td>
      <code>&lt;pre>
let myFuncs = {
  myFun = (fun x -> x + 1);
  your = (fun a b -> a + b);
}&lt;/pre></code>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let myFuncs = {
myFun: (x) =&gt; x + 1,
your: (a, b) =&gt; a + b
};&lt;/pre&gt;</code>
</td></table></p>
<pre><code class="hljs">&lt;h2&gt;
  Listen
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let list = [1; 2; 3]&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let list = [1, 2, 3]&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let list = hd :: tl&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let list = [hd, ...tl];&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h2&gt;
  Typdefinitionen
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml Tupel
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason Tupel
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type tuple = int * int&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type tuple = (int, int);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let tup: tuple = (10, 30)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let tup: tuple = (10, 30);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml Record
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason Record
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type r = {x: int; y: int}&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type r = {x: int, y: int};&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let myRec: r = {x = 0; y = 10}&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let myRec: r = {x: 0, y: 10};&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml Funktion
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason Funktion
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type func = int -&amp;gt; int&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type func = int =&amp;gt; int;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x: func = fun a -&amp;gt; a + 1&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x: func = (a) =&amp;gt; a + 1;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h2&gt;
  Funktionen
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x a b = e&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = (a, b) =&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = fun a b -&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = (a, b) =&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = fun a -&amp;gt; fun b -&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = (a, b) =&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  Match-Funktionen mit einem Argument
&lt;/h3&gt;

&lt;p&gt;
  OCaml hat eine Funktionsdefinition (&lt;code&gt;function |&lt;/code&gt;), die als äquivalent zu &lt;code&gt;function a -&amp;gt; match a with ...&lt;/code&gt; angesehen wird. Reason hat die gleiche aber die Syntax stellt klar heraus, dass sie tatsächlich eine Erweiterung einer Funktion mit einem Argument ist. Der Einzelfall-Match ist eine natürliche Erweiterung des einfachen Lambdas, und Lambda mit mehreren Fällen ist eine natürliche Erweiterung des Einzelfall-Lambdas.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        Form
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      lambda
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>fun pat -&gt; e&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>fun pat =&gt; e&lt;/pre&gt;</code>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      ein Match-Fall
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>function | pat -&gt; e&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>fun | pat =&gt; e&lt;/pre&gt;</code>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      viele Fälle
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>function | pat -&gt; e
| pat2 -&gt; e&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>fun | pat =&gt; e
| pat2 =&gt; e&lt;/pre&gt;</code>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  Argumente annotieren
&lt;/h3&gt;

&lt;p&gt;
  Sowohl in Reason als auch in OCaml werden Argumente mit Typen dadurch annotiert (wie bei allem anderen), dass sie von Klammern umgeben werden nachdem &lt;code&gt;:typeAnnotation&lt;/code&gt; angehängt wurde.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;reason&quot;&gt;(arg: argType) =&amp;gt; returnValue;
</code></pre>
<p></code></pre></p>
<pre><code class="hljs">&lt;pre&gt;&lt;code class=&quot;reason&quot;&gt;(arg: argType) =&amp;gt; (arg2: arg2Type) =&amp;gt; returnValue;
</code></pre>
<p></code></pre></p>
<pre><code class="hljs">&lt;pre&gt;&lt;code class=&quot;reason&quot;&gt;(arg: argType, arg2: arg2Type) =&amp;gt; returnValue;
</code></pre>
<p></code></pre></p>
<pre><code class="hljs">&lt;p&gt;
  Sowohl Reason als auch OCaml erlauben die Annotation des Rückgabetyps mit der Form der let-Bindung, die „besonders viel syntaktischen Zucker“ hat.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;(* OCaml *)
</code></pre>
<p>let myFunc (a:int) (b:int) :int * int = (a, b)
let myFunc (a:int) (b:int) :int list = [1]
let myFunc (a:int) (b:int) :int -&gt; int = fun x -&gt; x + a + b
</code></pre></p>
<pre><code class="hljs">&lt;pre&gt;&lt;code class=&quot;reason&quot;&gt;/* Reason */
</code></pre>
<p>let myFunc = (a: int, b: int) :(int, int) =&gt; (a, b);
let myFunc = (a: int, b: int) :list(int) =&gt; [1];
let myFunc = (a: int, b: int): (int =&gt; int) =&gt; (x) =&gt; x + a + b;
</code></pre></p>
<pre><code class="hljs">&lt;p&gt;
  Da wir &lt;code&gt;=&amp;gt;&lt;/code&gt; für alle Funktionen in Reason verwenden, gibt es einen Fall, in dem wir zusätzliche Klammern um einen Rückgabetyp hinzufügen müssen, der selbst ein Funktionstyp ist.
&lt;/p&gt;

&lt;h3&gt;
  Typparameter
&lt;/h3&gt;

&lt;h4&gt;
  OCaml
&lt;/h4&gt;

&lt;p&gt;
  OCamls Typanwendungen (etwa wie „generics“) werden in umgekehrter Reihenfolge angewendet.
&lt;/p&gt;

&lt;p&gt;
  Mit OCaml führt dies zu einigen unintuitiven Konsequenzen.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let x: int list = [2]
</code></pre>
<p>type listOfListOfInts = int list list</p>
<p>(* Wird geparst als: *)
type listOfListOfInts = (int list) list
</code></pre></p>
<pre><code class="hljs">&lt;p&gt;
  Die Dinge werden sogar noch seltsamer, wenn Typkonstruktoren mehrere Parameter akzeptieren. Mehrere Argumente erfordern Klammern und Kommas, um Typparameter voneinander zu trennen, aber diese Klammern stellen keine Tupel dar. Die Klammer/Komma-Form muss auch angegeben werden, wenn Typinstanzen wie z. B. &lt;code&gt;(int, string)&lt;/code&gt;-Tupel konstruiert werden.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;type ('a, 'b) tuple = 'a * 'b
</code></pre>
<p>type listOfTuplesOfStringAndInt = (string, int) tuple list</p>
<p>(* Was geparst wird als: *)
type listOfTuplesOfStringAndInt = ((string, int) tuple) list</p>
<p>(* Was eine Liste von (Tupel von (string und int)) erlaubt *)
let tuples: listOfTuplesOfStringAndInt = [(&quot;asdf&quot;, 3)]
</code></pre></p>
<pre><code class="hljs">&lt;h4&gt;
  Reason
&lt;/h4&gt;

&lt;p&gt;
  Zusammengefasst vereinheitlicht Reason fast die ganze Syntax in einfachem „Funktionsaufruf“-Stil, was bedeutet, dass Typparameter dem gleichen Komma-separiertem Muster folgen, wie sonst überall in der Syntax zu sehen. Dies führt zu weniger syntaktischen Mustern, die zu lernen sind.
&lt;/p&gt;

&lt;p&gt;
  Zum Beispiel kannst du dir vorstellen, dass &lt;code&gt;list&lt;/code&gt; eine „Funktion“ für Typen ist, die einen Typ akzeptiert und einen neuen Typ zurückgibt.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let x: int list = [2]
type listOfListOfInts = int list list
type ('a, 'b) tup = ('a * 'b)
type pairs = (int, int) tup list
let tuples: pairs = [(2, 3)]&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let x: list(int) = [2];
type listOfListOfInts = list(list(int));
type tup('a, 'b) = ('a, 'b);
type pairs = list(tup(int, int));
let tuples: pairs = [(2, 3)];&lt;/pre&gt;</code>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h2&gt;
  Tupel als Typparameter
&lt;/h2&gt;

&lt;p&gt;
  Weil OCaml Klammern und Kommas verwendet, um mehrere Argumente in Typkonstruktoren zu repräsentieren, ist es verwirrend, wenn eins der Argumente eines Typkonstruktors selbst ein Tupel ist. In OCaml ist es schwierig, sich an den Unterschied zu erinnern zwischen einem Typkonstruktor mit mehreren Argumenten und einem Typkonstruktor mit einem einzelnen Argument, das ein Tupel ist.
&lt;/p&gt;

&lt;p&gt;
  Die folgenden Beispiele zeigen den Unterschied zwischen &lt;em&gt;zwei&lt;/em&gt; Typparametern für &lt;code&gt;pair&lt;/code&gt; und einem &lt;em&gt;einzelnen&lt;/em&gt; Parameter, der ein Tupel ist.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type intPair = (int, int) pair&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type intPair = pair(int, int)&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type pairList = (int * int) list&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type pairList = list((int, int))&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    In Reason sieht die Syntax, die Tupel oder Tupeltypen repräsentiert, immer wie Tupel aus.
  &lt;/li&gt;
  &lt;li&gt;
    In Reason sieht die Syntax, die Records oder Record-Typen repräsentiert, immer wie Records aus.
  &lt;/li&gt;
  &lt;li&gt;
    So ziemlich alles andere verwendet das syntaktische Muster einer Funktionsanwendung (durch Kommas getrennte Argumente).
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;
  Varianten
&lt;/h2&gt;

&lt;h5&gt;
  OCaml
&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    OCaml erwartet bereits, dass Konstruktorargumenttypen in Tupelform angegeben werden. Daher ist es verwirrend, wenn ein einzelner Konstruktor ein einzelnes Argument akzeptiert, das ein Tupeltyp &lt;em&gt;ist&lt;/em&gt;.
  &lt;/li&gt;
  &lt;li&gt;
    Es ist sogar noch verwirrender, dass die Konstruktoren &lt;em&gt;eigentlich&lt;/em&gt; keine Tupel akzeptieren und dennoch die Syntax Tupeln zu ähneln scheint.
  &lt;/li&gt;
  &lt;li&gt;
    Manchmal überschneiden sich die Syntax für die Instanziierung eines Konstruktors mit mehreren Argumenten und die Syntax für die Erzeugung einer Variante mit einem einzelnen Argument, das ein Tupel ist - daher sieht es &lt;em&gt;genauso&lt;/em&gt; aus &lt;em&gt;als wenn&lt;/em&gt; du einen Tupel übergibst, auch wenn du eigentlich keinen Tupel übergibst.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;
  Reason
&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    Variantenkonstruktortypen werden als durch Kommas getrennte Listen erwartet, wobei Klammern verwendet werden, um den Vorrang zu gruppieren (so wie bei &lt;strong&gt;allem&lt;/strong&gt; anderem).
  &lt;/li&gt;
  &lt;li&gt;
    Instanzen der Variante zu konstruieren (wie du wohl erraten hast) folgt dem Funktionsanwendungsstil (durch Kommas getrennte Listen).
  &lt;/li&gt;
  &lt;li&gt;
    Tupel &lt;em&gt;sehen&lt;/em&gt; &lt;strong&gt;immer&lt;/strong&gt; wie Tupel aus und alles, was wie ein Tupel aussieht, &lt;em&gt;ist&lt;/em&gt; ein Tupel.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>type myVariant =
| HasNothing
| HasSingleInt of int
| HasSingleTuple of (int * int)
| HasMultipleInts of int * int
| HasMultipleTuples of (int * int) * (int * int)
&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>type myVariant =
| HasNothing
| HasSingleInt(int)
| HasSingleTuple((int, int))
| HasMultipleInts(int, int)
| HasMultipleTuples((int, int), (int, int));
&lt;/pre&gt;</code>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let a = HasSingleInt 10
let a = HasSingleTuple (10, 10)
let a = HasMultipleInts (10, 10)
let a = HasMultipleTuples ((10, 10), (10, 10))
&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let a = HasSingleInt(10);
let a = HasSingleTuple((10, 10));
let a = HasMultipleInts(10, 10);
let a = HasMultipleTuples((10, 10), (10, 10));
&lt;/pre&gt;</code>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let res x = match x with
| HasNothing -&gt; 0
| HasSingleInt x -&gt; 0
| HasSingleTuple (x, y) -&gt; 0
| HasMultipleInts (x, y) -&gt; 0
| HasMultipleTuples ((x, y), (q, r)) -&gt; 0
&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let res = (x) =&gt;
switch (x) {
| HasNothing =&gt; 0
| HasSingleInt(x) =&gt; 0
| HasSingleTuple((x, y)) =&gt; 0
| HasMultipleInts(x, y) =&gt; 0
| HasMultipleTuples((x, y), (q, r)) =&gt; 0
};
&lt;/pre&gt;</code>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h2&gt;
  Pattern-Matching
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let res = match x with
| A (x, y) -&gt; match y with
| None -&gt; 0
| Some i -&gt; 10
| B (x, y) -&gt; 0&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let res = switch (x) {
| A((x, y)) =&gt; switch (y) {
| None =&gt; 0
| Some(i) =&gt; 10
}
| B((x, y)) =&gt; 0
};
&lt;/pre&gt;</code>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;p&gt;
  Kannst du den Fehler im OCaml-Beispiel erkennen? Dies ist einer der häufigsten Fehler bei OCaml-Programmierern. Das verschachtelte &lt;code&gt;match&lt;/code&gt; &lt;em&gt;muss&lt;/em&gt; von Klammern umgeben werden, ansonsten wird der &lt;code&gt;Some&lt;/code&gt;-Fall so geparst, als würde er zum äußeren &lt;code&gt;match&lt;/code&gt; gehören. Veranschaulicht ist es eigentlich:
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let res = match x with
</code></pre>
<p>| A (x, y) -&gt; match y with
| None -&gt; 0
| Some i -&gt; 10
| B (x, y) -&gt; 0
</code></pre></p>
<pre><code class="hljs">&lt;p&gt;
  Reason verhindert dieses Problem durch die erzwungenen &lt;code&gt;{}&lt;/code&gt; um die &lt;code&gt;switch&lt;/code&gt;-Fälle.
&lt;/p&gt;

&lt;h2&gt;
  Module und Signaturen
&lt;/h2&gt;

&lt;h3&gt;
  Definition
&lt;/h3&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>module type MySig = sig
type t = int
val x: int
end
module MyModule: MySig = struct
type t = int
let x = 10
end
module MyModule = struct
module NestedModule = struct
let msg = &quot;hello&quot;;
end
end
&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>module type MySig = {
type t = int;
let x: int;
};
module MyModule: MySig = {
type t = int;
let x = 10;
};
module MyModule = {
module NestedModule = {
let msg = &quot;hello&quot;;
};
};
&lt;/pre&gt;</code>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  Funktortypen
&lt;/h3&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>module type FType =
functor (A: ASig) -&gt;
functor (B: BSig) -&gt; Result
&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>module type FType =
(A: ASig) =&gt;
(B: BSig) =&gt; Result;
&lt;/pre&gt;</code>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h2&gt;
  Functors
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>module F =
functor (A: ASig) -&gt;
functor (B: BSig) -&gt; struct end&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>module F =
(A: ASig) =&gt;
(B: BSig) =&gt; {};&lt;/pre&gt;</code>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>module F = functor (A: ASig) (B: BSig) -&gt; struct end&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>module F = (A: ASig, B: BSig) =&gt; {};&lt;/pre&gt;</code>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>module F (A: ASig) (B: BSig) = struct end&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>module F = (A: ASig, B: BSig) =&gt; {};&lt;/pre&gt;</code>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>module Res = F(A)(B)&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>module Res = F(A, B);&lt;/pre&gt;</code>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h2&gt;
  Verschiedene Verbesserungen
&lt;/h2&gt;

&lt;p&gt;
  OCaml verlangt keine Klammern um Sequenzen &lt;code&gt;(a;b;c;d)&lt;/code&gt; oder Tupel &lt;code&gt;(x,y)&lt;/code&gt;, was somit dazu führt, dass eine Menge anderer sehr praktischer Syntaxregeln ausgeschlossen werden. Da Reason immer &lt;code&gt;{}&lt;/code&gt; verwendet, um Sequenzen oder let-Bindungen zu umgeben, und Reason immer &lt;code&gt;()&lt;/code&gt; um Tupel herum verlangt, werden viele andere Syntaxkonstrukte intuitiver ausgedrückt, ohne zusätzliche Umfassung mit Klammern.
&lt;/p&gt;

&lt;h3&gt;
  Lambdas als Record-Felder brauchen nicht mehr extra Klammern
&lt;/h3&gt;

&lt;p&gt;
  Dies ist eine willkommene Verbesserung weil die Fehler bei OCaml-Typen, die ein Benutzer sehen würde, sehr verwirrend sind, wenn der Rückgabewert der Funktion ein Tupel mit dem Infix-Komma &lt;code&gt;,&lt;/code&gt; wäre.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let myFuncs = {
myFun = (fun x -&gt; x + 1);
your = (fun a b -&gt; a + b);
}&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let myFuncs = {
myFun: (x) =&gt; x + 1,
your: (a, b) =&gt; a + b
};&lt;/pre&gt;</code>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  Lambdas als Ergebnis in Pattern-Matching brauchen nicht mehr extra Klammern
&lt;/h3&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let x = match prnt with
| None -&gt; fun a -&gt; blah
(* Extra () required ! *)
| Some &quot;_&quot; -&gt; (fun a -&gt; ())
| Some &quot;ml&quot; -&gt; blah
&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let x =
switch (prnt) {
| None =&gt; (a) =&gt; blah
| Some(&quot;_&quot;) =&gt; (a) =&gt; ()
| Some(&quot;ml&quot;) =&gt; blah
};&lt;/pre&gt;</code>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  Lambdas und Typannotationen in Tupeln brauchen nicht mehr extra Klammern
&lt;/h3&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let tuple = ((fun x -&amp;gt; x), 20)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let tuple = ((x) =&amp;gt; x, 20);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let tuple = ((&quot;hi&quot;: string), (20: int))&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let tuple = (&quot;hi&quot;: string, 20: int);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h2&gt;
  Verschiedene Unterschiede
&lt;/h2&gt;

&lt;h3&gt;
  Vorrang von &lt;code&gt;as&lt;/code&gt;
&lt;/h3&gt;

&lt;p&gt;
  Mit Reason hat &lt;code&gt;as&lt;/code&gt; eine höhere Priorität als &lt;code&gt;|&lt;/code&gt;. Dies ermöglicht das Erstellen von &lt;code&gt;as&lt;/code&gt;-Aliasen für ganze Zeilen im Pattern-Matching.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let ppp = match MyThing 20 with
| (MyThing x as ppp)
| (YourThing x as ppp) -&gt; ppp;
&lt;/pre&gt;</code>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;code&gt;&amp;lt;pre&gt;
</code></pre>
<p>let ppp =
switch (MyThing(20)) {
| MyThing(x) as ppp
| YourThing(x) as ppp =&gt; ppp
};
&lt;/pre&gt;</code>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  Änderungen mutierbarer Record-Felder
&lt;/h3&gt;

&lt;p&gt;
  Da Gleichheiten und ihre Negationen in Reason konsistenter gemacht wurden, ist der Operator &lt;code&gt;=&lt;/code&gt; für die Aktualisierung mutierbarer Felder verfügbar.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;myRec.field &amp;lt;- &quot;next&quot;&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;myRec.field = &quot;next&quot;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  Präfix-Operatoren
&lt;/h3&gt;

&lt;p&gt;
  Reasons &lt;code&gt;!&lt;/code&gt; wird für boolean &lt;code&gt;not&lt;/code&gt; verwendet. Dereferenzierung verwendet das postfix &lt;code&gt;^&lt;/code&gt;.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(foo.bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo.bar^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(foo#bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo#bar^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(!foo.bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo^.bar^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(!foo#bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = (foo^)#bar^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(!(foo.bar))&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo.bar^ ^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(!(foo#bar))&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo#bar^ ^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !!(foo.bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = !!foo.bar;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !!(foo#bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = !!foo#bar;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !~(foo.bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = !~foo.bar;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !~(foo#bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = !~foo#bar;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  Maskierung in Kommentaren
&lt;/h3&gt;

&lt;p&gt;
  Da Reason Kommentare im C-Stil verwendet, müssen einige obskure benutzerdefinierte Präfix- / Infix-Operatoren anders geschrieben werden. Die Regeln für Präfix / Infix-Operatoren sind die gleichen wie in der OCaml-Syntax, jedoch mit den folgenden Ausnahmen:
&lt;/p&gt;

&lt;p&gt;
  Wenn ein beliebiges Zeichen außer dem ersten in einem Präfix / Infix-Operator ein Stern oder ein Schrägstrich ist, muss das zuerst mit einem Backslash maskiert werden. Diese werden &lt;em&gt;ohne&lt;/em&gt; den Schrägstrich geparst, wenn es dem AST hinzugefügt wird. Bei der erneuten Ausgabe werden die Schrägstriche zur Maskierung automatisch hinzugefügt.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let (/*) a b = a + b&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let (/\*) a b =&amp;gt; a + b;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = 12 /-* 23 /-* 12&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = 12 /-* 23 /-* 12;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let y = (/*) a b&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let y = a /\* b;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let (!=*) q r = q + r&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let ( !=* ) = (q, r) =&amp;gt; q + r;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let res = q (!=*) r&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let res = q(( !=* ), r);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let (!=/*) q r = q + r&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let ( !=/\* ) = (q, r) =&amp;gt; q + r;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let res = q (!=/*) r&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let res = q(( !=/\* ), r);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  Umbenennung von Operatoren
&lt;/h3&gt;

&lt;p&gt;
  Wenn Reason &lt;code&gt;==&lt;/code&gt; benutzt, um OCamls &lt;code&gt;=&lt;/code&gt; zu repräsentieren, und &lt;code&gt;===&lt;/code&gt; einsetzt, um OCamls &lt;code&gt;==&lt;/code&gt; darzustellen, wie würde dann Reason das &lt;code&gt;===&lt;/code&gt;-Symbol von OCaml repräsentieren (wenn es definiert wäre)? Reason stellt einen Weg bereit! „Maskiere“ das dreifache Gleichheitszeichen!
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      Identifier
    &lt;/th&gt;
    
    &lt;th&gt;
      Bedeutung
    &lt;/th&gt;
    
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&quot;===&quot;&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      Benutzerdefinierter Wert
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;x === y&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;x \=== y&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  REPL
&lt;/h3&gt;

&lt;p&gt;
  In Reasons repl &lt;a href=&quot;extra-goodies.md#repl&quot;&gt;&lt;code&gt;rtop&lt;/code&gt;&lt;/a&gt; (ein angepasstes &lt;a href=&quot;https://github.com/diml/utop&quot;&gt;&lt;code&gt;utop&lt;/code&gt;&lt;/a&gt;), wird jede Eingabe mit einen einzelnen Semikolon &lt;code&gt;;&lt;/code&gt; ausgewertet. OCamls repl verlangt zwei Semikolons &lt;code&gt;;;&lt;/code&gt;.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;;;&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="faq.html">← Häufige Fragen</a><a class="docs-next button" href="newcomer-examples.html">Newcomer-Beispiele →</a></div></div></div></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react'
              });
            </script></body></html>