<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>Interoperabilität · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Interoperabilität · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/index.html"/><meta property="og:description" content="## JavaScript einfach mitten in deinen Reason-Code einstreuen"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/arduino-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/dummy.svg"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/docs/de/quickstart-javascript.html" target="_self">Dokumentation</a></li><li><a href="/de/try.html" target="_self">Try</a></li><li><a href="/api/index.html" target="_self">API</a></li><li><a href="/docs/de/community.html" target="_self">Community</a></li><li><a href="/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg"/>Deutsch</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/ja">日本語</a></li><li><a href="/en">English</a></li><li><a href="/es-ES">Español</a></li><li><a href="/fr">Français</a></li><li><a href="/ko">한국어</a></li><li><a href="/pt-BR">Português (Brasil)</a></li><li><a href="/ru">Русский</a></li><li><a href="/uk">Українська</a></li><li><a href="/zh-CN">中文</a></li><li><a href="/zh-TW">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank">Beim Übersetzen helfen</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>JavaScript</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Einführung</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/what-and-why.html">Was &amp; Wieso</a></li></ul></div><div class="navGroup navGroupActive"><h3>Editor-Setup</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/global-installation.html">Globale Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/de/editor-plugins.html">Editor-Plugins</a></li><li class="navListItem"><a class="navItem" href="/docs/de/extra-goodies.html">Weitere Goodies</a></li></ul></div><div class="navGroup navGroupActive"><h3>Grundlagen der Sprache</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/overview.html">Übersicht</a></li><li class="navListItem"><a class="navItem" href="/docs/de/let-binding.html">Let Binding</a></li><li class="navListItem"><a class="navItem" href="/docs/de/type.html">Typen!</a></li><li class="navListItem"><a class="navItem" href="/docs/de/string-and-char.html">String &amp; Char</a></li><li class="navListItem"><a class="navItem" href="/docs/de/boolean.html">Boolean</a></li><li class="navListItem"><a class="navItem" href="/docs/de/integer-and-float.html">Integer &amp; Float</a></li><li class="navListItem"><a class="navItem" href="/docs/de/tuple.html">Tuple</a></li><li class="navListItem"><a class="navItem" href="/docs/de/record.html">Record</a></li><li class="navListItem"><a class="navItem" href="/docs/de/variant.html">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/de/list-and-array.html">List &amp; Array</a></li><li class="navListItem"><a class="navItem" href="/docs/de/function.html">Funktionen</a></li><li class="navListItem"><a class="navItem" href="/docs/de/if-else.html">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/de/more-on-type.html">Mehr über Typen</a></li><li class="navListItem"><a class="navItem" href="/docs/de/destructuring.html">Destrukturierung</a></li><li class="navListItem"><a class="navItem" href="/docs/de/pattern-matching.html">Pattern-Matching!</a></li><li class="navListItem"><a class="navItem" href="/docs/de/mutation.html">Mutation</a></li><li class="navListItem"><a class="navItem" href="/docs/de/imperative-loops.html">Imperative Schleifen</a></li><li class="navListItem"><a class="navItem" href="/docs/de/jsx.html">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/de/external.html">External</a></li><li class="navListItem"><a class="navItem" href="/docs/de/exception.html">Exception</a></li><li class="navListItem"><a class="navItem" href="/docs/de/object.html">Objekt</a></li><li class="navListItem"><a class="navItem" href="/docs/de/module.html">Module</a></li><li class="navListItem"><a class="navItem" href="/docs/de/promise.html">Promise</a></li></ul></div><div class="navGroup navGroupActive"><h3>JavaScript</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/quickstart-javascript.html">Schnellstart</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/docs/de/interop.html">Interoperabilität</a></li><li class="navListItem"><a class="navItem" href="/docs/de/syntax-cheatsheet.html">Syntax Cheatsheet</a></li><li class="navListItem"><a class="navItem" href="/docs/de/libraries.html">Libraries</a></li><li class="navListItem"><a class="navItem" href="/docs/de/converting-from-js.html">Konvertieren von JS</a></li></ul></div><div class="navGroup navGroupActive"><h3>Nativ</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/native.html">Nativ</a></li><li class="navListItem"><a class="navItem" href="/docs/de/quickstart-ocaml.html">Schnellstart</a></li><li class="navListItem"><a class="navItem" href="/docs/de/convert-from-ocaml.html">Konvertieren von OCaml</a></li></ul></div><div class="navGroup navGroupActive"><h3>Weiteres</h3><ul><li class="navListItem"><a class="navItem" href="/docs/de/faq.html">Häufige Fragen</a></li><li class="navListItem"><a class="navItem" href="/docs/de/comparison-to-ocaml.html">Vergleich zu OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/de/newcomer-examples.html">Newcomer-Beispiele</a></li><li class="navListItem"><a class="navItem" href="/docs/de/project-structure.html">Projektstruktur</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/de" target="_blank">Translate</a><h1>Interoperabilität</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" name="javascript-einfach-mitten-in-deinen-reason-code-einstreuen"></a><a href="#javascript-einfach-mitten-in-deinen-reason-code-einstreuen" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript einfach mitten in deinen Reason-Code einstreuen</h2>
<p>If you're just hacking things together, this can be very nice, but you also have all of the unsafety of JavaScript code</p>
<pre><code class="hljs css reason">Js.<span class="hljs-built_in">log</span>(<span class="hljs-string">"this is reason"</span>);

[%bs.raw {<span class="hljs-string">|</span>
console.<span class="hljs-built_in">log</span>('here is some javascript for you');
<span class="hljs-string">|}];</span>
</code></pre>
<blockquote>
<p><code>{|</code> und <code>|}</code> sind die Trennzeichen in einem mehrzeiligen String in OCaml. Du kannst dort auch einen Tag einfügen, z. B. <code>{something|</code> und dann wird nach einem passenden <code>|something}</code> zum Schließen gesucht.</p>
</blockquote>
<p>Und hier ist das resultierende JavaScript:</p>
<pre><code class="hljs css js"><span class="hljs-comment">// Generated by BUCKLESCRIPT VERSION 1.7.4, PLEASE EDIT WITH CARE</span>
<span class="hljs-meta">'use strict'</span>;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"this is reason"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'here is some javascript for you'</span>);
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="etwas-javascript-einstreuen-und-es-von-reason-zuganglich-machen"></a><a href="#etwas-javascript-einstreuen-und-es-von-reason-zuganglich-machen" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Etwas JavaScript einstreuen und es von Reason zugänglich machen</h2>
<p>Was ist, wenn du einen Wert haben möchtest, der aus deinem Reason-Code verwendet werden kann?</p>
<pre><code class="hljs css reason">Js.<span class="hljs-built_in">log</span>(<span class="hljs-string">"this is reason"</span>);
<span class="hljs-built_in">let</span> x = [%bs.raw {| 'here <span class="hljs-built_in">is</span> a <span class="hljs-built_in">string</span> from javascript' |}];
Js.<span class="hljs-built_in">log</span>(x ++ <span class="hljs-string">" back in reason land"</span>); <span class="hljs-comment">/* ++ ist der Operator für String-Konkatenation */</span>
</code></pre>
<p>Jetzt fragst du dich vielleicht: „Was ist das für eine Magie?? Wie konnte OCaml wissen, dass <code>x</code> ein String war?“ <strong>Konnte es nicht</strong>. Der Typ von <code>x</code> in diesem Code ist ein magischer Typ, der sich mit beliebigem vereinheitlichen wird! Dies ist ziemlich gefährlich und kann kaskadierende Effekte in OCamls Typ-Inferenz-Algorithmus haben.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> y = [%bs.raw {| <span class="hljs-string">'something'</span> |}];
Js.log((<span class="hljs-string">"a string"</span> ++ y, <span class="hljs-number">10</span> + y));
<span class="hljs-comment">/* Gefahr!! OCaml wird dich nicht daran hindern, y als 2 total verschiedene Typen zu verwenden */</span>
</code></pre>
<p>Um dies zu beheben, solltest du <strong>immer</strong> einen konkreten Typ für das Ergebnis von <code>bs.raw</code> angeben.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> x: string = [%bs.raw {| <span class="hljs-string">'well-typed'</span> |}];
Js.log(x ++ <span class="hljs-string">" back in reason land"</span>);
<span class="hljs-comment">/* OCaml wird mit einem Fehler aussteigen, wenn du x als etwas anderes als ein String verwendest */</span>
</code></pre>
<p>Und hier ist die Ausgabe!</p>
<pre><code class="hljs css js"><span class="hljs-comment">// Generated by BUCKLESCRIPT VERSION 1.7.4, PLEASE EDIT WITH CARE</span>
<span class="hljs-meta">'use strict'</span>;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"this is reason"</span>);
<span class="hljs-keyword">var</span> x = ( <span class="hljs-string">'here is a string from javascript'</span> );
<span class="hljs-built_in">console</span>.log(x + <span class="hljs-string">" back in reason land"</span>);
<span class="hljs-keyword">var</span> y = ( <span class="hljs-string">'something'</span> );
<span class="hljs-built_in">console</span>.log(<span class="hljs-comment">/* tuple */</span>[
      <span class="hljs-string">"a string"</span> + y,
      <span class="hljs-number">10</span> + y | <span class="hljs-number">0</span>
    ]);
<span class="hljs-keyword">var</span> x$<span class="hljs-number">1</span> = ( <span class="hljs-string">'well-typed'</span> );
<span class="hljs-built_in">console</span>.log(x$<span class="hljs-number">1</span> + <span class="hljs-string">" back in reason land"</span>);
</code></pre>
<blockquote>
<p>Der Unterschied zwischen den 2 <code>%%</code> aus dem vorherigen Abschnitt und dem 1 <code>%</code> hier ist wichtig! <code>[%%something ...]</code> ist ein OCaml-„Erweiterungspunkt“ der eine Anweisung <em>auf oberster Ebene</em> repräsentiert (sie kann z. B. nicht in einer Funktion oder einem Wert vorkommen). <code>[%something ...]</code> ist ein Erweiterungspunkt, der für einen <em>Ausdruck</em> steht, und dieser kann fast überall eingesetzt werden -- aber stelle sicher, dass das JavaScript, das du einfügst, tatsächlich ein Ausdruck ist! Setze nach diesem z. B. kein Semikolon ein, ansonsten erhältst du einen Syntaxfehler, wenn du versuchst, das resultierende JavaScript auszuführen.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" name="eine-funktion-einfugen-werte-ubergeben"></a><a href="#eine-funktion-einfugen-werte-ubergeben" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Eine Funktion einfügen &amp; Werte übergeben</h2>
<p>Damit dies funktioniert, benötigen wir ein wenig Wissen, wie BuckleScript verschiedene Werte zur Laufzeit repräsentiert.</p>
<ul>
<li><code>strings</code> sind Strings, <code>ints</code> und <code>floats</code> sind einfach nur vom Typ number</li>
<li>ein <a href="/docs/de/list-and-array.html#array">Array</a> ist in OCaml eine mutierbare Liste fester Größe und wird als ein einfaches JavaScript-Array repräsentiert.</li>
<li>eine <a href="/docs/de/list-and-array.html#list">Liste</a> ist eine unveränderliche (<em>immutable</em>) verkettete Liste funktionalen Stils und stellt definitiv die idiomatischere Verwendung in den meisten Fällen dar. Allerdings ist ihre Darstellung komplizierter (versuche es einmal mit <code>Js.log([1,2,3,4])</code>). Deshalb konvertiere ich von &amp; zu <code>Array</code>s wenn ich mit JavaScript spreche, mithilfe von <code>Array.of_list</code> und <code>Array.to_list</code>.</li>
<li>Wenn du tiefer gehen möchtest, dann ist hier einer Liste <a href="https://bucklescript.github.io/docs/en/common-data-types.html#cheat-sheet">in der Dokumentation zu BuckleScript</a></li>
</ul>
<p>Wenn wir das wissen, können wir eine Funktion in JavaScript schreiben, die ohne viel Mühe einfach ein Array akzeptiert und eine Zahl zurückgibt.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> jsCalculate: (<span class="hljs-keyword">array</span>(<span class="hljs-keyword">int</span>), <span class="hljs-keyword">int</span>) =&gt; <span class="hljs-keyword">int</span> = [%bs.raw
  {|
 <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(numbers, scaleFactor)</span> </span>{
   <span class="hljs-keyword">var</span> result = <span class="hljs-number">0</span>;
   numbers.<span class="hljs-keyword">forEach</span>(number =&gt; {
     result += number;
   });
   <span class="hljs-keyword">return</span> result * scaleFactor;
 }
|}
];

<span class="hljs-keyword">let</span> calculate = (numbers, scaleFactor) =&gt; jsCalculate(<span class="hljs-keyword">Array</span>.of_list(numbers), scaleFactor);

Js.log(calculate([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">10</span>)); <span class="hljs-comment">/* -&gt; 60 */</span>
</code></pre>
<p>Natürlich kann diese Funktion, die ich in JavaScript geschrieben habe, ohne großen Aufwand nach Reason portiert werden.</p>
<p><strong>Denke daran,</strong> dass dies eine Notlösung ist, die sehr nützlich zum Lernen ist, damit du schnell beginnen und etwas machen kannst, aber es ist eine gute Übung, wieder durch den Code zu gehen und diesen in feinen, sicheren Reason-Code umzuwandeln.</p>
<p>I've run into more than a few bugs because of raw JavaScript that I added to save time</p>
<h2><a class="anchor" aria-hidden="true" name="sich-eingewohnen-und-diszipliniert-werden"></a><a href="#sich-eingewohnen-und-diszipliniert-werden" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Sich eingewöhnen und diszipliniert werden</h2>
<p>Bisher haben wir <code>bs.raw</code> verwendet, was eine sehr schnelle und lockere Weise ist, und <strong>nicht</strong> für die Produktion geeignet ist.</p>
<p>Aber was, wenn wir tatsächlich eine Funktion aufrufen müssen, die in JavaScript ist? Dies ist für die Interaktion mit dem DOM oder die Verwendung von Node. js-Modulen erforderlich. In BuckleScript kannst du eine <code>external</code>-Deklaration (<a href="https://bucklescript.github.io/docs/en/intro-to-external.html">docs</a>) verwenden.</p>
<p>Sowohl einen Wert als auch eine Funktion zu erhalten, ist ziemlich einfach:</p>
<pre><code class="hljs css reason">[@bs.<span class="hljs-keyword">val</span>] <span class="hljs-keyword">external</span> pi : <span class="hljs-built_in">float</span> = <span class="hljs-string">"Math.PI"</span>;
<span class="hljs-keyword">let</span> tau = pi *. <span class="hljs-number">2.0</span>;
[@bs.<span class="hljs-keyword">val</span>] <span class="hljs-keyword">external</span> alert : <span class="hljs-built_in">string</span> =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"alert"</span>;
alert(<span class="hljs-string">"hello"</span>);
</code></pre>
<p>Aber was ist, wenn wir etwas komplizierteres wollen? So könnten wir <code>getContext</code> auf einem Canvas-DOM-Knoten aufrufen:</p>
<pre><code class="hljs css reason">type canvas<span class="hljs-comment">;</span>

type <span class="hljs-built_in">context</span><span class="hljs-comment">;</span>

<span class="hljs-comment">/* wir lassen diese Typen abstrakt, weil wir 
 * diese nirgends direkt verwenden */</span>
[@<span class="hljs-keyword">bs.send] </span><span class="hljs-keyword">external </span>getContext : (canvas, string) =&gt; <span class="hljs-built_in">context</span> = <span class="hljs-string">""</span><span class="hljs-comment">;</span>

let myCanvas: canvas = [%<span class="hljs-keyword">bs.raw </span>{<span class="hljs-title">| document.getElementById("mycanvas") |</span>}]<span class="hljs-comment">;</span>

let ctx = getContext(myCanvas, <span class="hljs-string">"2d"</span>)<span class="hljs-comment">;</span>
</code></pre>
<p>Entschlüsseln wir, was hier vor sich geht. Wir haben einige abstrakte Typen für den Canvas-DOM-Knoten und das zugehörige RenderingContext-Objekt erstellt.</p>
<p>Denn erstellten wir eine <code>getContext</code>-Funktion, aber anstatt <code>@bs.val</code> haben wir <code>@bs.send</code> verwendet, und wir setzten einen leeren String für den Text bei external ein. <code>@bs.send</code> bedeutet „wir rufen eine Methode für das erste Argument auf“, was in diesem Fall das Canvas-Objekt ist. In Anbetracht des oben Gesagten übersetzt BuckleScript <code>getContext(theFirstArgument, theSecondArgument)</code> in <code>theFirstArgument.getContext (theSecondArgument, ...)</code>.</p>
<p>Der leere String bedeutet „dieser JS-Name ist der gleiche wie der Name, den wir dem external im BuckleScript-Land geben“ – in diesem Fall <code>getContext</code>. Wenn wir ihn anders benennen möchten (wie <code>getRenderingContext</code>), müssten wir den String <code>&quot;getContext&quot;</code> angeben, damit BuckleScript die richtige Funktion aufruft.</p>
<p>Lass uns eine weitere Funktion hinzufügen, nur damit es interessant ist.</p>
<pre><code class="hljs css reason">[@bs.send] <span class="hljs-keyword">external</span> fillRect : (context, <span class="hljs-built_in">float</span>, <span class="hljs-built_in">float</span>, <span class="hljs-built_in">float</span>, <span class="hljs-built_in">float</span>) =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">""</span>;
</code></pre>
<p>Und jetzt können wir etwas malen!</p>
<pre><code class="hljs css reason"><span class="hljs-selector-tag">fillRect</span>(<span class="hljs-selector-tag">ctx</span>, 0<span class="hljs-selector-class">.0</span>, 0<span class="hljs-selector-class">.0</span>, 100<span class="hljs-selector-class">.0</span>, 100<span class="hljs-selector-class">.0</span>);
</code></pre>
<p>Es ist nicht viel, aber das Hinzufügen anderer Canvas-Methoden ist ähnlich, und dann kannst du einige <a href="https://twitter.com/jaredforsyth/status/871062358076030976">wirklich lustige Dinge</a> machen.</p>
<p>Wie sieht nun das kompilierte JavaScript aus?</p>
<pre><code class="hljs css js"><span class="hljs-meta">'use strict'</span>;
<span class="hljs-keyword">var</span> tau = <span class="hljs-built_in">Math</span>.PI * <span class="hljs-number">2.0</span>;
alert(<span class="hljs-string">"hello"</span>);
<span class="hljs-keyword">var</span> myCanvas = ( <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"mycanvas"</span>) );
<span class="hljs-keyword">var</span> ctx = myCanvas.getContext(<span class="hljs-string">"2d"</span>);
ctx.fillRect(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">100.0</span>, <span class="hljs-number">100.0</span>);
</code></pre>
<p>Wow! Hast du bemerkt, wie BuckleScript unsere <code>pi</code>-Variable automatisch im Code aufgelöst hat? Und die Ausgabe sieht fast genauso aus wie von Hand geschrieben.</p>
<h2><a class="anchor" aria-hidden="true" name="vorhandene-javascript-bibliotheken-verwenden"></a><a href="#vorhandene-javascript-bibliotheken-verwenden" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Vorhandene JavaScript-Bibliotheken verwenden</h2>
<p>Wenn Benutzer Wrapper für eine bestimmte JavaScript-Bibliothek schreiben, veröffentlichen sie diese normalerweise in npm. Gehe zu <a href="/docs/de/libraries.html">Bibliotheken</a>, um herauszufinden, wie du diese finden kannst.</p>
<p>Um eine Bibliothek ohne vorhandene Wrapper zu verwenden, musst du das npm-Paket jedoch wie gewöhnlich installieren, z. B. verwende <code>npm install --save &lt;paketname&gt;</code>, und dann schreib einfach deinen Wrapper. Du wirst wahrscheinlich die <a href="https://bucklescript.github.io/docs/en/import-export.html#import"><code>bs.module</code></a>-FFI-Funktion besonders nützlich finden. Je nach Modulformat des JS-Kompilierungsziels gibt es die richtigen <code>import</code>s oder <code>require</code>s aus.</p>
<p>Als Beispiel hier ist der gesamte Quellcode des <a href="https://github.com/reasonml-community/sb-glob"><code>bs.glob</code></a>-Wrappers (konvertiert zu Reason, das Original ist OCaml):</p>
<pre><code class="hljs css reason"><span class="hljs-built_in">type</span> <span class="hljs-built_in">error</span>;

[@bs.<span class="hljs-built_in">module</span>] external glob : <span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">string</span>, (Js.nullable(<span class="hljs-built_in">error</span>), array(<span class="hljs-built_in">string</span>)) =&gt; unit)</span> =&gt;</span> unit = <span class="hljs-string">""</span>;

[@bs.val] [@bs.<span class="hljs-built_in">module</span> <span class="hljs-string">"glob"</span>] external sync : <span class="hljs-built_in">string</span> =&gt; array(<span class="hljs-built_in">string</span>) = <span class="hljs-string">""</span>;
</code></pre>
<p>Und die relevanten Teil aus <code>package.json</code>:</p>
<pre><code class="hljs css json">{
  "name": "bs-glob",
  "version": "0.1.0",
  ...
  "devDependencies": {
    "bs-platform": "^1.9.1"
  },
  "dependencies": {
    "glob": "^7.1.2"
  }
}
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="quickstart-javascript.html">← Schnellstart</a><a class="docs-next button" href="syntax-cheatsheet.html">Syntax Cheatsheet →</a></div></div></div></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react'
              });
            </script></body></html>