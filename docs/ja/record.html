<!DOCTYPE html><html lang="ja"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Record · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Record · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/index.html"/><meta property="og:description" content="レコードは JavaScript のオブジェクトのようなものですが、"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/arduino-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible doc separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/ja"><img class="logo" src="/img/dummy.svg" alt="Reason"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/ja/quickstart-javascript.html" target="_self">Docs</a></li><li class=""><a href="/ja/try.html" target="_self">Try</a></li><li class=""><a href="/api/index.html" target="_self">API</a></li><li class=""><a href="/docs/ja/community.html" target="_self">Community</a></li><li class=""><a href="/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg"/>日本語</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/en">English</a></li><li><a href="/de">Deutsch</a></li><li><a href="/es-ES">Español</a></li><li><a href="/fr">Français</a></li><li><a href="/ko">한국어</a></li><li><a href="/pt-BR">Português (Brasil)</a></li><li><a href="/ru">Русский</a></li><li><a href="/uk">Українська</a></li><li><a href="/zh-CN">中文</a></li><li><a href="/zh-TW">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank" rel="noreferrer noopener">Help Translate</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Language Basics</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Intro</h3><ul><li class="navListItem"><a class="navItem" href="/docs/ja/what-and-why.html">What &amp; Why</a></li></ul></div><div class="navGroup navGroupActive"><h3>Editor Setup</h3><ul><li class="navListItem"><a class="navItem" href="/docs/ja/global-installation.html">Global Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/editor-plugins.html">Editor Plugins</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/extra-goodies.html">Extra Goodies</a></li></ul></div><div class="navGroup navGroupActive"><h3>Language Basics</h3><ul><li class="navListItem"><a class="navItem" href="/docs/ja/overview.html">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/let-binding.html">Let Binding</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/type.html">Type!</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/string-and-char.html">String &amp; Char</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/boolean.html">ブール値</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/integer-and-float.html">Integer &amp; Float</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/tuple.html">Tuple</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/docs/ja/record.html">Record</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/variant.html">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/list-and-array.html">List &amp; Array</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/function.html">関数</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/if-else.html">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/more-on-type.html">More on Type</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/destructuring.html">Destructuring</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/pattern-matching.html">Pattern Matching!</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/mutation.html">Mutation</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/imperative-loops.html">Imperative Loops</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/jsx.html">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/external.html">External</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/exception.html">Exception</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/object.html">Object</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/module.html">Module</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/promise.html">Promise</a></li></ul></div><div class="navGroup navGroupActive"><h3>JavaScript</h3><ul><li class="navListItem"><a class="navItem" href="/docs/ja/quickstart-javascript.html">Quickstart</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/interop.html">Interop</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/syntax-cheatsheet.html">Syntax Cheatsheet</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/libraries.html">Libraries</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/converting-from-js.html">Converting from JS</a></li></ul></div><div class="navGroup navGroupActive"><h3>Native</h3><ul><li class="navListItem"><a class="navItem" href="/docs/ja/native.html">Native</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/quickstart-ocaml.html">Quickstart</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/convert-from-ocaml.html">Converting from OCaml</a></li></ul></div><div class="navGroup navGroupActive"><h3>Extra</h3><ul><li class="navListItem"><a class="navItem" href="/docs/ja/faq.html">Frequently Asked Questions</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/comparison-to-ocaml.html">Comparison to OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/newcomer-examples.html">Newcomer Examples</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/project-structure.html">Project Structure</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/ja" target="_blank" rel="noreferrer noopener">Translate</a><h1>Record</h1></header><article><div><span><p>レコードは JavaScript のオブジェクトのようなものですが、</p>
<ul>
<li>より軽量</li>
<li>デフォルトでイミュータブル</li>
<li>フィールド名と型で固定されている</li>
<li>とても速い</li>
<li>もう少し厳密に型付けされている</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="使い方"></a><a href="#使い方" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使い方</h2>
<p>型（必須）:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">type</span> person = {
  age: int,
  name: string
};
</code></pre>
<p>値（<code>person</code> 型と推論される）</p>
<pre><code class="hljs css reason">let <span class="hljs-keyword">me</span> = {
  age: <span class="hljs-number">5</span>,
  <span class="hljs-built_in">name</span>: <span class="hljs-string">"Big Reason"</span>
};
</code></pre>
<p>アクセス（使い慣れたドット表記）:</p>
<pre><code class="hljs css reason">let <span class="hljs-built_in">name</span> = <span class="hljs-keyword">me</span>.<span class="hljs-built_in">name</span>;
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="レコードは明示的な定義が必要"></a><a href="#レコードは明示的な定義が必要" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>レコードは明示的な定義が必要</h3>
<p>もし、明示的な宣言を事前ににせずに、<code>{age: 5, name: &quot;Baby Reason&quot;}</code> とだけ書いたら、型システムはエラーを返します。 もし型定義が別のファイルにある場合は、どのファイルのものであるかを明示的に指す必要があります。</p>
<pre><code class="hljs css reason"><span class="hljs-comment">/* School.re */</span>

<span class="hljs-keyword">type</span> person = {age: <span class="hljs-keyword">int</span>, name: <span class="hljs-keyword">string</span>};
</code></pre>
<pre><code class="hljs css reason"><span class="hljs-comment">/* example.re */</span>

let <span class="hljs-string">me:</span> School.person = {<span class="hljs-string">age:</span> <span class="hljs-number">20</span>, <span class="hljs-string">name:</span> <span class="hljs-string">"Big Reason"</span>};
<span class="hljs-comment">/* or */</span>
let me = School.{<span class="hljs-string">age:</span> <span class="hljs-number">20</span>, <span class="hljs-string">name:</span> <span class="hljs-string">"Big Reason"</span>};
<span class="hljs-comment">/* or */</span>
let me = {School.<span class="hljs-string">age:</span> <span class="hljs-number">20</span>, <span class="hljs-string">name:</span> <span class="hljs-string">"Big Reason"</span>};
</code></pre>
<p>上の3つのいずれも「このレコードの定義は School というファイルで見つけた」と言いますが、最初の例にある、いつもの型注釈の方法が推奨です。</p>
<h3><a class="anchor" aria-hidden="true" id="イミュータブルな更新"></a><a href="#イミュータブルな更新" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>イミュータブルな更新</h3>
<p>スプレッド演算子（<code>...</code>）で古いレコードから新しいレコードを作ることができます。元のレコードは更新されません。</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> meNextYear = {...<span class="hljs-keyword">me</span>, age: <span class="hljs-keyword">me</span>.age + <span class="hljs-number">1</span>};
</code></pre>
<p>この更新は非常に効率的です！<a href="/try.html">プレイグラウンド</a>でどのようにレコードがコンパイルされるかいくつか試してください。</p>
<p><strong>注意</strong>: スプレッドで新しいフィールドを追加することはできません。レコードの形はその型によって固定されています。</p>
<h3><a class="anchor" aria-hidden="true" id="ミュータブルな更新"></a><a href="#ミュータブルな更新" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ミュータブルな更新</h3>
<p>レコードのフィールドはオプションでミュータブルにすることができます。<code>=</code> 演算子を使ってミュータブルなフィールドを更新することを許可します。</p>
<pre><code class="hljs css reason">type person = {
<span class="hljs-symbol">  name:</span> string,
  mutable age: int
}<span class="hljs-comment">;</span>
let <span class="hljs-keyword">baby </span>= {name: <span class="hljs-string">"Baby Reason"</span>, age: <span class="hljs-number">5</span>}<span class="hljs-comment">;</span>
<span class="hljs-keyword">baby.age </span>= <span class="hljs-keyword">baby.age </span>+ <span class="hljs-number">1</span><span class="hljs-comment">; /* `baby` を変更. ハッピーバースデー! */</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="シンタックスの省略形"></a><a href="#シンタックスの省略形" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>シンタックスの省略形</h2>
<p>冗長性を減らすために、私たちはレコードの型と値に <strong>punning</strong> を提供します。 Punning とは、フィールドの名前がその値/型の名前と一致するときに使用できるシンタックスの省略系を指します。</p>
<pre><code class="hljs css reason"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">horsePower</span></span> = {power: int, metric: <span class="hljs-built_in">bool</span>};

<span class="hljs-keyword">let</span> metric = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">let</span> someHorsePower = {power: <span class="hljs-number">10</span>, metric};
<span class="hljs-comment">/* {power: 10, metric: metric}; という値と同等 */</span>

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">car</span></span> = {name: string, horsePower};
<span class="hljs-comment">/* {name: string, horsePower: horsePower}; という型と同等 */</span>
</code></pre>
<p><strong>単一のフィールドには punning が使えないことに注意してください</strong>！<code>{foo}</code> はあなたが期待するようには動きません。（それは <code>foo</code> という値を返すブロックです。）</p>
<h2><a class="anchor" aria-hidden="true" id="ヒントとコツ"></a><a href="#ヒントとコツ" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ヒントとコツ</h2>
<h3><a class="anchor" aria-hidden="true" id="javascript-との相互運用"></a><a href="#javascript-との相互運用" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript との相互運用</h3>
<p>もし JavaScript を使用しているなら、レコードのシンタックスと操作は使い慣れているはずで、JS オブジェクトをレコードに変換し、逆にレコードを JS オブジェクトに変換して相互運用することに誘惑されるかもしれません。 それは問題なくできますが、<strong>変換のオーバーヘッドのないさらに良い方法</strong>があります！ See <a href="https://bucklescript.github.io/docs/en/object.html#record-mode">here</a></p>
<h3><a class="anchor" aria-hidden="true" id="レコードの型はフィールドの名前で特定される"></a><a href="#レコードの型はフィールドの名前で特定される" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>レコードの型はフィールドの名前で特定される</h3>
<p>With records, you <strong>cannot</strong> say &quot;I'd like this function to take any record type, as long as they have the field <code>age</code>&quot;. The following <em>works</em>, but not as expected:</p>
<pre><code class="hljs css reason">type person = {age: int, name: string};<span class="hljs-built_in">
type </span>monster = {age: int, hasTentacles: bool};

let getAge = (entity) =&gt; entity.age;
</code></pre>
<p>The last line's function will infer that the parameter <code>entity</code> must be of type <code>monster</code>. The following code's last line fails:</p>
<pre><code class="hljs css reason">let kraken = {<span class="hljs-string">age:</span> <span class="hljs-number">9999</span>, <span class="hljs-string">hasTentacles:</span> <span class="hljs-literal">true</span>};
let me = {<span class="hljs-string">age:</span> <span class="hljs-number">5</span>, <span class="hljs-string">name:</span> <span class="hljs-string">"Baby Reason"</span>};

getAge(kraken);
getAge(me);
</code></pre>
<p>The type system will complain that <code>me</code> is a <code>person</code>, and that <code>getAge</code> only works on <code>monster</code>. If you need such capability, use Reason objects, described <a href="/docs/ja/object.html">here</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="設計方針"></a><a href="#設計方針" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>設計方針</h2>
<p>After reading the constraints in the previous sections, and if you're coming from a dynamic language background, you might be wondering why one would bother with record in the first place instead of straight using object, since the former needs explicit typing and doesn't allow different records with the same field name to be passed to the same function, etc.</p>
<ol>
<li>あなたのアプリのほとんどの時間、データの形は実際は固定されていて、もしそうでなくても、潜在的にヴァリアント（次で説明します） + レコードの組み合わせでよりよく表現できるというのが実情です。</li>
<li>レコードはそのフィールドが固定されているので、JS オブジェクトの代わりにインデックスでアクセスする配列としてコンパイルされます（プレイングラウンドで試してください！）。 ネイティブでは、基本的にフィールドへのアクセスが単に1回のフィールド検索 + 1回の実際のアクセスで可能なメモリの領域にコンパイルされます。<strong>2アセンブリ命令</strong>とも言えます。 先人たちがナノ秒で測定していた古き良き日々...</li>
<li>最後に、単一の明示的な型宣言（これを「nominal typing」と呼ぶ）を見つけることによってレコード型が解決されるため、型エラーメッセージは相手方より優れています（タプルの場合のように「構造型」）。 これにより、リファクタリングが容易になります。 レコードタイプのフィールドを変更すると、コンパイラはそれがまだ同じレコードであり、いくつかの場所で不適になっていることを自然に知ることができます。 そうでなければ、構造型の場合、誤りが定義側にあるのか、利用側にあるのかを教えることが難しくなるかもしれません。</li>
</ol>
<p>* And we're not just finding excuses for ourselves! Reason objects do support these features.</p>
<!--TODO: sharable playground for 2 --></span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="tuple.html">← Tuple</a><a class="docs-next button" href="variant.html">Variant! →</a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#使い方">使い方</a><ul class="toc-headings"><li><a href="#レコードは明示的な定義が必要">レコードは明示的な定義が必要</a></li><li><a href="#イミュータブルな更新">イミュータブルな更新</a></li><li><a href="#ミュータブルな更新">ミュータブルな更新</a></li></ul></li><li><a href="#シンタックスの省略形">シンタックスの省略形</a></li><li><a href="#ヒントとコツ">ヒントとコツ</a><ul class="toc-headings"><li><a href="#javascript-との相互運用">JavaScript との相互運用</a></li><li><a href="#レコードの型はフィールドの名前で特定される">レコードの型はフィールドの名前で特定される</a></li></ul></li><li><a href="#設計方針">設計方針</a></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.min.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper, .onPageNav',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react'
              });
            </script></body></html>