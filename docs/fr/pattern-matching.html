<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>Pattern Matching! · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Pattern Matching! · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/index.html"/><meta property="og:description" content="*Assurez-vous d&#x27;avoir lu la section [Variant](/docs/fr/variant.html) tout d’abord*."/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/arduino-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/dummy.svg"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/docs/fr/quickstart-javascript.html" target="_self">Docs</a></li><li><a href="/fr/try.html" target="_self">Éditeur</a></li><li><a href="/api/index.html" target="_self">API</a></li><li><a href="/docs/fr/community.html" target="_self">Communauté</a></li><li><a href="/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg"/>Français</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/ja">日本語</a></li><li><a href="/en">English</a></li><li><a href="/es-ES">Español</a></li><li><a href="/ko">한국어</a></li><li><a href="/pt-BR">Português (Brasil)</a></li><li><a href="/ru">Русский</a></li><li><a href="/uk">Українська</a></li><li><a href="/zh-CN">中文</a></li><li><a href="/zh-TW">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank">Aider à la traduction</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Language Basics</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Intro</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/what-and-why.html">Quoi &amp; Pourquoi</a></li></ul></div><div class="navGroup navGroupActive"><h3>Configuration de l&#x27;éditeur</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/global-installation.html">Installation globale</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/editor-plugins.html">Plugins éditeurs</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/extra-goodies.html">Goodies supplémentaires</a></li></ul></div><div class="navGroup navGroupActive"><h3>Principes de base du langage</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/overview.html">Aperçu</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/let-binding.html">Binding let</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/type.html">Type!</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/string-and-char.html">String &amp; Char</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/boolean.html">Booléen</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/integer-and-float.html">Integer &amp; Float</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/tuple.html">Tuple</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/record.html">Record</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/variant.html">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/list-and-array.html">List &amp; Array</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/function.html">Fonction</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/if-else.html">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/more-on-type.html">Plus sur les types</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/destructuring.html">Destructuring</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/docs/fr/pattern-matching.html">Pattern Matching!</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/mutation.html">Mutations</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/imperative-loops.html">Boucles impératives</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/jsx.html">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/external.html">External</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/exception.html">Exception</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/object.html">Objet</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/module.html">Module</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/promise.html">Promise</a></li></ul></div><div class="navGroup navGroupActive"><h3>JavaScript</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/quickstart-javascript.html">Démarrage rapide</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/interop.html">Interopérabilité</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/syntax-cheatsheet.html">Cheatsheet de la syntaxe</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/libraries.html">Librairies</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/converting-from-js.html">Convertir depuis JavaScript</a></li></ul></div><div class="navGroup navGroupActive"><h3>Natif</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/native.html">Natif</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/quickstart-ocaml.html">Démarrage rapide</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/convert-from-ocaml.html">Convertir depuis OCaml</a></li></ul></div><div class="navGroup navGroupActive"><h3>Extra</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/faq.html">Foire aux Questions</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/comparison-to-ocaml.html">Comparaison avec OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/newcomer-examples.html">Exemples néophytes</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/project-structure.html">Structure de projet</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/fr" target="_blank">Translate</a><h1>Pattern Matching!</h1></header><article><div><span><p><em>Assurez-vous d'avoir lu la section <a href="/docs/fr/variant.html">Variant</a> tout d’abord</em>.</p>
<p><strong>Nous y sommes enfin</strong> ! Le pattern matching est l’une des <em>meilleures fonctionnalités du langage</em>. Il ressemble au destructuring, mais avec encore plus d'aide de la part du système de types.</p>
<h2><a class="anchor" aria-hidden="true" name="utilisation"></a><a href="#utilisation" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Utilisation</h2>
<p>Considérons une variant :</p>
<pre><code class="hljs css reason">type payload =
  <span class="hljs-string">| BadResult(int)</span>
  <span class="hljs-string">| GoodResult(string)</span>
  <span class="hljs-string">| NoResult;</span>
</code></pre>
<p>Si on l'utilise avec l'expresion <code>switch</code>, on peut &quot;destructurer&quot; notre variant de la sorte :</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> data = GoodResult(<span class="hljs-string">"Product shipped!"</span>);

<span class="hljs-keyword">let</span> message =
  switch (data) {
  | <span class="hljs-type">GoodResult</span>(theMessage) =&gt; <span class="hljs-string">"Success! "</span> ++ theMessage
  | <span class="hljs-type">BadResult</span>(errorCode) =&gt; <span class="hljs-string">"Something's wrong. The error code is: "</span> ++ string_of_int(errorCode)
  };
</code></pre>
<p>Notez comment nous avons destructuré <code>data</code> tout en gérant chacun des différents cas. Cependant le ``switch ci-dessus vous générera un warning du compilateur :</p>
<pre><code class="hljs">Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
NoResult
</code></pre>
<p>N'est-ce pas merveilleux ? Tout en correspondant à la forme de nos données, le système de types nous a mis en garde contre un cas non traité. Cet aspect <strong>conditionnel</strong> est ce qui en fait du pattern matching plutôt que de la simple déstructuration. La plupart des structures de données avec un aspect <strong>«si ceci alors cela»</strong> fonctionnent aussi :</p>
<pre><code class="hljs css reason">switch (myList) {
| <span class="hljs-type">[] =&gt; print_endline</span>(<span class="hljs-string">"Empty list"</span>)
| <span class="hljs-type">[a</span>, ...theRest] =&gt; print_endline(<span class="hljs-string">"list with the head value "</span> ++ a)
};

switch (myArray) {
| <span class="hljs-type">[|1</span>, <span class="hljs-number">2</span>|<span class="hljs-type">] =&gt; print_endline</span>(<span class="hljs-string">"This is an array with item 1 and 2"</span>)
| <span class="hljs-type">[||] =&gt; print_endline</span>(<span class="hljs-string">"This array has no element"</span>)
| <span class="hljs-type">_</span> =&gt; print_endline(<span class="hljs-string">"This is an array"</span>)
};
</code></pre>
<p>Le cas <code>_</code> est un cas spécial qui permet à toutes les conditions inégalées d'accéder à cette branche.</p>
<p>Vous pouvez switch sur des strings, des ints et bien d'autres. Vous pouvez même avoir plusieurs patterns vallant le même résultat !</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> reply =
  <span class="hljs-keyword">switch</span> (message) {
  | <span class="hljs-string">"Reason's pretty cool"</span> =&gt; <span class="hljs-string">"Yep"</span>
  | <span class="hljs-string">"good night"</span> =&gt; <span class="hljs-string">"See ya!"</span>
  | <span class="hljs-string">"hello"</span> | <span class="hljs-string">"hi"</span> | <span class="hljs-string">"heya"</span> | <span class="hljs-string">"hey"</span> =&gt; <span class="hljs-string">"hello to you too!"</span>
  | _ =&gt; <span class="hljs-string">"Nice to meet you!"</span>
  };
</code></pre>
<p>Combiné avec d'autres structures de données, le pattern matching peut produire un code concis, vérifié par le compilateur et performant :</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> message =
  switch (data) {
  | <span class="hljs-type">GoodResult</span>(theMessage) =&gt; <span class="hljs-string">"Success! "</span> ++ theMessage
  | <span class="hljs-type">BadResult</span>(<span class="hljs-number">0</span> | <span class="hljs-type">1</span> | <span class="hljs-type">5</span>) =&gt; <span class="hljs-string">"Something's wrong. It's a server side problem."</span>
  | <span class="hljs-type">BadResult</span>(errorCode) =&gt; <span class="hljs-string">"Unknown error occurred. Code: "</span> ++ string_of_int(errorCode)
  | <span class="hljs-type">NoResult</span> =&gt; <span class="hljs-string">"Things look fine"</span>
  };
</code></pre>
<p><strong>Note</strong> : vous ne pouvez passer que des literals (c'est-à-dire des valeurs concrètes) en tant que pattern, pas de noms de let-bindings ou autres. Ce qui suit ne fonctionne pas comme espéré :</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> myMessage = <span class="hljs-string">"Hello"</span>;
<span class="hljs-keyword">switch</span> (greeting) {
| <span class="hljs-function"><span class="hljs-params">myMessage</span> =&gt;</span> print_endline(<span class="hljs-string">"Hi to you"</span>)
};
</code></pre>
<p>Au lieu de cela, il supposera que vous êtes entrain de match n'importe quelle string et que vous liez ceci au nom ``myMessage dans cette branche du <code>switch</code>, ce qui n'est pas ce que vous vouliez.</p>
<h3><a class="anchor" aria-hidden="true" name="clauses-when"></a><a href="#clauses-when" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Clauses when</h3>
<p>Lorsque vous avez vraiment besoin d'utiliser une logique arbitraire avec un pattern match autrement propre, vous pouvez glisser certaines clauses <code>when</code>, qui sont grosso modo un sucre syntaxique pour <code>if</code> :</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> message =
  switch (data) {
  | <span class="hljs-type">GoodResult</span>(theMessage) =&gt; ...
  | <span class="hljs-type">BadResult</span>(errorCode) when isServerError(errorCode) =&gt; ...
  | <span class="hljs-type">BadResult</span>(errorCode) =&gt; ... /* sinon */
  | <span class="hljs-type">NoResult</span> =&gt; ...
  };
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="match-sur-les-exceptions"></a><a href="#match-sur-les-exceptions" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Match sur les exceptions</h3>
<p>Si la fonction lève une exception (couvert plus tard), vous pouvez également y appliquer un match, en plus des valeurs retournées normalement par la fonction.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">switch</span> (<span class="hljs-keyword">List</span>.find((i) =&gt; i === theItem, myItems)) {
| item =&gt; print_endline(item)
| <span class="hljs-keyword">exception</span> Not_found =&gt; print_endline(<span class="hljs-string">"No such item found!"</span>)
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="patterns-imbriques"></a><a href="#patterns-imbriques" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Patterns imbriqués</h3>
<p>Les <code>|</code> foncitonnent comme espéré :</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">switch</span> (student) {
| {<span class="hljs-string">name:</span> <span class="hljs-string">"Jane"</span> | <span class="hljs-string">"Joe"</span>} =&gt; ...
| {<span class="hljs-string">name:</span> <span class="hljs-string">"Bob"</span>, <span class="hljs-string">Job:</span> Progammer({<span class="hljs-string">fullTime:</span> Yes | Maybe})} =&gt; ...
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="patterns-everywhere"></a><a href="#patterns-everywhere" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Patterns Everywhere</h3>
<p>Vous pouvez placer un pattern partout où vous placeriez une &quot;déclaration de variable&quot; normale:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> (<span class="hljs-keyword">Left</span> v | <span class="hljs-type">Right</span> v) = i;
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="conseils-astuces"></a><a href="#conseils-astuces" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conseils &amp; astuces</h2>
<p><strong>Simplifiez votre pattern-match chaque fois que vous le pouvez</strong>. Ça vous permet de supprimer bien des bugs. Exemple ci-dessous.</p>
<p>Ne pas trop abuser du cas par défaut <code>_</code>. Cela empêche le compilateur de vous dire que vous avez oublié de couvrir un cas (vérification exhaustive), ce qui serait particulièrement utile après un refactoring où vous ajoutez un nouveau cas à une variant. Essayez seulement d'utiliser <code>_</code> en dernier recours après avoir tenté d'infinies possibilités, par ex. strings, ints, etc.</p>
<p>Voici une série d'exemples, du pire au meilleur :</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> <span class="hljs-attr">optionBoolToJsBoolean</span> = (opt) =&gt;
  <span class="hljs-keyword">if</span> (<span class="hljs-attr">opt</span> == None) {
    Js.false_
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-attr">opt</span> == Some(<span class="hljs-literal">true</span>)) {
      Js.true_
    } <span class="hljs-keyword">else</span> {
      Js.false_
    }
  };
</code></pre>
<p>OK : ceci n'est que pure folie =). Passons le tout au pattern matching :</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> optionBoolToJsBoolean = (opt) =&gt;
  switch (opt) {
  | <span class="hljs-type">None</span> =&gt; Js.false_
  | <span class="hljs-type">Some</span>(a) =&gt; a ? Js.true_ : Js.false_
  };
</code></pre>
<p>Un peu mieux, mais encore imbriqué. Le pattern matching vous permet par ailleurs de faire ceci :</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> optionBoolToJsBoolean = (opt) =&gt;
  switch (opt) {
  | <span class="hljs-type">None</span> =&gt; Js.false_
  | <span class="hljs-type">Some</span>(true) =&gt; Js.true_
  | <span class="hljs-type">Some</span>(false) =&gt; Js.false_
  };
</code></pre>
<p>Beaucoup plus linéaire ! Maintenant, vous pourriez être tenté(e) de faire :</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> optionBoolToJsBoolean = <span class="hljs-function">(<span class="hljs-params">opt</span>) =&gt;</span>
  <span class="hljs-keyword">switch</span> (opt) {
  | Some(<span class="hljs-literal">true</span>) =&gt; Js.true_
  | <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> Js.false_
  };
</code></pre>
<p>Ce qui est beaucoup plus concis, mais tue le contrôle d'exhaustivité mentionné ci-dessus. Ceci est la meilleure option :</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> optionBoolToJsBoolean = <span class="hljs-function">(<span class="hljs-params">opt</span>) =&gt;</span>
  <span class="hljs-keyword">switch</span> (opt) {
  | Some(<span class="hljs-literal">true</span>) =&gt; Js.true_
  | Some(<span class="hljs-literal">false</span>)
  | <span class="hljs-function"><span class="hljs-params">None</span> =&gt;</span> Js.false_
  };
</code></pre>
<p>Assez difficile de faire une erreur dans ce code à ce stade ! Chaque fois que vous souhaitez utiliser un if-else avec de nombreuses branches, préférez plutôt le pattern matching. C'est plus concis et <a href="/docs/fr/variant.html#design-decisions">performant</a> aussi.</p>
<p>Voyez un autre exemple avec switch + tuple <a href="/docs/fr/tuple.html#tips-tricks">ici</a>.</p>
<h2><a class="anchor" aria-hidden="true" name="decisions-de-conception"></a><a href="#decisions-de-conception" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Décisions de conception</h2>
<p>Le très célèbre <a href="https://en.wikipedia.org/wiki/Fizz_buzz#Programming_interviews">problème fizz buzz</a> émerveille étrangement certaines personnes. En partie grâce à sa capacité à paralyser le programmeur qui espère simplifier/unifier les quelques branches de l'état à la recherche de l'élégance là où il n'y en a pas. Espérons que vous puissiez constater qu'habituellement, la concision visuelle du pattern matching <a href="/try.html?reason=PQKgBAQghgzgpgEzAewHZgBYBcsAcYBcwwATsvDlAMbIJwB0yJA5sAO4CWA1h8AGIcAXoIgBXYQGIA8gGEoAWwA2YEMABQiuFjAAzIYIBG4wWAC8YABQcAlGYB8asGBicsVDJY5h5tMAGYAGjAvHyQAVlsAb0cwAB9LAAYghNtTOzAAIgFhMWEMmPiLJLAAfVT0rP18p0KS5PLM3MFquNL7ZywSDlRmEuQdEu6sK2sYgF8AbjU1HSZPYPQARjAsZDBFhJSwaKcAKRh6RWRmCz1hI2ER0cmgA">nous permet de surmonter la paralysie des prises de décision</a> tout en conservant tous les avantages (et plus, comme vous l'avez vu) d'un tas de <code>if-else</code>s brute-forcés. Il n'y a vraiment rien de mal à énumérer explicitement toutes les possibilités. Le pattern matching correspond à <strong>l'analyse de cas</strong> en mathématiques, une technique de résolution de problèmes valable qui s'avère extrêmement pratique.</p>
<p>Utiliser un <code>switch</code> Reason pour la première fois peut vous faire vous sentir comme s'il vous avait manqué toutes ces années. Attention, cela pourrait ruiner d'autres langages à vos yeux =).</p>
<p>Si vous avez essayé de refactorer une grande logique if-else bien imbriquée, vous pouvez vous rendre compte qu'il est très difficile d'obtenir la bonne logique. D'autre part, le couple pattern matching + tuple correspond conceptuellement à un tableau 2D, où chaque cellule peut être remplie de manière indépendante. Cela garantit que chaque fois que vous devez ajouter un cas au <code>switch</code>, vous pouvez cibler cette cellule et seulement cette cellule du tableau, sans en déranger d'autres.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">type</span> animal = Dog | Cat | Bird;
<span class="hljs-keyword">let</span> result = <span class="hljs-keyword">switch</span> (isBig, myAnimal) {
| <span class="hljs-function">(<span class="hljs-params"><span class="hljs-literal">true</span>, Dog</span>) =&gt;</span> <span class="hljs-number">1</span>
| <span class="hljs-function">(<span class="hljs-params"><span class="hljs-literal">true</span>, Cat</span>) =&gt;</span> <span class="hljs-number">2</span>
| <span class="hljs-function">(<span class="hljs-params"><span class="hljs-literal">true</span>, Bird</span>) =&gt;</span> <span class="hljs-number">3</span>
| <span class="hljs-function">(<span class="hljs-params"><span class="hljs-literal">false</span>, Dog | Cat</span>) =&gt;</span> <span class="hljs-number">4</span>
| <span class="hljs-function">(<span class="hljs-params"><span class="hljs-literal">false</span>, Bird</span>) =&gt;</span> <span class="hljs-number">5</span>
};
</code></pre>
<table>
<thead>
<tr><th>isBig \ myAnimal</th><th>Dog</th><th>Cat</th><th>Bird</th></tr>
</thead>
<tbody>
<tr><td>true</td><td>1</td><td>2</td><td>3</td></tr>
<tr><td>false</td><td>4</td><td>4</td><td>5</td></tr>
</tbody>
</table>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="destructuring.html">← Destructuring</a><a class="docs-next button" href="mutation.html">Mutations →</a></div></div></div></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react'
              });
            </script></body></html>