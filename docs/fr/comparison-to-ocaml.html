<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>Comparaison avec OCaml · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Comparaison avec OCaml · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/index.html"/><meta property="og:description" content="Si vous venez d&#x27;OCaml ou si vous êtes un néophyte lisant un tutoriel écrit sur OCaml, ce guide est pour vous ! Mais n&#x27;oubliez pas que [reason-tools](https://github.com/reasonml/reason-tools) peut convertir la syntaxe OCaml et Reason à la volée."/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/arduino-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/dummy.svg"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/docs/fr/quickstart-javascript.html" target="_self">Docs</a></li><li><a href="/fr/try.html" target="_self">Éditeur</a></li><li><a href="/api/index.html" target="_self">API</a></li><li><a href="/docs/fr/community.html" target="_self">Communauté</a></li><li><a href="/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg"/>Français</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/ja">日本語</a></li><li><a href="/en">English</a></li><li><a href="/es-ES">Español</a></li><li><a href="/ko">한국어</a></li><li><a href="/pt-BR">Português (Brasil)</a></li><li><a href="/ru">Русский</a></li><li><a href="/uk">Українська</a></li><li><a href="/zh-CN">中文</a></li><li><a href="/zh-TW">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank">Aider à la traduction</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Extra</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Intro</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/what-and-why.html">Quoi &amp; Pourquoi</a></li></ul></div><div class="navGroup navGroupActive"><h3>Configuration de l&#x27;éditeur</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/global-installation.html">Installation globale</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/editor-plugins.html">Plugins éditeurs</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/extra-goodies.html">Goodies supplémentaires</a></li></ul></div><div class="navGroup navGroupActive"><h3>Principes de base du langage</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/overview.html">Aperçu</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/let-binding.html">Binding let</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/type.html">Type!</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/string-and-char.html">String &amp; Char</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/boolean.html">Booléen</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/integer-and-float.html">Integer &amp; Float</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/tuple.html">Tuple</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/record.html">Record</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/variant.html">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/list-and-array.html">List &amp; Array</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/function.html">Fonction</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/if-else.html">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/more-on-type.html">Plus sur les types</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/destructuring.html">Destructuring</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/pattern-matching.html">Pattern Matching!</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/mutation.html">Mutations</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/imperative-loops.html">Boucles impératives</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/jsx.html">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/external.html">External</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/exception.html">Exception</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/object.html">Objet</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/module.html">Module</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/promise.html">Promise</a></li></ul></div><div class="navGroup navGroupActive"><h3>JavaScript</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/quickstart-javascript.html">Démarrage rapide</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/interop.html">Interopérabilité</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/syntax-cheatsheet.html">Cheatsheet de la syntaxe</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/libraries.html">Librairies</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/converting-from-js.html">Convertir depuis JavaScript</a></li></ul></div><div class="navGroup navGroupActive"><h3>Natif</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/native.html">Natif</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/quickstart-ocaml.html">Démarrage rapide</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/convert-from-ocaml.html">Convertir depuis OCaml</a></li></ul></div><div class="navGroup navGroupActive"><h3>Extra</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/faq.html">Foire aux Questions</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/docs/fr/comparison-to-ocaml.html">Comparaison avec OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/newcomer-examples.html">Exemples néophytes</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/project-structure.html">Structure de projet</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/fr" target="_blank">Translate</a><h1>Comparaison avec OCaml</h1></header><article><div><span><p>Si vous venez d'OCaml ou si vous êtes un néophyte lisant un tutoriel écrit sur OCaml, ce guide est pour vous ! Mais n'oubliez pas que <a href="https://github.com/reasonml/reason-tools">reason-tools</a> peut convertir la syntaxe OCaml et Reason à la volée.</p>
<h2><a class="anchor" aria-hidden="true" name="commentaires"></a><a href="#commentaires" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Commentaires</h2>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>(* OCaml (*nest*) *)</code></td><td><code>/* Reason /*nest*/ */</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" name="renommage-d-operateur"></a><a href="#renommage-d-operateur" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Renommage d'opérateur</h2>
<p>Raison supporte tous les opérateurs infixes d'OCaml, mais quelques opérateurs sont exprimés différemment. Dans Reason, l'égalité structurelle est exprimée avec <code>==</code>, et l'égalité de référence (physique) est exprimée avec <code>===</code>. En Reason, pour obtenir l'inégalité correspondante, il suffit d'échanger le premier caractère avec un caractère <code>!</code> (<code>!=</code> pour l'inégalité structurelle, et <code>!==</code> pour l'inégalité de référence).</p>
<table>
<thead>
<tr><th>Égalité</th><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td>Structurelle</td><td><code>x = y</code></td><td><code>x == y</code></td></tr>
<tr><td>Référence</td><td><code>x == y</code></td><td><code>x === y</code></td></tr>
</tbody>
</table>
<table>
<thead>
<tr><th>Inégalité</th><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td>Structurelle</td><td><code>x &lt;&gt; y</code></td><td><code>x != y</code></td></tr>
<tr><td>Référence</td><td><code>x != y</code></td><td><code>x !== y</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" name="scope-local"></a><a href="#scope-local" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scope local</h2>
<p>Le scoping lexical de Reason est exactement le même que celui d'OCaml, mais les bindings let ressemblent syntaxiquement au &quot;block scope&quot; qui est plus familier à de nombreux développeurs. En Reason, ils sont créés avec des accolades <code>{}</code>, qui peuvent contenir à la fois des bindings <code>let</code> et des commandes impératives, séparées par <code>;</code>. Tous les blocs évaluent à la dernière ligne, où le point-virgule est facultatif. Les accolades <code>{}</code> ne sont nécessaires que si vous avez plus d'un élément à chaîner via <code>;</code>.</p>
<table>
  <tr>
    <th>
      <p>
        OCaml
      </p>
    </th>
<pre><code class="hljs">&lt;th&gt;
  &lt;p&gt;
    Reason
  &lt;/p&gt;
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre>
let _ =
  let msg = "Hello" in
  print_string msg;
  let msg2 = "Goodbye" in
  print_string msg2</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;
</code></pre>
<p>{
let msg = &quot;Hello&quot;;
print_string(msg);
let msg2 = &quot;Goodbye&quot;;
print_string(msg2)
};</pre>
</td></p>
  </tr>
</table>
<p>La syntaxe <code>{}</code> en Reason supprime plusieurs points de friction communément signalés dans la syntaxe d'OCaml :</p>
<ul>
<li>Les doubles point-virgules sont complètement retirés.</li>
<li><code>begin</code>/<code>end</code> est complètement retiré.</li>
<li>Les fameux <a href="https://github.com/ocaml/ocaml/pull/278">problèmes</a> de parsing impératif ont disparu.</li>
<li>Le corps et le scope local des modules sont unifiés.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" name="scope-local-vs-corps-de-module"></a><a href="#scope-local-vs-corps-de-module" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scope local vs Corps de module</h2>
<p>En Reason, tout ce qui peut être écrit entre les <code>{}</code> peut être dans le <a href="#local-scope">scope local</a> ou les corps de module. Vous pouvez même généralement copier/coller votre code entre ces deux contextes. En OCaml, les syntaxes pour les deux contextes sont très différentes. Le scope local requiert un trailing <code>in</code>, mais pas les corps de module. Par ailleurs, certaines déclarations impératives doivent être assignées à <code>_</code> ou <code>()</code>, voir utiliser un double <code>;;</code>.</p>
<table>
  <tr>
    <th>
      <p>
        Corps de module OCaml
      </p>
    </th>
<pre><code class="hljs">&lt;th&gt;
  &lt;p&gt;
    Corps de module Reason
  &lt;/p&gt;
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre>
let ten = 10
let () = imperativeFunc ten ten
let () = imperativeFunc 0 0</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;
</code></pre>
<p>let ten = 10;
imperativeFunc(ten, ten);
imperativeFunc(0, 0);</pre>
</td></p>
  </tr>
  <tr>
    <td>
      <pre>
let ten = 10;;
imperativeFunc ten ten;;
imperativeFunc 0 0;;</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  Pareil qu'au dessus
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <th>
      <p>
        Scope local OCaml
      </p>
    </th>
<pre><code class="hljs">&lt;th&gt;
  &lt;p&gt;
    Scope local Reason
  &lt;/p&gt;
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre>
let ten = 10 in
let _ = imperativeFunc ten ten in
imperativeFunc 0 0</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  Pareil qu'au dessus
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre>
let ten = 10 in begin
  imperativeFunc ten ten;
  imperativeFunc 0 0
end</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  Pareil qu'au dessus
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre>
let ten = 10 in (
  imperativeFunc ten ten;
  imperativeFunc 0 0
)</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  Pareil qu'au dessus
&lt;/td&gt;
</code></pre>
  </tr>
</table>
<h2><a class="anchor" aria-hidden="true" name="tuple-et-record"></a><a href="#tuple-et-record" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tuple et Record</h2>
<p>En Reason, les tuples s'écrivent toujours avec des parenthèses.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let tup = 4, 5</code></td><td><code>let tup = (4, 5);</code></td></tr>
<tr><td><code>let tup = ((1: int), (2:int))</code></td><td><code>let tup = (1: int, 2:int);</code></td></tr>
<tr><td><code>fun ((a: int), (b: int)) -&gt; a</code></td><td><code>((a: int, b: int)) =&gt; a;</code></td></tr>
</tbody>
</table>
<p>In Reason, record values resemble JavaScript, using <code>:</code> instead of <code>=</code>.</p>
<table>
  <tr>
    <th>
      <p>
        OCaml
      </p>
    </th>
<pre><code class="hljs">&lt;th&gt;
  &lt;p&gt;
    Reason
  &lt;/p&gt;
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre>
let myRec = {x = 0; y = 10}</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;
</code></pre>
<p>let myRec = {x: 0, y: 10};</pre>
</td></p>
  </tr>
  <tr>
    <td>
      <pre>
let myFuncs = {
  myFun = (fun x -> x + 1);
  your = (fun a b -> a + b);
}</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;
</code></pre>
<p>let myFuncs = {
myFun: (x) =&gt; x + 1,
your: (a, b) =&gt; a + b
};</pre>
</td></table></p>
<pre><code class="hljs">&lt;h2&gt;
  Listes
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let list = [1; 2; 3]&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let list = [1; 2; 3]&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let list = hd :: tl&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let list = [hd, ...tl];&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h2&gt;
  Définitions de type
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      Tuple OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Tuple Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type tuple = int * int&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type tuple = (int, int);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let tup: tuple = (10, 30)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let tup: tuple = (10, 30);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      Record OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Record Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type r = {x: int; y: int}&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type r = {x: int, y: int};&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let myRec: r = {x = 0; y = 10}&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let myRec: r = {x: 0, y: 10};&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      Fonction OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Fonction Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type func = int -&amp;gt; int&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type func = int =&amp;gt; int;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x: func = fun a -&amp;gt; a + 1&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x: func = (a) =&amp;gt; a + 1;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h2&gt;
  Fonctions
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x a b = e&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = (a, b) =&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = fun a b -&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = (a, b) =&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = fun a -&amp;gt; fun b -&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = (a, b) =&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  Fonctions match à un argument
&lt;/h3&gt;

&lt;p&gt;
  OCaml a une définition de fonction (&lt;code&gt;function |&lt;/code&gt;) qu'on considère équivalente à &lt;code&gt;function a -&amp;gt; match a with ...&lt;/code&gt;. Reason possède la même, mais la syntaxe ici montre plus clairement qu'il s'agit d'une extension de fonction à un seul arguement. Le match à un seul cas est une extension naturelle du lambda simple, et le lambda à plusieurs cas est une extension naturelle du lambda simple.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        Forme
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      Lambda
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>fun pat -&gt; e</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>fun pat =&gt; e</pre>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      Cas à un match
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>function | pat -&gt; e</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>fun | pat =&gt; e</pre>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      Plusieurs cas
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>function | pat -&gt; e
| pat2 -&gt; e</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>fun | pat =&gt; e
| pat2 =&gt; e</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  Annotations d'argument
&lt;/h3&gt;

&lt;p&gt;
  En Reason et en OCaml, les arguments sont annotés avec des types (comme pour tout le reste), les enveloppant entre parenthèses après l'ajout de &lt;code&gt;:typeAnnotation&lt;/code&gt;.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;reason&quot;&gt;(arg: argType) =&amp;gt; returnValue;
</code></pre>
<p></code></pre></p>
<pre><code class="hljs">&lt;pre&gt;&lt;code class=&quot;reason&quot;&gt;(arg: argType) =&amp;gt; (arg2: arg2Type) =&amp;gt; returnValue;
</code></pre>
<p></code></pre></p>
<pre><code class="hljs">&lt;pre&gt;&lt;code class=&quot;reason&quot;&gt;(arg: argType, arg2: arg2Type) =&amp;gt; returnValue;
</code></pre>
<p></code></pre></p>
<pre><code class="hljs">&lt;p&gt;
  Reason ainsi qu'OCaml permettent d'annoter le type retourné, lorsqu'on utilise la forme du &quot;super binding let sucré&quot;.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;(* OCaml *)
</code></pre>
<p>let myFunc (a:int) (b:int) :int * int = (a, b)
let myFunc (a:int) (b:int) :int list = [1]
let myFunc (a:int) (b:int) :int -&gt; int = fun x -&gt; x + a + b
</code></pre></p>
<pre><code class="hljs">&lt;pre&gt;&lt;code class=&quot;reason&quot;&gt;/* Reason */
</code></pre>
<p>let myFunc = (a: int, b: int) :(int, int) =&gt; (a, b);
let myFunc = (a: int, b: int) :list(int) =&gt; [1];
let myFunc = (a: int, b: int): (int =&gt; int) =&gt; (x) =&gt; x + a + b;
</code></pre></p>
<pre><code class="hljs">&lt;p&gt;
  Parce que nous utilisons &lt;code&gt;=&amp;gt;&lt;/code&gt; pour les fonctions partout en Reason, il y a un cas où nous avons besoin d'ajouter des parenthèses supplémentaires atour du type retourné, qui est lui-même un type de fonction.
&lt;/p&gt;

&lt;h3&gt;
  Paramètres de type
&lt;/h3&gt;

&lt;h4&gt;
  OCaml
&lt;/h4&gt;

&lt;p&gt;
  Les applications de type en OCaml (pensez &quot;generiques&quot;), sont appliquées dans l'ordre inverse.
&lt;/p&gt;

&lt;p&gt;
  Il y a ainsi dans le langage, quelques conséquences assez peu intuitives à cela.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let x: int list = [2]
</code></pre>
<p>type listOfListOfInts = int list list</p>
<p>(* Parsé comme étant : *)
type listOfListOfInts = (int list) list
</code></pre></p>
<pre><code class="hljs">&lt;p&gt;
  Les choses deviennent encore plus étranges lorsque les constructeurs de type acceptent plusieurs paramètres. Les arguments multiples nécessitent des parenthèses et des virgules pour séparer les paramètres de type, mais ces parenthèses ne représentent pas les tuples. La forme parenthèses/virgule doit également être donnée lors de la construction d'instances de type tels que le tuple &lt;code&gt;(int, string) tuple&lt;/code&gt;.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;type ('a, 'b) tuple = 'a * 'b
</code></pre>
<p>type listOfTuplesOfStringAndInt = (string, int) tuple list</p>
<p>(* Parsé comme étant : *)
type listOfTuplesOfStringAndInt = ((string, int) tuple) list</p>
<p>(* Ce qui permet une liste de (tuples de (string et d'int)) *)
let tuples: listOfTuplesOfStringAndInt = [(&quot;asdf&quot;, 3)]
</code></pre></p>
<pre><code class="hljs">&lt;h4&gt;
  Reason
&lt;/h4&gt;

&lt;p&gt;
  En résumé, Reason unifie presque la totalité de la syntaxe au style d'une simple &quot;application de fonction&quot;, ce qui signifie que les paramètres de type suivent le même modèle de listes séparées par des espaces vu partout ailleurs dans la syntaxe. Le résultat de tout cela est qu'il y a moins de modèles syntaxiques à apprendre.
&lt;/p&gt;

&lt;p&gt;
  Par exemple, on peut imaginer &lt;code&gt;list&lt;/code&gt; comme étant une &quot;fonction&quot; pour les types qui accepte un type et retourne un nouveau type.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let x: int list = [2]
type listOfListOfInts = int list list
type ('a, 'b) tup = ('a * 'b)
type pairs = (int, int) tup list
let tuples: pairs = [(2, 3)]</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let x: list(int) = [2];
type listOfListOfInts = list(list(int));
type tup('a, 'b) = ('a, 'b);
type pairs = list(tup(int, int));
let tuples: pairs = [(2, 3)];</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h2&gt;
  Tuples en tant que paramètres de type
&lt;/h2&gt;

&lt;p&gt;
  Parce qu'OCaml utilise des parenthèses et des virgules pour représenter plusieurs arguments de constructeurs de type, il est assez déroutant de voir que l'un des arguments d'un constructeur de type est lui-même un tuple. En OCaml, il est difficile de se rappeler la différence entre un constructeur de type acceptant plusieurs arguments et un constructeur de type acceptant un seul argument qui se trouve être un tuple.
&lt;/p&gt;

&lt;p&gt;
  Les exemples suivants montrent la différence entre passer &lt;em&gt;deux&lt;/em&gt; paramètres de type à &lt;code&gt;pair&lt;/code&gt; et &lt;em&gt;un seul&lt;/em&gt; paramètre de type qui est un tuple.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type intPair = (int, int) pair&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type intPair = pair(int, int)&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type pairList = (int * int) list&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type pairList = list((int, int))&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    En Reason, la syntaxe qui représente un tuple ou des types de tuples ressemble toujours à un tuple.
  &lt;/li&gt;
  &lt;li&gt;
    En Reason, la syntaxe qui représente un record ou des types de records ressemble toujours à un record.
  &lt;/li&gt;
  &lt;li&gt;
    À peu près tout le reste utilise le modèle syntaxique de l'application de fonction (arguments séparés par des virgules).
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;
  Variants
&lt;/h2&gt;

&lt;h5&gt;
  OCaml
&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    OCaml s'attend déjà à ce que les types des arguments de constructeurs soient spécifiés sous la forme de tuples, donc on est un peu confus lorsque le seul argument qu'attend un constructeur &lt;em&gt;se trouve&lt;/em&gt; être type de tuple.
  &lt;/li&gt;
  &lt;li&gt;
    Ce qui est encore plus surprenant, c'est que les constructeurs n'acceptent pas &lt;em&gt;réellement&lt;/em&gt; les tuples, même si la syntaxe parait ressembler à des tuples.
  &lt;/li&gt;
  &lt;li&gt;
    Parfois, la syntaxe pour l'instanciation d'un constructeur avec plusieurs arguments chevauche la syntaxe pour construire une variant avec un seul argument qui se trouve être un tuple - donc on dirait &lt;em&gt;vraiment&lt;/em&gt; que vous &lt;em&gt;êtes&lt;/em&gt; entrain d'envoyer un tuple, alors que ce n'est pas le cas.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;
  Reason
&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    Les types de constructeurs de variants doivent être listés sous forme de listes séparées par des virgules, en utilisant des parenthèses pour regrouper par priorité (comme &lt;strong&gt;tout&lt;/strong&gt; le reste).
  &lt;/li&gt;
  &lt;li&gt;
    La construction des instances de la variant (comme vous l'aurez deviné) suit le style d'application de la fonction (listes séparées par des virgules).
  &lt;/li&gt;
  &lt;li&gt;
    Les tuples &lt;em&gt;ressemblent&lt;/em&gt; &lt;strong&gt;toujours&lt;/strong&gt; à des tuples, et tout autre chose qui ressemblerait à un type … &lt;em&gt;est&lt;/em&gt; un tuple.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>type myVariant =
| HasNothing
| HasSingleInt of int
| HasSingleTuple of (int * int)
| HasMultipleInts of int * int
| HasMultipleTuples of (int * int) * (int * int)
</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>type myVariant =
| HasNothing
| HasSingleInt(int)
| HasSingleTuple((int, int))
| HasMultipleInts(int, int)
| HasMultipleTuples((int, int), (int, int));
</pre>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let a = HasSingleInt 10
let a = HasSingleTuple (10, 10)
let a = HasMultipleInts (10, 10)
let a = HasMultipleTuples ((10, 10), (10, 10))
</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let a = HasSingleInt(10);
let a = HasSingleTuple((10, 10));
let a = HasMultipleInts(10, 10);
let a = HasMultipleTuples((10, 10), (10, 10));
</pre>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let res x = match x with
| HasNothing -&gt; 0
| HasSingleInt x -&gt; 0
| HasSingleTuple (x, y) -&gt; 0
| HasMultipleInts (x, y) -&gt; 0
| HasMultipleTuples ((x, y), (q, r)) -&gt; 0
</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let res = (x) =&gt;
switch (x) {
| HasNothing =&gt; 0
| HasSingleInt(x) =&gt; 0
| HasSingleTuple((x, y)) =&gt; 0
| HasMultipleInts(x, y) =&gt; 0
| HasMultipleTuples((x, y), (q, r)) =&gt; 0
};
</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h2&gt;
  Pattern Matching
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let res = match x with
| A (x, y) -&gt; match y with
| None -&gt; 0
| Some i -&gt; 10
| B (x, y) -&gt; 0</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let res = switch (x) {
| A((x, y)) =&gt; switch (y) {
| None =&gt; 0
| Some(i) =&gt; 10
}
| B((x, y)) =&gt; 0
};</p>
</pre>
        </td>
      </tr>
    </table>
<pre><code class="hljs">&lt;p&gt;
  Pouvez-vous repérer l'erreur dans l'exemple OCaml ? C'est l'une des erreurs les plus fréquentes chez les développeurs OCaml. Le second &lt;code&gt;match&lt;/code&gt; &lt;em&gt;doit&lt;/em&gt; être englobé dans des parenthèses, sinon le cas &lt;code&gt;Some&lt;/code&gt; est parsé comme appartenant au &lt;code&gt;match&lt;/code&gt; externe. Visuellement, c'est en fait :
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let res = match x with
</code></pre>
<p>| A (x, y) -&gt; match y with
| None -&gt; 0
| Some i -&gt; 10
| B (x, y) -&gt; 0
</code></pre></p>
<pre><code class="hljs">&lt;p&gt;
  Les &lt;code&gt;{}&lt;/code&gt; obligatoires en Reason autour des &lt;code&gt;switch&lt;/code&gt; cases empêchent ce problème.
&lt;/p&gt;

&lt;h2&gt;
  Modules et Signatures
&lt;/h2&gt;

&lt;h3&gt;
  Définition
&lt;/h3&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module type MySig = sig
type t = int
val x: int
end
module MyModule: MySig = struct
type t = int
let x = 10
end
module MyModule = struct
module NestedModule = struct
let msg = &quot;hello&quot;;
end
end
</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module type MySig = {
type t = int;
let x: int;
};
module MyModule: MySig = {
type t = int;
let x = 10;
};
module MyModule = {
module NestedModule = {
let msg = &quot;hello&quot;;
};
};
</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  Types de functor
&lt;/h3&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module type FType =
functor (A: ASig) -&gt;
functor (B: BSig) -&gt; Result
</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module type FType =
(A: ASig) =&gt;
(B: BSig) =&gt; Result;
</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h2&gt;
  Functors
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module F =
functor (A: ASig) -&gt;
functor (B: BSig) -&gt; struct end</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module F =
(A: ASig) =&gt;
(B: BSig) =&gt; {};</pre>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module F = functor (A: ASig) (B: BSig) -&gt; struct end</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module F = (A: ASig, B: BSig) =&gt; {};</pre>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module F (A: ASig) (B: BSig) = struct end</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module F = (A: ASig, B: BSig) =&gt; {};</pre>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module Res = F(A)(B)</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module Res = F(A, B);</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h2&gt;
  Améliorations diverses
&lt;/h2&gt;

&lt;p&gt;
  OCaml ne requiert pas de parenthèses autour des séquences &lt;code&gt;(a;b;c;d)&lt;/code&gt; ou des tuples &lt;code&gt;(x,y)&lt;/code&gt;, ce qui finit par exclure un tas d'autres règles de syntaxe très pratiques. Vu que Reason utilise toujours les accolades &lt;code&gt;{}&lt;/code&gt; pour englober des séquences ou des bindigs let, et qu'il requiert toujours des parenthèses &lt;code&gt;()&lt;/code&gt; autour de tuples, beaucoup d'autres constructions de syntaxe sont exprimées de manière plus intuitive, sans nécessiter d'enveloppement supplémentaire entre parenthèses.
&lt;/p&gt;

&lt;h3&gt;
  Les lambdas en champs de record n'ont plus besoin de parenthèses supplémentaires
&lt;/h3&gt;

&lt;p&gt;
  Il s'agit d'une amélioration bienvenue parce que les erreurs de type en OCaml que l'utilisateur voyait étaient très déroutantes quand il pensait que la valeur de retour de la fonction était un tuple avec une virgule &lt;code&gt;,&lt;/code&gt; infixe.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let myFuncs = {
myFun = (fun x -&gt; x + 1);
your = (fun a b -&gt; a + b);
}</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let myFuncs = {
myFun: (x) =&gt; x + 1,
your: (a, b) =&gt; a + b
};</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  Les lambdas en résultats de match n'ont plus besoin de parenthèses supplémentaires
&lt;/h3&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let x = match prnt with
| None -&gt; fun a -&gt; blah
(* Extra () required ! *)
| Some &quot;_&quot; -&gt; (fun a -&gt; ())
| Some &quot;ml&quot; -&gt; blah
</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let x =
switch (prnt) {
| None =&gt; (a) =&gt; blah
| Some(&quot;_&quot;) =&gt; (a) =&gt; ()
| Some(&quot;ml&quot;) =&gt; blah
};</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  Les lambdas et annotations de types des tuples n'ont plus besoin de parenthèses supplémentaires
&lt;/h3&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let tuple = ((fun x -&amp;gt; x), 20)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let tuple = ((x) =&amp;gt; x, 20);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let tuple = ((&quot;hi&quot;: string), (20: int))&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let tuple = (&quot;hi&quot;: string, 20: int);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h2&gt;
  Différences diverses
&lt;/h2&gt;

&lt;h3&gt;
  Priorité d'&lt;code&gt;as&lt;/code&gt;
&lt;/h3&gt;

&lt;p&gt;
  Avec Reason, &lt;code&gt;as&lt;/code&gt; à une plus grande priorité que le pipe &lt;code&gt;|&lt;/code&gt;. Cela permet de créer des alias &lt;code&gt;as&lt;/code&gt; pour des lignes entières dans le pattern matching.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let ppp = match MyThing 20 with
| (MyThing x as ppp)
| (YourThing x as ppp) -&gt; ppp;
</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let ppp =
switch (MyThing(20)) {
| MyThing(x) as ppp
| YourThing(x) as ppp =&gt; ppp
};
</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  Mises à jour de champ de record mutable
&lt;/h3&gt;

&lt;p&gt;
  Parce que les égalités et leurs négations ont été rendues plus cohérentes en Reason, l'opérateur &lt;code&gt;=&lt;/code&gt; est disponible pour la mise à jour du champ mutable.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;myRec.field &amp;lt;- &quot;next&quot;&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;myRec.field &amp;lt;- &quot;next&quot;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  Opérateurs préfixes
&lt;/h3&gt;

&lt;p&gt;
  En Reason, &lt;code&gt;!&lt;/code&gt; est utilisé pour le booléen &lt;code&gt;not&lt;/code&gt;. Le déréférencement utilise le suffixe &lt;code&gt;^&lt;/code&gt;.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(foo.bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo.bar^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(foo#bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo#bar^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(!foo.bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo^.bar^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(!foo#bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = (foo^)#bar^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(!(foo.bar))&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo.bar^ ^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(!(foo#bar))&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo#bar^ ^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !!(foo.bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = !!foo.bar;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !!(foo#bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = !!foo#bar;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !~(foo.bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = !~foo.bar;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !~(foo#bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = !~foo#bar;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  Escape de commentaire
&lt;/h3&gt;

&lt;p&gt;
  Parce que Reason utilise des commentaires de style C, certains obscurs opérateurs préfixes/infixes customs doivent être écrits différemment. Les règles pour les opérateurs préfixes/infixes sont les mêmes que dans la syntaxe OCaml, mais avec les exceptions suivantes :
&lt;/p&gt;

&lt;p&gt;
  Plus précisément, si un caractère, à l'exception du premier, d'un opérateur préfixe/infixe est une étoile ou un slash, il faut d'abord l'échapper avec un backslash. Ceux-ci seront analysés &lt;em&gt;sans&lt;/em&gt; le backslash lorsqu'ils seront ajoutés à l'AST. Lorsqu'ils sont reprint, les backslashes sont automatiquement rajoutés.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let (/*) a b = a + b&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let (/\*) a b =&amp;gt; a + b;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = 12 /-* 23 /-* 12&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = 12 /-* 23 /-* 12;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let y = (/*) a b&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let y = a /\* b;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let (!=*) q r = q + r&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let ( !=* ) = (q, r) =&amp;gt; q + r;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let res = q (!=*) r&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let res = q(( !=* ), r);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let (!=/*) q r = q + r&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let ( !=/\* ) = (q, r) =&amp;gt; q + r;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let res = q (!=/*) r&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let res = q(( !=/\* ), r);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  Renommage d'opérateur
&lt;/h3&gt;

&lt;p&gt;
  Si Reason utilise &lt;code&gt;==&lt;/code&gt; pour représenter le &lt;code&gt;=&lt;/code&gt; d'OCaml, et utilise &lt;code&gt;===&lt;/code&gt; pour représenter le &lt;code&gt;==&lt;/code&gt; d'OCaml, alors comment est-ce que Reason représente le symbole &lt;code&gt;===&lt;/code&gt; d'OCaml (s'il était défini) ? Reason propose une solution ! &quot;Escape&quot; le symbole triple égal !
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      Identifiant
    &lt;/th&gt;
    
    &lt;th&gt;
      Sens
    &lt;/th&gt;
    
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&quot;===&quot;&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      Valeur custom
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;x === y&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;x \=== y&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  REPL
&lt;/h3&gt;

&lt;p&gt;
  Dans la boucle d'évaluation de Reason, &lt;a href=&quot;extra-goodies.md#repl&quot;&gt;&lt;code&gt;rtop&lt;/code&gt;&lt;/a&gt; (une version customisée d'&lt;a href=&quot;https://github.com/diml/utop&quot;&gt;&lt;code&gt;utop&lt;/code&gt;&lt;/a&gt;), chaque entrée est soumise via un seul point-virgule &lt;code&gt;;&lt;/code&gt;. A boucle d'évalution OCaml quant à elle requiert deux points-virgules &lt;code&gt;;;&lt;/code&gt;.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;;;&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="faq.html">← Foire aux Questions</a><a class="docs-next button" href="newcomer-examples.html">Exemples néophytes →</a></div></div></div></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react'
              });
            </script></body></html>