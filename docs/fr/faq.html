<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>Frequently Asked Questions · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Frequently Asked Questions · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/index.html"/><meta property="og:description" content="### Dois-je apprendre Reason ou OCaml en premier ?"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/arduino-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/dummy.svg"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/docs/fr/quickstart-javascript.html" target="_self">Docs</a></li><li><a href="/fr/try.html" target="_self">Try</a></li><li><a href="/api/index.html" target="_self">API</a></li><li><a href="/docs/fr/community.html" target="_self">Community</a></li><li><a href="/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg"/>Français</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/ja">日本語</a></li><li><a href="/en">English</a></li><li><a href="/es-ES">Español</a></li><li><a href="/ko">한국어</a></li><li><a href="/pt-BR">Português (Brasil)</a></li><li><a href="/ru">Русский</a></li><li><a href="/zh-CN">中文</a></li><li><a href="/zh-TW">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank">Help Translate</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Community</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Community</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/community.html">Community</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/articles-and-videos.html">Articles &amp; Videos</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/docs/fr/faq.html">Frequently Asked Questions</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/roadmap.html">Roadmap &amp; Contribution</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/events.html">Events</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/community-examples.html">Examples</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/fr" target="_blank">Translate</a><h1>Frequently Asked Questions</h1></header><article><div><span><h3><a class="anchor" aria-hidden="true" name="dois-je-apprendre-reason-ou-ocaml-en-premier"></a><a href="#dois-je-apprendre-reason-ou-ocaml-en-premier" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dois-je apprendre Reason ou OCaml en premier ?</h3>
<p>Pas besoin de choisir ! Reason et OCaml partagent exactement la même sémantique (c'est-à-dire comment le code est exécuté). Seule la syntaxe diffère. Gardez <a href="https://github.com/reasonml/reason-tools">Reason-tools</a> près de vous pour passer d'une syntaxe à l'autre à tout moment. Un tutoriel Reason est un tutoriel OCaml, et vice-versa. Dans la ligne de commande, vous pouvez créer les deux alias suivants :</p>
<pre><code class="hljs css sh"><span class="hljs-comment"># conversion de code OCaml vers Reason</span>
<span class="hljs-built_in">alias</span> mlre=<span class="hljs-string">"pbpaste | refmt --parse ml --print re --interface false | pbcopy"</span>
<span class="hljs-comment"># conversion de code Reason vers OCaml</span>
<span class="hljs-built_in">alias</span> reml=<span class="hljs-string">"pbpaste | refmt --parse re --print ml --interface false | pbcopy"</span>
</code></pre>
<p>Ils prendront votre code depuis le presse-papier (macOS), le convertiront, et le remettront dans le presse-papier. Changez pbpaste/pbcopy par les outils de gestion de presse-papier de votre système.</p>
<h3><a class="anchor" aria-hidden="true" name="je-ne-suis-pas-sur-de-savoir-quoi-faire-avec-reason"></a><a href="#je-ne-suis-pas-sur-de-savoir-quoi-faire-avec-reason" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Je ne suis pas sûr de savoir quoi faire avec Reason</h3>
<p><a href="/docs/fr/quickstart-javascript.html">Nous compilons très bien en JavaScript</a>. Pensez au projet que vous auriez l'habitude de réaliser en pur JavaScript ; essayez de le convertir ou de l'écrire en Reason + BuckleScript à la place ! Nous recommandons d'essayer de réaliser des projets concrets pour l'utilisateur final (par exemple un outil en ligne de commande) plutôt que des projets au niveau infra (par exemple un générateur de squelette de projet). Ces derniers nécessitent une expertise et une compréhension idiomatique du code de Reason.</p>
<h3><a class="anchor" aria-hidden="true" name="quel-est-le-lien-entre-reason-bucklescript-et-ocaml"></a><a href="#quel-est-le-lien-entre-reason-bucklescript-et-ocaml" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Quel est le lien entre Reason, BuckleScript et OCaml ?</h3>
<p>Plus d'informations <a href="/docs/fr/quickstart-javascript.html">ici</a>. Reason est une syntaxe pour OCaml et supporte toutes ses fonctionnalités. BuckleScript compile du code OCaml/Reason vers du JavaScript.</p>
<h3><a class="anchor" aria-hidden="true" name="d-ou-viennent-toutes-ces-fonctions-print-endline-string-of-int"></a><a href="#d-ou-viennent-toutes-ces-fonctions-print-endline-string-of-int" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>D'où viennent toutes ces fonctions <code>print_endline</code>, <code>string_of_int</code> ?</h3>
<p>Elles viennent de la bibliothèque standard, incluses automatiquement lors de la compilation de votre fichier. C'est pourquoi elles sont disponibles dans le contexte global.</p>
<h3><a class="anchor" aria-hidden="true" name="y-a-t-il-une-fonction-permettant-d-afficher-une-structure-de-donnees-arbitraire"></a><a href="#y-a-t-il-une-fonction-permettant-d-afficher-une-structure-de-donnees-arbitraire" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Y a-t-il une fonction permettant d'afficher une structure de données arbitraire ?</h3>
<p>Si vous compilez en JavaScript via BuckleScript, vous pouvez utiliser <code>console.log</code> de JavaScript grâce à <a href="https://bucklescript.github.io/bucklescript/api/Js.html#VALlog"><code>Js.log</code></a>. Si vous compilez en natif, vous aurez besoin de quelque chose comme <a href="https://github.com/diml/ppx_show">ppx_show</a>. Une future fonctionnalité d'OCaml (appelée <em>modular implicit</em>) résoudra cela directement dans le langage.</p>
<h3><a class="anchor" aria-hidden="true" name="pourquoi-y-a-t-il-un-operateur-pour-additionner-des-entiers-pour-additionner-des-flottants-etc"></a><a href="#pourquoi-y-a-t-il-un-operateur-pour-additionner-des-entiers-pour-additionner-des-flottants-etc" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pourquoi y a-t-il un opérateur <code>+</code> pour additionner des entiers, <code>+.</code> pour additionner des flottants, etc. ?</h3>
<p>Plus d'informations <a href="/docs/fr/integer-and-float.html#design-decisions">ici</a>.</p>
<h3><a class="anchor" aria-hidden="true" name="est-ce-que-la-bibliotheque-fonctionne-avec-reason"></a><a href="#est-ce-que-la-bibliotheque-fonctionne-avec-reason" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Est-ce que la bibliothèque ___ fonctionne avec Reason ?</h3>
<p>La plupart des bibliothèques JavaScript devraient fonctionner sans problèmes avec Reason + BuckleScript. Pour ce qui est du natif, étant donné que Reason n'est qu'une syntaxe différente : oui, elles devraient fonctionner avec Reason également. Mais le <em>workflow</em> natif est encore en cours de développement, et nécessite quelques finitions.</p>
<h3><a class="anchor" aria-hidden="true" name="qu-en-est-il-du-server-side-devrais-je-compiler-en-natif-ou-vers-javascript-et-utiliser-nodejs"></a><a href="#qu-en-est-il-du-server-side-devrais-je-compiler-en-natif-ou-vers-javascript-et-utiliser-nodejs" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Qu'en est-il du <em>server-side</em> ? Devrais-je compiler en natif ou vers JavaScript et utiliser Node.js ?</h3>
<p>Nous compilons en natif, mais le <em>workflow</em> est en cours de développement. Pour le moment nous recommandons de compiler en JavaScript via BuckleScript et d'utiliser les <em>bindings</em> de <a href="https://github.com/reasonml-community">reasonml-community</a> ou d'ailleurs.</p>
<h3><a class="anchor" aria-hidden="true" name="qu-en-est-il-de-l-asynchrone-avec-bucklescript"></a><a href="#qu-en-est-il-de-l-asynchrone-avec-bucklescript" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Qu'en est-il de l'asynchrone avec BuckleScript ?</h3>
<p>Tout d'abord, si vous ne vous interfacez avec aucune bibliothèque utilisant les promesses, vous pouvez simplement utiliser des <em>callbacks</em>. Ils sont compris de tout le monde et sont performants.</p>
<p>Si vous avez besoin d'une bibliothèque JavaScript utilisant des promesses, ou si vous devez communiquer avec une telle bibliothèque, vous pouvez utiliser les<em>bindings</em> BuckleScript pour les promesses<a>. Il se pourrait qu'une nouvelle syntaxe facilite cela dans le futur. À long terme, nous souhaiterions mettre en place une implémentation des promesses conforme aux spécifications, en OCaml/Reason, afin de pouvoir profiter des optimisations du compilateur.</p></p>
<p>
  Pour une solution plus idiomatique en OCaml, il existe <a href="http://ocsigen.org/lwt/">lwt</a> et <a href="https://ocaml.janestreet.com/ocaml-core/111.03.00/doc/async/#Std">Async</a>. Ils ne sont pas utilisés pour le web, mais pourraient l'être dans le futur.
</p>
<p><h3>
Qu'en est-il des tests (unitaires) ?
</h3></p>
<p>
  Certaines fonctionnalités du langage OCaml (pas seulement les types) peuvent repousser le besoin de tests unitaires à plus tard. En attendant, pour la compilation vers JavaScript, nous travaillons sur des <a href="https://github.com/BuckleTypes/bs-jest"><em>bindings</em> pour Jest</a>. Nous étudierons la possibilité d'utiliser Jest pour le natif également, si Jest est écrit en Reason dans le futur (ce qui n'est pas prévu à l'heure actuelle). <a href="http://ounit.forge.ocamlcore.org">OUnit</a> est une bonne librairie native de tests pour OCaml.
</p>
<p><h3>
Quel est ce fichier <code>.merlin</code> à la racine de mon projet ?
</h3></p>
<p>
  Il s'agit du fichier de métadonnées pour <a href="extra-goodies.md#merlin">Merlin</a>, le programme en arrière-plan permettant l'intégration aux éditeurs pour l'auto-complétion, le <em>jump-to-definition</em>, etc. Pour le <a href="quickstart-javascript.md"><em>workflow</em> JavaScript</a>, le système de <em>build</em> <code>bsb</code> génère le <code>.merlin</code> pour vous. Vous n'avez pas besoin de le surveiller dans votre outil de gestion de version, ni de le modifier manuellement.
</p>
<p><h3>
Je ne vois ni <code>import</code> ni <code>require</code> dans mon fichier ; comment fonctionne la résolution de module ?
</h3></p>
<p>
  Aucun import explicite n'est nécessaire en Reason/OCaml ; les modules référencés dans le fichier sont automatiquement recherchés dans le projet. Plus précisément, un module <code>Hello</code> demande au compilateur de rechercher le fichier <code>hello.re</code> ou <code>hello.ml</code> (et leurs <a href="module.md#signatures">fichiers d'interface</a> correspondant, <code>hello.rei</code> ou <code>hello.mli </code>, le cas échéant).
</p>
<p>
  Le nom d'un module est le nom du fichier, avec une majuscule. Il doit être unique dans le projet ; cela permet de s'affranchir du système de fichier et vous laisse libre de réorganiser vos fichiers sans modifier le code.
</p>
<p><h3>
Est-ce que <code>Some | None</code>, <code>contents</code>, <code>Array</code>, <code>List</code> et autres sont spéciaux ? D'où proviennent-ils ?
</h3></p>
<p>
  Il s'agit de définitions de <em>variants</em>, <em>records</em>, modules ordinaires qui sont fournis avec la <a href="/api/index.html">bibliothèque standard</a>, incluse par défaut à la compilation par commodité.
</p>
<p><h3>
Qu'implique le fait, pour un paramètre, d'être préfixé par un tiret bas ? (par exemple <code>_</code> ou <code>_foo</code>)
</h3></p>
<p>
  Disons que vous avez <code>List.map (fun item =&gt; 1) myList</code>. Le paramètre <code>item</code> n'est pas utilisé et génèrera un avertissement de la part du compilateur. Utiliser à la place <code>fun _ =&gt; 1</code> indique que vous ignorez volontairement le paramètre, évitant ainsi l'avertissement. Autrement, <code>fun _item =&gt; 1</code> a le même effet, mais décrit mieux le paramètre que vous ignorez.
</p>
<p><h3>
Quel est ce <code>MyModule.t</code> que je vois tout le temps ?
</h3></p>
<p>
  En supposant que <code>MyModule</code> est le nom d'un module, <code>t</code> est une convention de la communauté pour indiquer « le type que représente ce module, quoi que cela veuille dire ». Par exemple, pour le module <a href="http://bucklescript.github.io/bucklescript/api/Js.String.html"><code>Js.String</code></a>, <a href="http://bucklescript.github.io/bucklescript/api/Js.String.html#TYPEt"><code>String.t</code></a> est le type manipulé et représentant « une chaîne de caractères ».
</p>
<p><h3>
Pourquoi y a-t-il un <a href="http://bucklescript.github.io/bucklescript/api/Js_promise.html"><code>Js_promise</code></a> et également un <a href="http://bucklescript.github.io/bucklescript/api/Js.Promise.html"><code>Js.Promise</code></a> ? Et pour <a href="http://bucklescript.github.io/bucklescript/api/Js_array.html"><code>Js_array</code></a>, <a href="http://bucklescript.github.io/bucklescript/api/Js_string.html"><code>Js_string</code></a> et les autres ?
</h3></p>
<p>
  Par convention, <code>Js_foo</code> est le vrai nom du module, et <code>Js.Foo</code> est un alias. Ils sont <a href="https://github.com/bloomberg/bucklescript/blob/7bc37f387a726ba1ae4afeefe02b9c82577d9e10/jscomp/runtime/js.ml#L124-L138">équivalents</a>. Privilégiez <code>Js.Foo</code> car il s'agit du nom public officiel du module.
</p>
<p><h3>
Quand est-ce que les <em>modular implicit</em>, <em>multicore</em> et <em>algebraic effects</em> seront prêts ?
</h3></p>
<p>
  Ils le seront un jour. En attendant, aidez-nous à livrer plus de code Reason ! La popularité aidera à canaliser plus de contributions OCaml. Moins les personnes d'OCaml ont besoin de s'inquiéter des « fruits prêts à tomber », plus ils peuvent se concentrer sur de la recherche et du développement !
</p>
<p><h3>
Pourquoi BuckleScript et <code>bsb</code> sont-ils si rapides ? Comment puis-je les ralentir ?
</h3></p>
<p>
  BuckleScript est optimisé pour les performances sur chaque couche applicative. Vous pouvez le ralentir en ajoutant quelque douzaine de couches d'indirections et un peu de métaprogrammation. Essayez :
</p>
<ul>
  <li>
    d'ajouter quelques boucles infinies ici et là ;
  </li>
  <li>
    de caler un outil de build JavaScript dans votre <em>pipeline</em> ;
  </li>
  <li>
    de placer plus de dépendances pour un « Hello World ».
  </li>
</ul>
<p><h3>
Je vois un étrange fichier .cmi/.cmx/.cmj/.cma dans une erreur du compilateur. D'où viennent ces fichiers ?
</h3></p>
<p>
  La communauté OCaml utilise fréquemment des extensions de fichier pour distinguer les fichiers sources, artefacts et de métadonnées, en fonction du résultat final visé (natif, <em>bytecode</em>, JavaScript). Voici un aperçu de certaines extensions que vous pouvez croiser :
</p>
<p><h4>
Fichiers sources
</h4></p>
<ul>
  <li>
    <code>.ml</code> : fichier source OCaml
  </li>
  <li>
    <code>.mli</code> : fichier d'interface OCaml ; il détermine quelles parties du fichier <code>.ml</code> sont visibles depuis l'extérieur
  </li>
  <li>
    <code>.re</code> : fichier source Reason ; équivalent du <code>.ml</code> pour Reason
  </li>
  <li>
    <code>.rei</code> : fichier d'interface Reason ; équivalent du <code>.mli</code> pour Reason
  </li>
</ul>
<p><h4>
Fichiers compilés
</h4></p>
<ul>
  <li>
    <code>.cmi</code> : fichier d'interface (.rei/.mli) compilé
  </li>
  <li>
    <code>.cmx</code> : fichier d'objets compilé (via ocamlopt) pour générer du natif
  </li>
  <li>
    <code>.cmo</code> : fichier d'objet compilé pour générer du <em>bytecode</em>
  </li>
  <li>
    <code>.cmj</code> : fichier d'objet compilé pour le web (via BuckleScript)
  </li>
  <li>
    <code>.cma</code>: fichier de bibliothèque pour générer du <em>bytecode</em> (équivalent des fichiers .a en C)
  </li>
  <li>
    <code>.cmxa</code> : fichiers de bibliothèque pour générer du natif
  </li>
  <li>
    <code>.cmt</code> : contient un « Typedtree » – finalement l'AST avec tous les informations de type
  </li>
  <li>
    <code>.cmti</code> : comme un fichier .cmt, mais pour les fichiers d'interface
  </li>
  <li>
    <code>.cmxs</code> : plugin chargé dynamiquement (pour compilation native)
  </li>
  <li>
    <code>.o</code> : fichier d'objet natif compilé
  </li>
  <li>
    <code>.out</code> : nom/extension conventionnel pour le fichier final généré par ocamlc/ocamlopt (par exemple <code>ocamlc -o myExecutable.out</code>)
  </li>
</ul>
<p><h4>
Autres fichiers de l'écosystème OCaml
</h4></p>
<ul>
  <li>
    <code>.mll</code> : fichier de définition de l'<em>ocamllex lexical analyzer</em>
  </li>
  <li>
    <code>.mly</code> : fichier de définition de l'<em>ocamlyacc parser generator</em>
  </li>
  <li>
    <code>.mldylib</code> : contient une liste de chemins de modules qui seront compilés et assemblés pour construire un fichier <code>.cmxs</code> correspondant (plugin natif)
  </li>
  <li>
    <code>.mliv</code> : fichiers spécifiques à <em>batteries</em> pour du <a href="https://github.com/ocaml-batteries-team/batteries-included/blob/f019927b9503ec65ef816f02315de78d4bae3481/src/batArray.mliv"><em>preprocessing</em> personnalisé</a>
  </li>
  <li>
    <code>.mllib</code> : bibliothèque OCaml (cma et cmxa)
  </li>
  <li>
    <code>.mlpack</code> : paquet OCaml (construit avec cmo et le paramètre -pack)
  </li>
  <li>
    <code>.mlpp</code> : fichiers relatifs à <a href="https://github.com/ygrek/ocaml-extlib">Extlib</a> pour du <em>preprocessing</em> personnalisé
  </li>
  <li>
    <code>.mltop</code> : <a href="https://shonkychef.wordpress.com/2009/07/28/making-an-ocaml-toplevel-with-ocamlbuild/">fichier <em>top-level</em> OCamlbuild</a>, utilisé par OCamlbuild pour générer un fichier .top.
  </li>
  <li>
    <code>.odocl</code> : fichier de documentation OCaml
  </li>
</ul>
<p>
  Si certaines de ces explications sont encore un peu énigmatiques, voici quelques apports concernant des termes utilisés plus haut : - <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">AST</a> : <em>Abstract Syntax Tree</em> ou Arbre syntaxique abstrait. La structure de données issue du code source, sur laquelle opère le compilateur. - <a href="https://en.wikipedia.org/wiki/Linker_(computing)"><em>Linking</em><a> : l'étape durant laquelle le compilateur prend plusieurs fichiers intermédiaires compilés et les assemble. Par exemple lier A avec B, car le fichier source original de A référence B. - Natif : programme exécuté sur la plateforme cible directement en instruction assembleur. - <a href="https://en.wikipedia.org/wiki/Bytecode">Bytecode</a> : comme du code natif, mais plus portable et moins performant - <a href="https://en.wikipedia.org/wiki/Object_file">Fichier objet</a> : contient du code machine qui n'est pas exécutable directement.</p> 
  <p>
    Plus d'informations et de contexte sur ces extensions de fichiers peuvent être trouvées sur <a href="https://ocaml.org/learn/tutorials/filenames.html">le site d'OCaml</a> et dans <a href="http://caml.inria.fr/pub/ml-archives/caml-list/2008/09/2bc9b38171177af5dc0d832a365d290d.en.html">ce message de liste de diffusion</a>. Vous pourrez aussi explorer plus en profondeur les compilations de code <a href="https://caml.inria.fr/pub/docs/manual-ocaml/native.html">natif</a> ou <a href="http://caml.inria.fr/pub/docs/manual-ocaml/comp.html"><em>bytecode</em></a> avec des descriptions plus détaillées dans le manuel d'OCaml.
  </p></span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="articles-and-videos.html">← Articles &amp; Videos</a><a class="docs-next button" href="roadmap.html">Roadmap &amp; Contribution →</a></div></div></div></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react'
              });
            </script></body></html>