<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>Module · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Module · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/index.html"/><meta property="og:description" content="## Fondamentaux"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/arduino-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/dummy.svg"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/docs/fr/quickstart-javascript.html" target="_self">Docs</a></li><li><a href="/fr/try.html" target="_self">Éditeur</a></li><li><a href="/api/index.html" target="_self">API</a></li><li><a href="/docs/fr/community.html" target="_self">Communauté</a></li><li><a href="/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg"/>Français</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/ja">日本語</a></li><li><a href="/en">English</a></li><li><a href="/es-ES">Español</a></li><li><a href="/ko">한국어</a></li><li><a href="/pt-BR">Português (Brasil)</a></li><li><a href="/ru">Русский</a></li><li><a href="/uk">Українська</a></li><li><a href="/zh-CN">中文</a></li><li><a href="/zh-TW">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank">Aider à la traduction</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Language Basics</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Intro</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/what-and-why.html">Quoi &amp; Pourquoi</a></li></ul></div><div class="navGroup navGroupActive"><h3>Configuration de l&#x27;éditeur</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/global-installation.html">Installation globale</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/editor-plugins.html">Plugins éditeurs</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/extra-goodies.html">Goodies supplémentaires</a></li></ul></div><div class="navGroup navGroupActive"><h3>Principes de base du langage</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/overview.html">Aperçu</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/let-binding.html">Binding let</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/type.html">Type!</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/string-and-char.html">String &amp; Char</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/boolean.html">Booléen</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/integer-and-float.html">Integer &amp; Float</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/tuple.html">Tuple</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/record.html">Record</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/variant.html">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/list-and-array.html">List &amp; Array</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/function.html">Fonction</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/if-else.html">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/more-on-type.html">Plus sur les types</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/destructuring.html">Destructuring</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/pattern-matching.html">Pattern Matching!</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/mutation.html">Mutations</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/imperative-loops.html">Boucles impératives</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/jsx.html">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/external.html">External</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/exception.html">Exception</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/object.html">Objet</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/docs/fr/module.html">Module</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/promise.html">Promise</a></li></ul></div><div class="navGroup navGroupActive"><h3>JavaScript</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/quickstart-javascript.html">Démarrage rapide</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/interop.html">Interopérabilité</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/syntax-cheatsheet.html">Cheatsheet de la syntaxe</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/libraries.html">Librairies</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/converting-from-js.html">Convertir depuis JavaScript</a></li></ul></div><div class="navGroup navGroupActive"><h3>Natif</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/native.html">Natif</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/quickstart-ocaml.html">Démarrage rapide</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/convert-from-ocaml.html">Convertir depuis OCaml</a></li></ul></div><div class="navGroup navGroupActive"><h3>Extra</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/faq.html">Foire aux Questions</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/comparison-to-ocaml.html">Comparaison avec OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/newcomer-examples.html">Exemples néophytes</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/project-structure.html">Structure de projet</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/fr" target="_blank">Translate</a><h1>Module</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" name="fondamentaux"></a><a href="#fondamentaux" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fondamentaux</h2>
<p><strong>Les modules sont comme des petits fichiers</strong> ! Ils peuvent contenir des définitions de type, des bindings <code>let</code>, d'autres modules imbriqués, etc.</p>
<h3><a class="anchor" aria-hidden="true" name="creation"></a><a href="#creation" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Création</h3>
<p>Pour créer un module, utilisez le mot clé <code>module</code>. Le nom du module doit commencer par une <strong>lettre majuscule</strong>. Tout ce que vous pouvez placer dans un fichier <code>.re</code>, peut aller à l'intérieur du bloc de définition <code>{}</code> d’un module.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">module</span> School = {
  <span class="hljs-keyword">type</span> profession = Teacher | Director;

  <span class="hljs-keyword">let</span> person1 = Teacher;
  <span class="hljs-keyword">let</span> getProfession = <span class="hljs-function">(<span class="hljs-params">person</span>) =&gt;</span>
    <span class="hljs-keyword">switch</span> (person) {
    | <span class="hljs-function"><span class="hljs-params">Teacher</span> =&gt;</span> <span class="hljs-string">"A teacher"</span>
    | <span class="hljs-function"><span class="hljs-params">Director</span> =&gt;</span> <span class="hljs-string">"A director"</span>
    };
};
</code></pre>
<p>Vous pouvez accéder au contenu d'un module (types inclus !) de la même façon qu'avec un record, en utilisant la notation <code>.</code>. Ceci démontre l'utilité des modules pour le namespacing.</p>
<pre><code class="hljs css reason">let anotherPerson: <span class="hljs-keyword">School.profession </span>= <span class="hljs-keyword">School.Teacher;
</span>print_endline(<span class="hljs-keyword">School.getProfession(anotherPerson)); </span><span class="hljs-comment">/* "A teacher" */</span>
</code></pre>
<p>Les modules imbriqués fonctionnent aussi.</p>
<pre><code class="hljs css reason">module <span class="hljs-attr">MyModule</span> = {
  module <span class="hljs-attr">NestedModule</span> = {
    <span class="hljs-keyword">let</span> <span class="hljs-attr">message</span> = <span class="hljs-string">"hello"</span>;
  };
};

<span class="hljs-keyword">let</span> <span class="hljs-attr">message</span> = MyModule.NestedModule.message;
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="open-un-module"></a><a href="#open-un-module" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>open</code> un module</h3>
<p>Se référer constamment à une valeur/type dans un module peut être fastidieux. Nous pouvons ouvrir la définition d’un module et nous référer à son contenu sans les préciser avec le nom du module. Deux options s'offrent à nous :</p>
<p>Ouverture locale.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> message =
  School.(
    <span class="hljs-keyword">switch</span> (person1) {
    | <span class="hljs-function"><span class="hljs-params">Teacher</span> =&gt;</span> <span class="hljs-string">"Hello teacher!"</span>
    | <span class="hljs-function"><span class="hljs-params">Director</span> =&gt;</span> <span class="hljs-string">"Hello director!"</span>
    }
  );
</code></pre>
<p>Ouverture globale. <strong>Utilisez-la avec précaution, certes cela permet une certaine commodité mais au prix de la facilité de raisonnement</strong> :</p>
<pre><code class="hljs css reason">open <span class="hljs-keyword">School;
</span>let anotherPerson: profession = Teacher<span class="hljs-comment">;</span>
printProfession(anotherPerson)<span class="hljs-comment">;</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="extension-de-module"></a><a href="#extension-de-module" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Extension de module</h3>
<p>Utiliser <code>include</code> à l'intérieur d'un module &quot;spread&quot; statiquement son contenu à l'intérieur d'un nouveau module, remplissant souvent le rôle &quot;d'héritage&quot; ou de &quot;mixin&quot;.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">module</span> BaseComponent = {
  <span class="hljs-keyword">let</span> defaultGreeting = <span class="hljs-string">"Hello"</span>;
  <span class="hljs-keyword">let</span> getAudience = <span class="hljs-function">(<span class="hljs-params">~excited</span>) =&gt;</span> excited ? <span class="hljs-string">"world!"</span> : <span class="hljs-string">"world"</span>;
};

<span class="hljs-keyword">module</span> ActualComponent = {
  <span class="hljs-comment">/* the content is copied over */</span>
  include BaseComponent;
  <span class="hljs-comment">/* overrides BaseComponent.defaultGreeting */</span>
  <span class="hljs-keyword">let</span> defaultGreeting = <span class="hljs-string">"Hey"</span>;
  <span class="hljs-keyword">let</span> render = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> defaultGreeting ++ <span class="hljs-string">" "</span> ++ getAudience(~excited=<span class="hljs-literal">true</span>);
};
</code></pre>
<p><strong>Note</strong> : <code>open</code> et <code>include</code> sont très différents ! Le premier apporte le contenu d'un module dans votre scope, de sorte à ce que vous n'ayez pas à faire référence à une valeur en la préfixant avec le nom du module à chaque fois. Ce dernier <strong>copie</strong> la définition d'un module de manière statique, puis éffectue également un <code>open</code>.</p>
<h3><a class="anchor" aria-hidden="true" name="tout-fichier-re-est-un-module"></a><a href="#tout-fichier-re-est-un-module" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tout fichier <code>.re</code> est un module</h3>
<p>Un fichier OCaml/Reason map vers un module. Cela permet une expressivité assez intéressante qui nécessitait auparavant la génération de code supplémentaire dans d'autres langages. The file <code>React.re</code> implicitly forms a module <code>React</code>, which can be seen by other source files.</p>
<pre><code class="hljs css reason"><span class="hljs-comment">/* FileA.re. This typically compiles to module FileA below */</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">a</span> = <span class="hljs-number">1</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">b</span> = <span class="hljs-number">2</span>;

<span class="hljs-comment">/* FileB.re */</span>
<span class="hljs-comment">/* Maps FileA's implementation to a new API */</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">alpha</span> = FileA.a;
<span class="hljs-keyword">let</span> <span class="hljs-attr">beta</span> = FileA.b;
</code></pre>
<p>Cet extrait artificiel montre une &quot;copie&quot; de fichier :</p>
<pre><code class="hljs css reason"><span class="hljs-comment">/* FileA.re. This typically compiles to module FileA below */</span>
let a = <span class="hljs-number">1</span><span class="hljs-comment">;</span>
let <span class="hljs-keyword">b </span>= <span class="hljs-number">2</span><span class="hljs-comment">;</span>

<span class="hljs-comment">/* FileB.re */</span>
<span class="hljs-comment">/* compiles to exactly fileA.re's content with no runtime overhead! */</span>
include FileA<span class="hljs-comment">;</span>
</code></pre>
<p><strong>Note</strong>: Because files are modules, file names should, by convention, be capitalized so they match their module names. Uncapitalized file names are not invalid, but will be transformed into a capitalized module name. I.e. <code>file.re</code> will be compiled into the module <code>File</code>. To simplify and minimize the disconnect here, the convention is therefore to capitalize file names too.</p>
<h2><a class="anchor" aria-hidden="true" name="signatures"></a><a href="#signatures" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Signatures</h2>
<p>A module's type is called a &quot;signature&quot;, and can be written explicitly. If a module is like a <code>.re</code> (implementation) file, then a module's signature is like a <code>.rei</code> (interface) file.</p>
<h3><a class="anchor" aria-hidden="true" name="creation"></a><a href="#creation" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Création</h3>
<p>To create a signature, use the <code>module type</code> keyword. The signature name must start with a <strong>capital letter</strong>. Whatever you could place in a <code>.rei</code> file, you may place inside a signature definition's <code>{}</code> block.</p>
<pre><code class="hljs css reason"><span class="hljs-comment">/* Récupérons l'exemple de la section précédente */</span>
<span class="hljs-keyword">module</span> type EstablishmentType = {
  <span class="hljs-keyword">type</span> profession;
  <span class="hljs-keyword">let</span> getProfession: <span class="hljs-function"><span class="hljs-params">profession</span> =&gt;</span> <span class="hljs-built_in">string</span>;
};
</code></pre>
<p>A signature defines the list of requirements that a module must satisfy in order for that module to match the signature. Those requirements are of the form:</p>
<ul>
<li><code>laissez x: int;</code> nécessite un binding <code>let</code> nommé <code>x</code> et de type <code>int</code>.</li>
<li><code>t type = someType;</code> nécessite un champ de type <code>t</code> étant égal à <code>someType</code>.</li>
<li><code>type t ;</code> nécessite un champ de type <code>t</code>, mais sans imposer de'exigence sur le type concret de <code>t</code>. Nous pourrions utiliser <code>t</code> dans d'autres entrées de la signature pour décrire les relations, par exemple <code>let makePair: t = &gt; (t, t)</code>, mais on ne peut pas par exemple, supposer que <code>t</code> est un <code>int</code>. Cela nous donne de grandes capacités d'abstraction forcées.</li>
</ul>
<p>To illustrate the various kinds of type entries, consider the above signature <code>EstablishmentType</code> which requires that a module:</p>
<ul>
<li>déclare un type nommé <code>profession</code>.</li>
<li>doit inclure une fonction qui prend une valeur du type de <code>profession</code> et retourne une string.</li>
</ul>
<p><strong>Note</strong>:</p>
<p>Modules of the type <code>EstablishmentType</code> can contain more fields than the signature declares, just like the module <code>School</code> in the previous section (if we choose to assign it the type <code>EstablishmentType</code>. Otherwise, <code>School</code> exposes every field). This effectively makes the <code>person1</code> field an enforced implementation detail! Outsiders can't access it, since it's not present in the signature; the signature <strong>constrained</strong> what others can access.</p>
<p>The type <code>EstablishmentType.profession</code> is <strong>abstract</strong>: it doesn't have a concrete type; it's saying &quot;I don't care what the actual type is, but it's used as input to <code>getProfession</code>&quot;. This is useful to fit many modules under the same interface:</p>
<pre><code class="hljs css reason">module Company: EstablishmentType = {
 <span class="hljs-built_in"> type </span>profession = CEO | Designer | Engineer | <span class="hljs-built_in">..</span>.;

  let getProfession = (person) =&gt; <span class="hljs-built_in">..</span>.;
  let person1 = <span class="hljs-built_in">..</span>.;
  let person2 = <span class="hljs-built_in">..</span>.;
};
</code></pre>
<p>It's also useful to hide the underlying type as an implementation detail others can't rely on. If you ask what the type of <code>Company.profession</code> is, instead of exposing the variant, it'll only tell you &quot;it's <code>Company.profession</code>&quot;.</p>
<h3><a class="anchor" aria-hidden="true" name="extension-de-la-signature-d-un-module"></a><a href="#extension-de-la-signature-d-un-module" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Extension de la signature d'un module</h3>
<p>Like modules themselves, module signatures can also be extended through <code>include module type of Foo</code>:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">module</span> <span class="hljs-keyword">type</span> <span class="hljs-type">BaseComponent</span> = {
  <span class="hljs-keyword">let</span> defaultGreeting: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">let</span> getAudience: (~excited: <span class="hljs-built_in">bool</span>) =&gt; <span class="hljs-built_in">string</span>;
};

<span class="hljs-keyword">module</span> <span class="hljs-keyword">type</span> <span class="hljs-type">ActualComponent</span> = {
  /* la signature est copiée*/
  <span class="hljs-keyword">include</span> (<span class="hljs-keyword">module</span> <span class="hljs-keyword">type</span> <span class="hljs-keyword">of</span> <span class="hljs-type">BaseComponent</span>);
  <span class="hljs-keyword">let</span> render: <span class="hljs-built_in">unit</span> =&gt; <span class="hljs-built_in">string</span>;
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="tout-fichier-rei-est-une-signature"></a><a href="#tout-fichier-rei-est-une-signature" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tout fichier <code>.rei</code> est une signature</h3>
<p>Similar to how a <code>React.re</code> file implicitly defines a module <code>React</code>, a file <code>React.rei</code> implicitly defines a signature for <code>React</code>. If <code>React.rei</code> isn't provided, the signature of <code>React.re</code> defaults to exposing all the fields of the module. Because they don't contain implementation files, <code>.rei</code> files are used in the ecosystem to also document the public API of their corresponding modules.</p>
<pre><code class="hljs css reason">/* file <span class="hljs-type">React</span>.re (implementation. <span class="hljs-type">Compiles</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">module</span> <span class="hljs-type">React</span>) */
<span class="hljs-keyword">type</span> state = <span class="hljs-built_in">int</span>;
<span class="hljs-keyword">let</span> render = (str) =&gt; str;
</code></pre>
<pre><code class="hljs css reason">/* file <span class="hljs-type">React</span>.rei (interface. <span class="hljs-type">Compiles</span> <span class="hljs-keyword">to</span> signature <span class="hljs-keyword">of</span> <span class="hljs-keyword">module</span> <span class="hljs-type">React</span>) */
<span class="hljs-keyword">type</span> state = <span class="hljs-built_in">int</span>;
<span class="hljs-keyword">let</span> render: str =&gt; str;
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="fonctions-de-module-functors"></a><a href="#fonctions-de-module-functors" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fonctions de module (functors)</h2>
<p>Modules can be passed to functions! It would be the equivalent of passing a file as a first-class item. However, modules are at a different &quot;layer&quot; of the language than other common concepts, so we can't pass them to <em>regular</em> functions. Instead, we pass them to special functions called &quot;functors&quot;.</p>
<p>The syntax for defining and using functors is very much like the syntax for defining and using regular functions. The primary differences are:</p>
<ul>
<li>les functors utilisent le mot-clé <code>module</code> en lieu et place de <code>let</code></li>
<li>les functors prennent des modules en entrée et retournent des modules</li>
<li>les functors <em>requièrent</em> une annotation des arguments</li>
<li>les functors doivent débuter avec une lettre majuscule (exactement comme les modules/signatures)</li>
</ul>
<p>Here's an example <code>MakeSet</code> functor, that takes in a module of the type <code>Comparable</code> and returns a new set that can contain such comparable items.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">module</span> type Comparable = {
  <span class="hljs-keyword">type</span> t;
  <span class="hljs-keyword">let</span> equal: <span class="hljs-function">(<span class="hljs-params">t, t</span>) =&gt;</span> bool;
};

<span class="hljs-keyword">module</span> MakeSet = (Item: Comparable) =&gt; {
  <span class="hljs-comment">/* utilisons une liste comme notre structure de données de support naïve */</span>
  <span class="hljs-keyword">type</span> backingType = list(Item.t);
  <span class="hljs-keyword">let</span> empty = [];
  <span class="hljs-keyword">let</span> add = (currentSet: backingType, newItem: Item.t) : <span class="hljs-function"><span class="hljs-params">backingType</span> =&gt;</span>
    <span class="hljs-comment">/* si item existe */</span>
    <span class="hljs-keyword">if</span> (List.exists(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> Item.equal(x, newItem), currentSet)) {
      currentSet <span class="hljs-comment">/* retourne le même ensemble immutable (une list en réalité) */</span>
    } <span class="hljs-keyword">else</span> {
      [
        newItem,
        ...currentSet <span class="hljs-comment">/* prepend l'ensemble et le retourne */</span>
      ]
    };
};
</code></pre>
<p>Functors can be applied using function application syntax. In this case, we're creating a set, whose items are pairs of integers.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">module</span> IntPair = {
  <span class="hljs-keyword">type</span> t = (int, int);
  <span class="hljs-keyword">let</span> equal = <span class="hljs-function">(<span class="hljs-params">(<span class="hljs-params">x1, y1</span>), (<span class="hljs-params">x2, y2</span>)</span>) =&gt;</span> x1 == x2 &amp;&amp; y1 == y2;
  <span class="hljs-keyword">let</span> create = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> (x, y);
};

<span class="hljs-comment">/* IntPair respecte la signature Comparable requise par MakeSet */</span>
<span class="hljs-keyword">module</span> SetOfIntPairs = MakeSet(IntPair);
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="types-de-fonctions-de-module"></a><a href="#types-de-fonctions-de-module" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Types de fonctions de module</h3>
<p>Like with module types, functor types also act to constrain and hide what we may assume about functors. The syntax for functor types are consistent with those for function types, but with types capitalized to represent the signatures of modules the functor accepts as arguments and return values. In the previous example, we're exposing the backing type of a set; by giving <code>MakeSet</code> a functor signature, we can hide the underlying data structure!</p>
<pre><code class="hljs css reason">module<span class="hljs-built_in"> type </span>Comparable = <span class="hljs-built_in">..</span>.

module<span class="hljs-built_in"> type </span>MakeSetType = (Item: Comparable) =&gt; {
 <span class="hljs-built_in"> type </span>backingType;
  let empty: backingType;
  let add: (backingType, Item.t) =&gt; backingType;
};

module MakeSet: MakeSetType = (Item: Comparable) =&gt; {
  <span class="hljs-built_in">..</span>.
};
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="desavantages"></a><a href="#desavantages" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Désavantages</h2>
<p>Modules and functors are at a different &quot;layer&quot; of language than the rest ( functions, let bindings, data structures, etc.). For example, you can't easily pass them into a tuple or record. Use them judiciously! Lots of times, just a record or a function is enough.</p>
<pre><code class="hljs css reason">module <span class="hljs-type">School</span> = <span class="hljs-meta">{...}</span>;

/* ceci va directement vous donner une erreur de syntaxe ! */
<span class="hljs-keyword">let</span> schools = (<span class="hljs-type">School</span>, <span class="hljs-type">School</span>);
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="object.html">← Objet</a><a class="docs-next button" href="promise.html">Promise →</a></div></div></div></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react'
              });
            </script></body></html>