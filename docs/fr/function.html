<!DOCTYPE html><html lang="fr"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Function · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="*Antisèche pour la syntaxe complète des fonctions à la fin*"/><meta name="docsearch:language" content="fr"/><meta property="og:title" content="Function · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/index.html"/><meta property="og:description" content="*Antisèche pour la syntaxe complète des fonctions à la fin*"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/fr"><img class="logo" src="/img/dummy.svg" alt="Reason"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/fr/what-and-why" target="_self">Docs</a></li><li class=""><a href="/fr/try" target="_self">Try</a></li><li class=""><a href="/api/index" target="_self">API</a></li><li class=""><a href="/docs/fr/community" target="_self">Community</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>Français</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/ja/function">日本語</a></li><li><a href="/docs/en/function">English</a></li><li><a href="/docs/de/function">Deutsch</a></li><li><a href="/docs/es-ES/function">Español</a></li><li><a href="/docs/ko/function">한국어</a></li><li><a href="/docs/pt-BR/function">Português (Brasil)</a></li><li><a href="/docs/ru/function">Русский</a></li><li><a href="/docs/uk/function">Українська</a></li><li><a href="/docs/zh-CN/function">中文</a></li><li><a href="/docs/zh-TW/function">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank" rel="noreferrer noopener">Aider à la traduction</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Language Basics</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Intro</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/what-and-why">What &amp; Why</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Setup</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/installation">Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/editor-plugins">Editor Plugins</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/extra-goodies">Extra Goodies</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Language Basics</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/let-binding">Let Binding</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/type">Type!</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/string-and-char">String &amp; Char</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/boolean">Boolean</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/integer-and-float">Integer &amp; Float</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/tuple">Tuple</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/record">Record</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/variant">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/null-undefined-option">Null, Undefined &amp; Option</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/list-and-array">List &amp; Array</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/fr/function">Function</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/if-else">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/fast-pipe">Fast Pipe</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/more-on-type">More on Type</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/destructuring">Destructuring</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/pattern-matching">Pattern Matching!</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/mutation">Mutation</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/imperative-loops">Imperative Loops</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/jsx">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/external">External</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/exception">Exception</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/object">Object</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/module">Module</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/promise">Promise</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">JavaScript</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/interop">Interop</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/syntax-cheatsheet">Syntax Cheatsheet</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/libraries">Libraries</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/converting-from-js">Converting from JS</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Native</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/native">Native</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/quickstart-ocaml">Quickstart</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/convert-from-ocaml">Converting from OCaml</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Extra</h3><ul><li class="navListItem"><a class="navItem" href="/docs/fr/faq">Frequently Asked Questions</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/comparison-to-ocaml">Comparison to OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/newcomer-examples">Newcomer Examples</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/project-structure">Project Structure</a></li></ul></div></div></section></div><script>
            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docMainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/fr" target="_blank" rel="noreferrer noopener">Translate</a><h1 class="postHeaderTitle">Function</h1></header><article><div><span><p><em>Antisèche pour la syntaxe complète des fonctions à la fin</em></p>
<p>Nous n'avons pas encore parlé des fonctions jusqu'ici, incroyable non ?</p>
<p>Les fonctions sont déclarées avec une flèche et renvoient l'expression.</p>
<pre><code class="hljs css language-reason">let greet = <span class="hljs-function"><span class="hljs-params">(name)</span> =&gt;</span> <span class="hljs-string">"Hello "</span> ++ name;
</code></pre>
<p>Ceci déclare un fonction et lui assigne le nom <code>greet</code>, que vous pouvez appeler comme ceci :</p>
<pre><code class="hljs css language-reason"><span class="hljs-selector-tag">greet</span>(<span class="hljs-string">"world!"</span>); <span class="hljs-comment">/* "Hello world!" */</span>
</code></pre>
<p>Quand une fonction prend plusieurs arguments, ceux-ci sont séparés par une virgule :</p>
<pre><code class="hljs css language-reason">let <span class="hljs-keyword">add</span><span class="bash"> = (x, y, z) =&gt; x + y + z;
</span><span class="hljs-keyword">add</span><span class="bash">(1, 2, 3); /* 6 */
</span></code></pre>
<p>On met le corps de fonctions plus longues a l'intérieur d'un bloc :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> greetMore = <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> {
  <span class="hljs-keyword">let</span> part1 = <span class="hljs-string">"Hello"</span>;
  part1 ++ <span class="hljs-string">" "</span> ++ name
};
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="aucun-argument"></a><a href="#aucun-argument" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Aucun argument</h2>
<p>Une fonction prends toujours un argument; cependant, parfois, on utilise des fonctions pour leurs <em>effets de bord</em>, et nous n'avons dans ce cas aucun argument a leur passer. Dans d'autres langages, on ne donnerait &quot;aucun argument&quot;. En Reason, toute fonction prend au moins un argument; conventionnellement, on passe dans ce cas la valeur <code>()</code>, appelée &quot;unit&quot;.</p>
<pre><code class="hljs css language-reason">/* reçoit &amp; destructure l'argument <span class="hljs-string">"unit"</span> */
<span class="hljs-keyword">let</span> logSomething = <span class="hljs-literal">()</span> =&gt; {
  print_endline(<span class="hljs-string">"hello"</span>);
  print_endline(<span class="hljs-string">"world"</span>)
};

/* appelle la fonction avec la valeur de <span class="hljs-keyword">type</span> <span class="hljs-string">"unit"</span> */
logSomething<span class="hljs-literal">()</span>;
</code></pre>
<p><code>()</code> est une valeur tout a fait normale, la seule valeur de type <code>unit</code>. Reason lui donne une syntaxe spéciale par commodité.</p>
<h2><a class="anchor" aria-hidden="true" id="arguments-labellises"></a><a href="#arguments-labellises" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Arguments labellisés</h2>
<p>Les fonctions multi-arguments, en particulier celles dont les arguments sont du même type, peuvent être source de confusion lors des appels.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> addCoordinates = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> {
  <span class="hljs-comment">/* use x and y here */</span>
};
<span class="hljs-comment">/* ... */</span>
addCoordinates(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>); <span class="hljs-comment">/* which is x, which is y? */</span>
</code></pre>
<p>En OCaml/Reason, vous pouvez attacher des labels à un argument en préfixant le nom avec le symbole <code>~</code> :</p>
<pre><code class="hljs css language-reason">let <span class="hljs-keyword">addCoordinates </span>= (~x, ~y) =&gt; {
  <span class="hljs-comment">/* use x and y here */</span>
}<span class="hljs-comment">;</span>
<span class="hljs-comment">/* ... */</span>
<span class="hljs-keyword">addCoordinates(~x=5, </span>~y=<span class="hljs-number">6</span>)<span class="hljs-comment">;</span>
</code></pre>
<p>Étant donné que nous avons la curryfication (plus à ce sujet ci-dessous), nous pouvons fournir les arguments <strong>dans n'importe quel ordre</strong> :</p>
<pre><code class="hljs css language-reason">addCoordinates(~<span class="hljs-attribute">y</span>=6, ~<span class="hljs-attribute">x</span>=5);
</code></pre>
<p>La partie <code>~x</code> de la déclaration signifie que la fonction accepte un argument avec le label <code>x</code>, et peut y référer dans le corps de la fonction avec le même nom. Vous pouvez également faire référence aux arguments dans le corps de la fonction par un nom différent, par soucis de concision :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> drawCircle = <span class="hljs-function">(<span class="hljs-params">~radius <span class="hljs-keyword">as</span> r, ~color <span class="hljs-keyword">as</span> c</span>) =&gt;</span> {
  setColor(c);
  startAt(r, r);
  <span class="hljs-comment">/* ... */</span>
};

drawCircle(~radius=<span class="hljs-number">10</span>, ~color=<span class="hljs-string">"red"</span>);
</code></pre>
<p>En effet, <code>(~radius)</code> est juste un raccourci (appelé <strong>punning</strong>) pour <code>(~radius as radius)</code>.</p>
<p>Voici la syntaxe pour typer des arguements :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> drawCircle = (~radius <span class="hljs-keyword">as</span> r: <span class="hljs-built_in">int</span>, ~color <span class="hljs-keyword">as</span> c: <span class="hljs-built_in">string</span>) =&gt; ...;
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="curryfication"></a><a href="#curryfication" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Curryfication</h3>
<p>Les fonctions Reason peuvent être automatiquement appelées <strong>en partie</strong> :</p>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">let add</span> = (x, y) =&gt; x + y;
<span class="hljs-attribute">let addFive</span> = add(5);
<span class="hljs-attribute">let eleven</span> = addFive(6);
<span class="hljs-attribute">let twelve</span> = addFive(7);
</code></pre>
<p>En fait, le <code>add</code> ci-dessus n'est rien d'autre que du <em>sucre syntaxique</em> pour :</p>
<pre><code class="hljs css language-reason">let add = (<span class="hljs-name">x</span>) =&gt; (<span class="hljs-name">y</span>) =&gt; x + y<span class="hljs-comment">;</span>
</code></pre>
<p>OCaml optimise ceci pour <a href="/try/?reason=DYUwLgBAhgJjEF4IAoAeBKRA+FBPTCOqEA1BLgNwBQVA9AFQTAD2zA1tJGABYgTMBXMAAchAQmhwAYgEsAbnxkBnaBAD6SmQDsA5qDUQAZgK0BjMDOZaIpqMGAT6tKqEiwYshYkkxkAVnRqF3AITWIkd08QZABGQKA">éviter l'allocation inutile de fonctions</a> (2 fonctions ici) chaque fois qu'il le peut ! De cette façon, nous obtenons</p>
<ul>
<li>une belle syntaxe</li>
<li>la curryfication sans effort supplémentaire (chaque fonction prend un seul argument, en fait !)</li>
<li>aucun coût de performance</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="arguments-labellises-optionnels"></a><a href="#arguments-labellises-optionnels" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Arguments labellisés optionnels</h2>
<p>Les arguments labellisés d'une fonction peuvent être rendus facultatifs lors de sa déclaration. Vous pouvez ensuite les omettre lors de l'appel de la fonction.</p>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* radius est facultatif */</span>
<span class="hljs-keyword">let</span> drawCircle = <span class="hljs-function">(<span class="hljs-params">~color, ~radius=?, (<span class="hljs-params"></span>)</span>) =&gt;</span> {
  setColor(color);
  <span class="hljs-keyword">switch</span> (radius) {
  | <span class="hljs-function"><span class="hljs-params">None</span> =&gt;</span> startAt(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)
  | Some(r_) =&gt; startAt(r_, r_)
  }
};
</code></pre>
<p>Lorsqu'il est fourni dans cette syntaxe, <code>radius</code> est <strong>englobé</strong> dans le type <code>option</code> de la librairie standard, qui vaut par défaut <code>None</code>. S'il est fourni, <code>radius</code> sera enveloppé d'un <code>Some</code>. Donc la valeur du type de <code>radius</code> vaut soit <code>None</code> soit <code>Some int</code> ici.</p>
<p><strong>Note</strong> : <code>None | Some(foo)</code> est un type de structure de données appelé variant et est décrit <a href="/docs/fr/variant">en amont</a>. Ce type de variant particulier est fourni par la librairie standard. C'est ce qu'ont appelle l'<code>option</code>. Sa définition ressemble à : <code>type option('a) = None | Some('a)</code>.</p>
<p><strong>Notez</strong> l'unit <code>()</code> à la fin de <code>drawCircle</code>. Sans ça, vu que <code>radius</code> et <code>color</code> sont tous deux labellisés, peuvent être curryfiés, et peuvent être appliqués sans ordre spécifique, il n'est pas évident de comprendre ce que siginifie :</p>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">let whatIsThis</span> = drawCircle(~color);
</code></pre>
<p>Est-ce que <code>whatIsThis</code> est une fonction <code>drawCircle</code> curryfiée, qui attend que l'argument optionnel <code>radius</code> soit appliqué ? Ou bien a-t-il fini de s'appliquer ? Pour résoudre cette confusion, ajoutez un argument positionnel (aka non-labellisé) à <code>drawCircle</code> (par convention <code>()</code>), et OCaml, en règle générale, supposera que l'argument marqué optionnel est omis lorsque l'argument positionnel est fourni.</p>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">let curriedFunction</span> = drawCircle(~color);
<span class="hljs-attribute">let actualResultWithoutProvidingRadius</span> = drawCircle(~color, ());
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="optionnel-passe-explicitement"></a><a href="#optionnel-passe-explicitement" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Optionnel passé explicitement</h3>
<p>Parfois, vous pouvez vouloir transférer une valeur à une fonction sans savoir si la valeur est <code>None</code> ou <code>Some a</code>. Naïvement, vous feriez :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> result =
  switch (payloadRadius) {
  | <span class="hljs-type">None</span> =&gt; drawCircle(~color, ())
  | <span class="hljs-type">Some</span>(r) =&gt; drawCircle(~color, ~radius=r, ())
  };
</code></pre>
<p>Cela devient rapidement fastidieux. Nous fournissons un raccourci :</p>
<pre><code class="hljs css language-reason"><span class="hljs-built_in">let</span> result = drawCircle(~<span class="hljs-built_in">color</span>, ~<span class="hljs-built_in">radius</span>=?payloadRadius, ());
</code></pre>
<p>Ceci signifie &quot;Je comprends que <code>radius</code> est optionnel, et que lorsque je lui passe une valeur, il doit s'agir d'un <code>int</code>. Mais je ne sais pas si la valeur que je passe est <code>None</code> ou <code>Some(val)</code>, alors je vais passer toute le wrapper <code>option</code>&quot;.</p>
<h3><a class="anchor" aria-hidden="true" id="optionnel-avec-valeur-par-defaut"></a><a href="#optionnel-avec-valeur-par-defaut" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Optionnel avec valeur par défaut</h3>
<p>Il est aussi possible de définir une valeur par défaut pour les arguments labellisés optionnels. Dans ce cas, ils ne sont pas englobés dans un type <code>option</code>.</p>
<pre><code class="hljs css language-reason"><span class="hljs-built_in">let</span> drawCircle = (~<span class="hljs-built_in">radius</span>=<span class="hljs-number">1</span>, ~<span class="hljs-built_in">color</span>, ()) =&gt; {
  setColor(<span class="hljs-built_in">color</span>);
  startAt(<span class="hljs-built_in">radius</span>, <span class="hljs-built_in">radius</span>)
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="fonctions-recursives"></a><a href="#fonctions-recursives" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fonctions récursives</h3>
<p>Par défaut, un valeure ne peut pas voir un binding qui pointe sur elle, mais on peut rendre cela possible en incluant le mot-clé <code>rec</code> dans un binding <code>let</code>. Cela permet aux fonctions de pouvoir accéder à elles-mêmes et de s'appeler, nous donnant ainsi le Pouvoir de la Récursivité.</p>
<pre><code class="hljs css language-reason">let rec neverTerminate = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> neverTerminate();
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="fonctions-mutuellement-recursives"></a><a href="#fonctions-mutuellement-recursives" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Fonctions mutuellement récursives</h3>
<p>Les fonctions mutuellement récursives commencent comme un simple fonction récursive en utilisant le mot-clé <code>rec</code>, et sont chaînées avec <code>and</code> :</p>
<pre><code class="hljs css language-reason">let rec callSecond = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> callFirst()
<span class="hljs-keyword">and</span> callFirst = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> callSecond();
</code></pre>
<p><strong>Notez</strong> qu'il n'y a aucun point-virgule à la fin de la première ligne, ni de <code>let</code> à la seconde.</p>
<h2><a class="anchor" aria-hidden="true" id="conseils-astuces"></a><a href="#conseils-astuces" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conseils &amp; astuces</h2>
<p>Antisèche pour la syntaxe complète des fonctions à la fin :</p>
<h3><a class="anchor" aria-hidden="true" id="declaration"></a><a href="#declaration" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Déclaration</h3>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* fonction anonyme. Listé uniquement par soucis d'exhaustivité */</span>
(x) =&gt; <span class="hljs-function">(<span class="hljs-params">y</span>) =&gt;</span> <span class="hljs-number">1</span>;
<span class="hljs-comment">/* sucre syntaxique de la version ci-dessus */</span>
(x, y) =&gt; <span class="hljs-number">1</span>;
<span class="hljs-comment">/* assigner à un nom */</span>
<span class="hljs-keyword">let</span> add = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> <span class="hljs-number">1</span>;

<span class="hljs-comment">/* avec labels */</span>
<span class="hljs-keyword">let</span> add = <span class="hljs-function">(<span class="hljs-params">~first <span class="hljs-keyword">as</span> x, ~second <span class="hljs-keyword">as</span> y</span>) =&gt;</span> x + y;
<span class="hljs-comment">/* avec sucre syntaxique pour le punning */</span>
<span class="hljs-keyword">let</span> add = <span class="hljs-function">(<span class="hljs-params">~first, ~second</span>) =&gt;</span> first + second;

<span class="hljs-comment">/* labels avec valeur par défaut */</span>
<span class="hljs-keyword">let</span> add = <span class="hljs-function">(<span class="hljs-params">~first <span class="hljs-keyword">as</span> x=<span class="hljs-number">1</span>, ~second <span class="hljs-keyword">as</span> y=<span class="hljs-number">2</span></span>) =&gt;</span> x + y;
<span class="hljs-comment">/* avec le punning */</span>
<span class="hljs-keyword">let</span> add = <span class="hljs-function">(<span class="hljs-params">~first=<span class="hljs-number">1</span>, ~second=<span class="hljs-number">2</span></span>) =&gt;</span> first + second;

<span class="hljs-comment">/* optionnel */</span>
<span class="hljs-keyword">let</span> add = <span class="hljs-function">(<span class="hljs-params">~first <span class="hljs-keyword">as</span> x=?, ~second <span class="hljs-keyword">as</span> y=?</span>) =&gt;</span> <span class="hljs-keyword">switch</span> x {...};
<span class="hljs-comment">/* avec le punning */</span>
<span class="hljs-keyword">let</span> add = <span class="hljs-function">(<span class="hljs-params">~first=?, ~second=?</span>) =&gt;</span> <span class="hljs-keyword">switch</span> first {...};&gt;
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="avec-annotation-de-type"></a><a href="#avec-annotation-de-type" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Avec annotation de type</h4>
<pre><code class="hljs css language-reason">/* fonction anonyme */
(x: <span class="hljs-built_in">int</span>) =&gt; (y: <span class="hljs-built_in">int</span>): <span class="hljs-built_in">int</span> =&gt; <span class="hljs-number">1</span>;
/* sucre syntaxique de la version ci-dessus */
(x: <span class="hljs-built_in">int</span>, y: <span class="hljs-built_in">int</span>): <span class="hljs-built_in">int</span> =&gt; <span class="hljs-number">1</span>;
/* assigner à un nom */
<span class="hljs-keyword">let</span> add = (x: <span class="hljs-built_in">int</span>, y: <span class="hljs-built_in">int</span>): <span class="hljs-built_in">int</span> =&gt; <span class="hljs-number">1</span>;

/* avec labels */
<span class="hljs-keyword">let</span> add = (~first <span class="hljs-keyword">as</span> x: <span class="hljs-built_in">int</span>, ~second <span class="hljs-keyword">as</span> y: <span class="hljs-built_in">int</span>) : <span class="hljs-built_in">int</span> =&gt; x + y;

/* labels avec valeur par défaut */
<span class="hljs-keyword">let</span> add = (~first <span class="hljs-keyword">as</span> x: <span class="hljs-built_in">int</span>=<span class="hljs-number">1</span>, ~second <span class="hljs-keyword">as</span> y: <span class="hljs-built_in">int</span>=<span class="hljs-number">2</span>) : <span class="hljs-built_in">int</span> =&gt; x + y;

/* optionnel */
<span class="hljs-keyword">let</span> add = (~first <span class="hljs-keyword">as</span> x: option(<span class="hljs-built_in">int</span>)=?, ~second <span class="hljs-keyword">as</span> y: option(<span class="hljs-built_in">int</span>)=?) : <span class="hljs-built_in">int</span> =&gt; switch x <span class="hljs-meta">{...}</span>;
/* avec sucre syntaxique pour le punning */
/* notez que l'appelant passerait un `<span class="hljs-built_in">int</span>` et non `option <span class="hljs-built_in">int</span>` */
/* À l'<span class="hljs-built_in">int</span>érieur de la fonction, `first` et `second` sont des `option <span class="hljs-built_in">int</span>`. */
<span class="hljs-keyword">let</span> add = (~first: option(<span class="hljs-built_in">int</span>)=?, ~second: option(<span class="hljs-built_in">int</span>)=?) : <span class="hljs-built_in">int</span> =&gt; switch first <span class="hljs-meta">{...}</span>;
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="appel"></a><a href="#appel" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Appel</h3>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* appel anonyme. Listé uniquement par soucis d'exhaustivité */</span>
<span class="hljs-keyword">add(x)(y);
</span>
<span class="hljs-comment">/* sucre syntaxique de la version ci-dessus. */</span>
<span class="hljs-keyword">add(x, </span>y)<span class="hljs-comment">;</span>

<span class="hljs-comment">/* avec labels */</span>
<span class="hljs-keyword">add(~first=1, </span>~second=<span class="hljs-number">2</span>)<span class="hljs-comment">;</span>

<span class="hljs-comment">/* avec sucre syntaxique pour le punning */</span>
<span class="hljs-keyword">add(~first, </span>~second)<span class="hljs-comment">;</span>

<span class="hljs-comment">/* appel avec valeur par défaut. Pareil qu'un appel normal */</span>
<span class="hljs-keyword">add(~first=1, </span>~second=<span class="hljs-number">2</span>)<span class="hljs-comment">;</span>

<span class="hljs-comment">/* appel avec optionnel explicite */</span>
<span class="hljs-keyword">add(~first=?Some(1), </span>~second=?Some(<span class="hljs-number">2</span>))<span class="hljs-comment">;</span>

<span class="hljs-comment">/* avec le punning */</span>
<span class="hljs-keyword">add(~first?, </span>~second?)<span class="hljs-comment">;</span>
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="avec-annotation-de-type-1"></a><a href="#avec-annotation-de-type-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Avec annotation de type</h4>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* appel anonyme */</span>
<span class="hljs-built_in">add</span>(x: <span class="hljs-built_in">int</span>)(y: <span class="hljs-built_in">int</span>);

<span class="hljs-comment">/* avec labels */</span>
<span class="hljs-built_in">add</span>(~first=<span class="hljs-number">1</span>: <span class="hljs-built_in">int</span>, ~<span class="hljs-built_in">second</span>=<span class="hljs-number">2</span>: <span class="hljs-built_in">int</span>);

<span class="hljs-comment">/* avec sucre syntaxique pour le punning */</span>
<span class="hljs-built_in">add</span>(~first: <span class="hljs-built_in">int</span>, ~<span class="hljs-built_in">second</span>: <span class="hljs-built_in">int</span>);

<span class="hljs-comment">/* appel avec valeur par défaut. Pareil qu'un appel normal */</span>
<span class="hljs-built_in">add</span>(~first=<span class="hljs-number">1</span>: <span class="hljs-built_in">int</span>, ~<span class="hljs-built_in">second</span>=<span class="hljs-number">2</span>: <span class="hljs-built_in">int</span>);

<span class="hljs-comment">/* appel avec optionnel explicite */</span>
<span class="hljs-built_in">add</span>(~first=?Some(<span class="hljs-number">1</span>): option(<span class="hljs-built_in">int</span>), ~<span class="hljs-built_in">second</span>=?Some(<span class="hljs-number">2</span>): option(<span class="hljs-built_in">int</span>));

<span class="hljs-comment">/* avec sucre syntaxique pour le punning */</span>
 +<span class="hljs-built_in">add</span>(~first: option(<span class="hljs-built_in">int</span>)?, ~<span class="hljs-built_in">second</span>: option(<span class="hljs-built_in">int</span>)?);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="signature-de-type-autonome"></a><a href="#signature-de-type-autonome" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Signature de type autonome</h3>
<pre><code class="hljs css language-reason">/* premier argument de <span class="hljs-keyword">type</span>, second argument de <span class="hljs-keyword">type</span>, <span class="hljs-keyword">type</span> retourné */
<span class="hljs-keyword">type</span> foo = <span class="hljs-built_in">int</span> =&gt; <span class="hljs-built_in">int</span> =&gt; <span class="hljs-built_in">int</span>;
/* sucre syntaxique de la version ci-dessus */
<span class="hljs-keyword">type</span> foo = (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>) =&gt; <span class="hljs-built_in">int</span>;

/* avec labels */
<span class="hljs-keyword">type</span> foo = (~first: <span class="hljs-built_in">int</span>, ~second: <span class="hljs-built_in">int</span>) =&gt; <span class="hljs-built_in">int</span>;

/* avec labels */
<span class="hljs-keyword">type</span> foo = (~first: <span class="hljs-built_in">int</span>=?, ~second: <span class="hljs-built_in">int</span>=?, <span class="hljs-built_in">unit</span>) =&gt; <span class="hljs-built_in">int</span>;
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="dans-les-fichiers-d-interface"></a><a href="#dans-les-fichiers-d-interface" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dans les fichiers d'interface</h4>
<p>Pour annoter une fonction à partir du fichier d'implémentation (<code>.re</code>) :</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> add: <span class="hljs-keyword">int</span> =&gt; <span class="hljs-keyword">int</span> =&gt; <span class="hljs-keyword">int</span>;
<span class="hljs-comment">/* sucre syntaxique de la version ci-dessus */</span>
<span class="hljs-keyword">let</span> add: (<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>) =&gt; <span class="hljs-keyword">int</span>;
</code></pre>
<p>Mêmes règles que la section précédente, à l'exception du remplacement de <code>type foo = bar</code> par <code>let add: bar</code>.</p>
<p><strong>Ne confondez pas</strong> ceci avec une exportation réelle d'un type dans le fichier d'interface. <code>let add: bar</code> annote un valeur <code>bar</code> existante depuis le fichier d'implémentation. <code>type foo = bar</code> exporte un type de même forme à partir du fichier d'implémentation.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/fr/list-and-array"><span class="arrow-prev">← </span><span>Précédent</span></a><a class="docs-next button" href="/docs/fr/if-else"><span>Suivant</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav docOnPageNav"><ul class="toc-headings"><li><a href="#aucun-argument">Aucun argument</a></li><li><a href="#arguments-labellises">Arguments labellisés</a><ul class="toc-headings"><li><a href="#curryfication">Curryfication</a></li></ul></li><li><a href="#arguments-labellises-optionnels">Arguments labellisés optionnels</a><ul class="toc-headings"><li><a href="#optionnel-passe-explicitement">Optionnel passé explicitement</a></li><li><a href="#optionnel-avec-valeur-par-defaut">Optionnel avec valeur par défaut</a></li><li><a href="#fonctions-recursives">Fonctions récursives</a></li><li><a href="#fonctions-mutuellement-recursives">Fonctions mutuellement récursives</a></li></ul></li><li><a href="#conseils-astuces">Conseils &amp; astuces</a><ul class="toc-headings"><li><a href="#declaration">Déclaration</a></li><li><a href="#appel">Appel</a></li><li><a href="#signature-de-type-autonome">Signature de type autonome</a></li></ul></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.min.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper, .onPageNav',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:fr"]}
              });
            </script></body></html>