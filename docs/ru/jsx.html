<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>JSX · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="JSX · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/index.html"/><meta property="og:description" content="Не хотите ли немного HTML синтаксиса в вашем Reason коде? Если нет, то пропустите эту секцию!"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/arduino-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/dummy.svg"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/docs/ru/quickstart-javascript.html" target="_self">Документация</a></li><li><a href="/ru/try.html" target="_self">Попробовать</a></li><li><a href="/api/index.html" target="_self">API</a></li><li><a href="/docs/ru/community.html" target="_self">Сообщество</a></li><li><a href="/blog" target="_self">Блог</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg"/>Русский</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/ja">日本語</a></li><li><a href="/en">English</a></li><li><a href="/es-ES">Español</a></li><li><a href="/fr">Français</a></li><li><a href="/ko">한국어</a></li><li><a href="/pt-BR">Português (Brasil)</a></li><li><a href="/uk">Українська</a></li><li><a href="/zh-CN">中文</a></li><li><a href="/zh-TW">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank">Помочь с переводом</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Language Basics</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Введение</h3><ul><li class="navListItem"><a class="navItem" href="/docs/ru/what-and-why.html">Что и Зачем</a></li></ul></div><div class="navGroup navGroupActive"><h3>Настройка редактора кода</h3><ul><li class="navListItem"><a class="navItem" href="/docs/ru/global-installation.html">Глобальная установка</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/editor-plugins.html">Плагины для редактора кода</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/extra-goodies.html">Дополнительные инструменты</a></li></ul></div><div class="navGroup navGroupActive"><h3>Основы языка</h3><ul><li class="navListItem"><a class="navItem" href="/docs/ru/overview.html">Обзор</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/let-binding.html">Присваивание</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/type.html">Тип!</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/string-and-char.html">Строки и символы</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/boolean.html">Boolean</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/integer-and-float.html">Integer и Float</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/tuple.html">Кортеж</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/record.html">Запись</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/variant.html">Вариант!</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/list-and-array.html">Список и Массив</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/function.html">Function</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/if-else.html">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/more-on-type.html">Больше о типах</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/destructuring.html">Destructuring</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/pattern-matching.html">Паттерн-матчинг!</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/mutation.html">Мутации</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/imperative-loops.html">Императивные циклы</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/docs/ru/jsx.html">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/external.html">External</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/exception.html">Exception</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/object.html">Объект</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/module.html">Модуль</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/promise.html">Промисы</a></li></ul></div><div class="navGroup navGroupActive"><h3>JavaScript</h3><ul><li class="navListItem"><a class="navItem" href="/docs/ru/quickstart-javascript.html">Краткое руководство</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/interop.html">Взаимодействие</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/syntax-cheatsheet.html">Шпаргалка по синтаксису</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/libraries.html">Библиотеки</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/converting-from-js.html">Перенос JS кода</a></li></ul></div><div class="navGroup navGroupActive"><h3>Нативный</h3><ul><li class="navListItem"><a class="navItem" href="/docs/ru/native.html">Собственные процессы</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/quickstart-ocaml.html">Краткое руководство</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/convert-from-ocaml.html">Перенос из OCaml</a></li></ul></div><div class="navGroup navGroupActive"><h3>Дополнительно</h3><ul><li class="navListItem"><a class="navItem" href="/docs/ru/faq.html">Часто задаваемые вопросы</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/comparison-to-ocaml.html">Сравнение с OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/newcomer-examples.html">Примеры для начинающих</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/project-structure.html">Структура проекта</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/ru" target="_blank">Translate</a><h1>JSX</h1></header><article><div><span><p>Не хотите ли немного HTML синтаксиса в вашем Reason коде? Если нет, то пропустите эту секцию!</p>
<p>Reason поддерживает синтаксис JSX, с некоторыми отличиями от <a href="https://facebook.github.io/react/docs/introducing-jsx.html">ReactJS</a>. Reason JSX не привязан к ReactJS, он транслируется в обычные вызовы функций:</p>
<p><strong>Примечание</strong> для тех кто смотрел <a href="//reasonml.github.io/reason-react/">ReasonReact</a>: это не то как ReasonReact превращается в JSX, в конечном итоге. См. раздел Использование для получения дополнительной информации.</p>
<h2><a class="anchor" aria-hidden="true" name=""></a><a href="#" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Заглавный тег</h2>
<pre><code class="hljs css reason"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> <span class="hljs-attr">foo</span>=<span class="hljs-string">{bar}</span> /&gt;</span>
</code></pre>
<p>становится</p>
<pre><code class="hljs css reason">([<span class="hljs-name">@JSX</span>] MyComponent.make(<span class="hljs-name">~foo=bar</span>, ~children=[], ()))<span class="hljs-comment">;</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" name=""></a><a href="#" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Строчный тег</h2>
<pre><code class="hljs css reason"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">foo</span>=<span class="hljs-string">{bar}</span>&gt;</span> child1 child2 <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>;
</code></pre>
<p>становится</p>
<pre><code class="hljs css reason">([<span class="hljs-name">@JSX</span>] div(<span class="hljs-name">~foo=bar</span>, ~children=[<span class="hljs-name">child1</span>, child2], ()))<span class="hljs-comment">;</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" name=""></a><a href="#" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Потомок</h3>
<pre><code class="hljs css reason"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span>&gt;</span> foo bar <span class="hljs-tag">&lt;/<span class="hljs-name">MyComponent</span>&gt;</span>
</code></pre>
<p>Это синтаксис для передачи списка из двух пунктов, <code>foo</code> и <code>бар</code>, в состояние потомков. Он переводит их в список, содержащий <code>foo</code> и <code>bar</code>:</p>
<pre><code class="hljs css reason">([<span class="hljs-name">@JSX</span>] MyComponent.createElement(<span class="hljs-name">~children=</span>[<span class="hljs-name">foo</span>, bar], ()))<span class="hljs-comment">;</span>
</code></pre>
<p><strong>Примечание</strong> это не преобразование для ReasonReact; ReasonReact превращает итоговый список в массив. Но смысл остается такой же.</p>
<p>Поэтому, <code>&lt;MyComponent&gt; foo &lt;/MyComponent&gt;</code> это тоже самое, что и <code>([@JSX] MyComponent.createElement(~children=[foo], ()))</code>. Т.е. все аргументы, которые вы передаете через потомков, будут обернуты в список. Что делать, если вам это не требуется? <strong>Что делать, если вы хотите передать непосредственно <code>foo</code> без дополнительной обертки</strong>?</p>
<h4><a class="anchor" aria-hidden="true" name=""></a><a href="#" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Спред дочерних элементов</h4>
<p>Для решения вышеуказанных проблем, мы ввели</p>
<pre><code class="hljs css reason"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span>&gt;</span> ...foo <span class="hljs-tag">&lt;/<span class="hljs-name">MyComponent</span>&gt;</span>
</code></pre>
<p>Это передаст значение <code>foo</code> <em>без</em> обертки в список (или массив, в случае ReasonReact). Также, это является лексической заменой для:</p>
<pre><code class="hljs css reason">([<span class="hljs-name">@JSX</span>] MyComponent.createElement(<span class="hljs-name">~children=foo</span>, ()))<span class="hljs-comment">;</span>
</code></pre>
<p>Это очень полезно в тех случаях, когда вы передаете <code>foo</code> уже как список, и не хотите оборачивать его еще раз (что может вызвать ошибку типа) \ *. Так же это позволяет вам передавать произвольные структуры данных в <code>children</code> (помните, JSX <code>children</code> это совершенно обычное свойство):</p>
<pre><code class="hljs css reason"><span class="hljs-params">&lt;MyComponent&gt;</span> ...((theClassName) =&gt; <span class="hljs-params">&lt;div className=theClassName /&gt;</span>) <span class="hljs-params">&lt;/MyComponent&gt;</span>;
<span class="hljs-params">&lt;MyForm&gt;</span> ...(<span class="hljs-string">"Hello"</span>, <span class="hljs-string">"Submit"</span>) <span class="hljs-params">&lt;/MyForm&gt;</span>;
</code></pre>
<h2><a class="anchor" aria-hidden="true" name=""></a><a href="#" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Использование</h2>
<p>Посмотрите <a href="//reasonml.github.io/reason-react/docs/jsx"> ReasonReact</a> как пример приложения JSX, который превращает вышеуказанные вызовы в характерные для ReasonReact.</p>
<p>Вот JSX тег показывающей большую часть фич.</p>
<pre><code class="hljs css reason"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span>
  <span class="hljs-attr">booleanAttribute</span>=</span></span><span class="hljs-template-variable">{true}</span><span class="xml"><span class="hljs-tag">
  <span class="hljs-attr">stringAttribute</span>=<span class="hljs-string">"string"</span>
  <span class="hljs-attr">intAttribute</span>=<span class="hljs-string">1</span>
  <span class="hljs-attr">forcedOptional</span>=<span class="hljs-string">?</span></span></span><span class="hljs-template-variable">{Some("hello")}</span><span class="xml"><span class="hljs-tag">
  <span class="hljs-attr">onClick</span>=</span></span><span class="hljs-template-variable">{send(handleClick)}</span><span class="xml"><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> </span><span class="hljs-template-variable">{ReasonReact.stringToElement("hello")}</span><span class="xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">MyComponent</span>&gt;</span>
</span></code></pre>
<h2><a class="anchor" aria-hidden="true" name="js-jsx"></a><a href="#js-jsx" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Отличия от JS JSX</h2>
<ul>
<li>Атрибуты и потомки не заключаются в <code>{}</code>, но мы показываем их в любом случае для удобства обучения. Когда вы <code>refmt</code> ваш файл, некоторые из них убираются, а некоторые превращаются в скобки.</li>
<li>Отсутствует поддержка спреда свойств как в JSX: <code>&lt;Foo {...bar} /&gt;</code>. Хотя есть кое-что похожее, у нас есть спред потомков, описанный выше: <code>&lt;Foo&gt; ...baz &lt;/Foo&gt;</code>.</li>
<li>Короткие свойства!</li>
</ul>
<h3><a class="anchor" aria-hidden="true" name=""></a><a href="#" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Короткое свойство</h3>
<p>«Короткое свойство» используется для сокращенного синтаксиса, когда наименование значения и имя свойства совпадают. Например, в JavaScript, вместо <code>return {name: name}</code>, вы можете написать <code>return {name}</code>.</p>
<p>Reason JSX поддерживает короткие свойства. <code>&lt;input checked /&gt;</code> будет сокращением для <code>&lt;input checked=checked /&gt;</code>. Модуль форматирования будет подсказывать вам, когда это возможно. Это удобно в случаях, когда есть много параметров которые вам необходимо передать:</p>
<pre><code class="hljs css reason"><span class="hljs-section">&lt;MyComponent isLoading text onClick /&gt;</span>
</code></pre>
<p>В результате, в Reason JSX компонент можно втиснуть больше параметров до того момента, когда необходимо использовать дополнительные решения во избежания передачи параметров напрямую.</p>
<p><strong>Обратите внимание</strong>, что это представляет собой отход от ReactJS JSX, который <strong>не</strong> имеет короткие свойства. ReactJS' <code>&lt;input checked /&gt;</code> преобразует в <code>&lt;input checked=true /&gt;</code>, для того, чтобы соответствовать идиомам DOM, а также для обратной совместимости.</p>
<h2><a class="anchor" aria-hidden="true" name=""></a><a href="#" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Советы и трюки</h2>
<p>Для авторов библиотек, желающих воспользоваться преимуществами JSX: <code>[@JSX]</code> этот атрибут который дает возможность для ppx макросов определить функцию в таком формате как JSX. Как только вы определите функцию, вы можете превратить её в любое другое выражение.</p>
<p>Таки образом все могут получить профит от использования JSX без необходимости зависеть от конкретной библиотеки, например ReasonReact.</p>
<p>JSX поддерживает <a href="/docs/ru/function.html#labeled-arguments">именованые аргументы</a>: опциональные и аргументы по умолчанию.</p>
<h2><a class="anchor" aria-hidden="true" name=""></a><a href="#" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Дизайн решения</h2>
<p>The way we designed this JSX is related to how we'd like to help the language evolve. See the section &quot;What's the point?&quot; in <a href="https://medium.com/@chenglou/cool-things-reason-formatter-does-9e1f79e25a82">this blog post</a>.</p>
<p>The ability to have macros in the language + the library-agnostic JSX syntax allows every library to potentially have JSX without hassle. This way, we add some visual familiarities to the underlying OCaml language without compromising on its semantics (aka how it executes). One big goal of Reason is to let more folks take advantage of the beautiful language that is OCaml, while discarding the time-consuming debates around syntax and formatting.</p>
<p>* You might wonder why you never needed such children spread in ReactJS; ReactJS uses some special runtime logic + special syntax transforms + variadic argument detection &amp; marking to avoid most of these cases (<a href="https://github.com/facebook/react/blob/9b36df86c6ccecb73ca44899386e6a72a83ad445/packages/react/src/ReactElement.js#L207">see here</a>). Such dynamic usage complexifies the type system detection <em>quite a bit</em>. Since we control the whole syntax and ReasonReact, we decided to introduce children spread to disambiguate between the case of wrapping vs not wrapping, without compile-time &amp; runtime cost!</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="imperative-loops.html">← Императивные циклы</a><a class="docs-next button" href="external.html">External →</a></div></div></div></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react'
              });
            </script></body></html>