<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>¡Variante! · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="¡Variante! · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/index.html"/><meta property="og:description" content="¡He aquí, la joya de la corona de las estructuras de datos de Reason!"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/arduino-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/dummy.svg"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/docs/es-ES/quickstart-javascript.html" target="_self">Documentación</a></li><li><a href="/es-ES/try.html" target="_self">Pruebalo</a></li><li><a href="/api/index.html" target="_self">API</a></li><li><a href="/docs/es-ES/community.html" target="_self">Comunidad</a></li><li><a href="/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg"/>Español</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/ja">日本語</a></li><li><a href="/en">English</a></li><li><a href="/fr">Français</a></li><li><a href="/ko">한국어</a></li><li><a href="/pt-BR">Português (Brasil)</a></li><li><a href="/ru">Русский</a></li><li><a href="/uk">Українська</a></li><li><a href="/zh-CN">中文</a></li><li><a href="/zh-TW">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank">Ayuda a traducir</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Language Basics</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Intro</h3><ul><li class="navListItem"><a class="navItem" href="/docs/es-ES/what-and-why.html">Qué y para qué</a></li></ul></div><div class="navGroup navGroupActive"><h3>Configuración de Editor</h3><ul><li class="navListItem"><a class="navItem" href="/docs/es-ES/global-installation.html">Instalación global</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/editor-plugins.html">Editor Plugins</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/extra-goodies.html">Regalos extras</a></li></ul></div><div class="navGroup navGroupActive"><h3>Fundamentos del Idioma</h3><ul><li class="navListItem"><a class="navItem" href="/docs/es-ES/overview.html">Vista global</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/let-binding.html">Let Binding</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/type.html">¡Tipo!</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/string-and-char.html">String &amp; Char</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/boolean.html">Booleano</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/integer-and-float.html">Integer y Float</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/tuple.html">Tupla</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/record.html">Registro</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/docs/es-ES/variant.html">¡Variante!</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/list-and-array.html">Lista y Matriz</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/function.html">Función</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/if-else.html">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/more-on-type.html">Más de tipo</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/destructuring.html">Desestructurando</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/pattern-matching.html">¡Coincidencia de patrones!</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/mutation.html">Mutación</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/imperative-loops.html">Lazos imperativos</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/jsx.html">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/external.html">Externo</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/exception.html">Excepción</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/object.html">Objeto</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/module.html">Módulo</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/promise.html">Promise</a></li></ul></div><div class="navGroup navGroupActive"><h3>JavaScript</h3><ul><li class="navListItem"><a class="navItem" href="/docs/es-ES/quickstart-javascript.html">Inicio rápido</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/interop.html">Interop</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/syntax-cheatsheet.html">Hoja de Apoyo de sintaxis</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/libraries.html">Librerías</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/converting-from-js.html">Convertir de JS</a></li></ul></div><div class="navGroup navGroupActive"><h3>Nativo</h3><ul><li class="navListItem"><a class="navItem" href="/docs/es-ES/native.html">Nativo</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/quickstart-ocaml.html">Inicio rápido</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/convert-from-ocaml.html">Convertir de OCami</a></li></ul></div><div class="navGroup navGroupActive"><h3>Extra</h3><ul><li class="navListItem"><a class="navItem" href="/docs/es-ES/comparison-to-ocaml.html">Comparación a OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/newcomer-examples.html">Ejemplos de novato</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/project-structure.html">Estructura del proyecto</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/es-ES" target="_blank">Translate</a><h1>¡Variante!</h1></header><article><div><span><p>¡He aquí, la joya de la corona de las estructuras de datos de Reason!</p>
<p>La mayoría de estructura de datos en la mayoría de lenguajes son sobre &quot;esto <strong>y</strong> eso&quot;. Una variante nos permite expresar &quot;esto <strong>o</strong> eso&quot;.</p>
<pre><code class="hljs css reason">type myRespuestaVariante =
  | <span class="hljs-type">Si</span>
  | <span class="hljs-type">No</span>
  | <span class="hljs-type">Casi</span>;

<span class="hljs-keyword">let</span> LoEstasLogrando = Si;
</code></pre>
<p><code>Si</code>, <code>No</code> and <code>Casi</code> no son strings, o referencia, y tampoco algún tipo de dato especial. Ellos son llamados &quot;constructores&quot; (o &quot;etiquetas&quot;). La barra <code>|</code> separa cada constructor.</p>
<p><strong>Nota</strong>: una variante de constructor debe ir con mayúscula.</p>
<h2><a class="anchor" aria-hidden="true" name="uso"></a><a href="#uso" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Uso</h2>
<p>Junto con una variante viene una de las características más importantes de Reason, la expresión <code>switch</code>.</p>
<p>Un <code>switch</code> Reason es visualmente similar para otros lenguajes <code>switch</code> (también conocido como un gran <code>if/elseif/elseif...</code>). Te permite chequear cada caso posible de una variante. Para usarlo, enumera cada variante de constructor de un variante particular que te gustaría usar, cada uno seguido de un <code>=&gt;</code> y la expresión correspondiente de ese caso.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> mensaje =
  <span class="hljs-keyword">switch</span> (loEstasLogrando) {
  | <span class="hljs-function"><span class="hljs-params">No</span> =&gt;</span> <span class="hljs-string">"No te preocupes. ¡Sigue intentando!"</span>
  | <span class="hljs-function"><span class="hljs-params">Si</span> =&gt;</span> <span class="hljs-string">"¡Genial!"</span>
  | <span class="hljs-function"><span class="hljs-params">Casi</span> =&gt;</span> <span class="hljs-string">"¡Muy bien!"</span>
  };
<span class="hljs-comment">/* mensaje es "¡Genial!" */</span>
</code></pre>
<p>Un variante tiene una cantidad extremadamente rica de asistencia de tipo de sistema. Por ejemplo, te daremos un tipo de error si has olvidado cubrir un caso de tu variante, o si dos casos son redundantes. ¡Asegúrate de comprobar el switch y el patrón de coincidencia en un <a href="/docs/es-ES/pattern-matching.html"> sección posterior</a>!</p>
<h3><a class="anchor" aria-hidden="true" name="necesidades-variantes-y-una-definicion-explicita"></a><a href="#necesidades-variantes-y-una-definicion-explicita" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Necesidades Variantes y una Definición Explícita</h3>
<p>Si la variante que estas usando está en un archivo diferente, traerá dentro del alcance como lo harías <a href="/docs/es-ES/record.html#record-needs-an-explicit-definition"> para un record</a>:</p>
<pre><code class="hljs css reason"><span class="hljs-comment">/* Zoo.re */</span>

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">animal</span></span> = Dog | Cat | Bird;
</code></pre>
<pre><code class="hljs css reason"><span class="hljs-comment">/* example.re */</span>

<span class="hljs-keyword">let</span> pet: Zoo.<span class="hljs-attr">animal</span> = Dog; <span class="hljs-comment">/* preferred */</span>
<span class="hljs-comment">/* or */</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">pet</span> = Zoo.Dog;
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="constructor-de-argumentos"></a><a href="#constructor-de-argumentos" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Constructor de argumentos</h3>
<p>Un constructor de variante puede tener extra data separada por coma.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">type</span> account =
  | None
  | Instagram(<span class="hljs-keyword">string</span>)
  | Facebook(<span class="hljs-keyword">string</span>, <span class="hljs-keyword">int</span>);
</code></pre>
<p>Aquí, <code>Instagram</code> contiene un <code>string</code>, y <code>Facebook</code> contiene un <code>string</code> y un <code>int</code>. Uso:</p>
<pre><code class="hljs css reason"><span class="hljs-attribute">let miCuenta</span>= Facebook(<span class="hljs-string">"Josh"</span>, 26);
<span class="hljs-attribute">let CuentaAmigo</span>= Instagram(<span class="hljs-string">"Jenny"</span>);
</code></pre>
<p><strong>¿Notaste como usar un constructor es como llamar una función?</strong> Eso como si <code>Facebook</code> fuese una función que acepta dos argumentos. Esto no es una coincidencia; hay una razón de por qué una data de constructor es llamado &quot;argumento constructor&quot;.</p>
<p>Usar <code>switch</code>, puedes usar patrones coincidentes (repetimos: como descrito en la sección anterior) un argumento constructor:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> Saludo =
  switch (miCuenta) {
  | <span class="hljs-type">Ninguno</span> =&gt; <span class="hljs-string">"¡Hola!"</span>
  | <span class="hljs-type">Facebook</span>(nombre, edad) =&gt; <span class="hljs-string">"Hola "</span> ++ nombre ++ <span class="hljs-string">", tú tienes "</span> ++ string_of_int(edad) ++ <span class="hljs-string">"de edad"</span>
  | <span class="hljs-type">Instagram</span>(name) =&gt; <span class="hljs-string">"Hola "</span> ++ nombre ++ <span class="hljs-string">"!"</span>
  };
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="menciones-honorables"></a><a href="#menciones-honorables" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Menciones Honorables</h3>
<p>La <a href="/api/index.html">librería estándar </a> expone dos variantes importantes que escucharás mucho.</p>
<h4><a class="anchor" aria-hidden="true" name="opcion"></a><a href="#opcion" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>opción</code></h4>
<pre><code class="hljs css reason"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">option</span></span>(<span class="hljs-symbol">'a</span>) = <span class="hljs-literal">None</span> | <span class="hljs-literal">Some</span>(<span class="hljs-symbol">'a</span>);
</code></pre>
<p>Esto es la convención usada para simular una &quot;nullable&quot; (es decir, <code>undefined</code> o <code>null</code>). Gracias a esta convención de definición de tipo, Reason puede establecer por defecto cada valor ser no-nullable. Un <code>int</code> siempre será un int, nunca &quot;<code>int</code> <strong>o</strong> <code>null</code> <strong>o</strong> <code>undefined</code>&quot;. Si quieres expresar un &quot;nullable int&quot;, usarías <code>option(int)</code>, cuyos valores posibles son <code>None</code> o <code>Some(int)</code>. <code>switch</code> te obliga a manejar ambos casos; por lo tanto, <strong>un programa puro Reason no tiene errores null</strong>.</p>
<h4><a class="anchor" aria-hidden="true" name="lista"></a><a href="#lista" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>lista</code></h4>
<pre><code class="hljs css reason"><span class="hljs-keyword">type</span> <span class="hljs-built_in">list</span>(<span class="hljs-symbol">'a</span>) = <span class="hljs-type">Empty</span> | <span class="hljs-type">Head</span>(<span class="hljs-symbol">'a</span>, <span class="hljs-built_in">list</span>(<span class="hljs-symbol">'a</span>));
</code></pre>
<p><em>No la real definición de tipo. Sólo una ilustración</em>.</p>
<p>Esto dice: &quot;una lista que contiene un valor de tipo <code>a</code> (sea lo sea) es vacío o tiene ese valor además de otra lista&quot;.</p>
<p>Reason dio <code>list</code> un azúcar sintáctico. <code>[1, 2, 3]</code> es conceptualmente equivalente a <code>Head(1, Head(2, Head(3, Empty)))</code>. Una vez más,, <code>switch</code> te obliga a manejar cada caso de esta variante, incluyendo <code>Empty</code> (también conocido como <code>[]</code>). <strong>Esto elimina otra gran categoría de acceso a errores</strong>.</p>
<h4><a class="anchor" aria-hidden="true" name="otros-tipos-de-variante"></a><a href="#otros-tipos-de-variante" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Otros tipos de variante</h4>
<p>¿Sabías que puedes usar <code>switch</code> en string, int, float, fila y la mayoría de otra estructuras de data? ¡Pruébalo!</p>
<h2><a class="anchor" aria-hidden="true" name="consejos-y-trucos"></a><a href="#consejos-y-trucos" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Consejos y trucos</h2>
<p><strong>Se cuidadoso</strong> al no confundir un constructor que lleva 2 argumentos con un constructor que llega un sólo argumento tupla:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">type</span> cuenta =
  | Facebook(<span class="hljs-keyword">string</span>, <span class="hljs-keyword">int</span>) <span class="hljs-comment">/* 2 argumentos */</span>;
<span class="hljs-keyword">type</span> cuenta2 =
  | Instagram((<span class="hljs-keyword">string</span>, <span class="hljs-keyword">int</span>)) <span class="hljs-comment">/* 1 argumento -pasa ser una 2-tupla */</span>;
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="variantes-debe-tener-constructores"></a><a href="#variantes-debe-tener-constructores" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Variantes debe tener constructores</h3>
<p>Si vienes de un lenguaje sin tipo, podrías estar tentado en intentar <code>type foo = int | string</code>. Esto no es posible en Reason; tendrías que dar a cada rama un constructor: <code>type foo = Int(int) | String(string)</code>. Aunque usualmente, necesitar esto podría ser un anti-patrón. La sección de Diseño de Decisiones abajo lo explica más.</p>
<h3><a class="anchor" aria-hidden="true" name="interoperabilidad-con-javascript"></a><a href="#interoperabilidad-con-javascript" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Interoperabilidad con JavaScript</h3>
<p><em>Esta sección asume que se posee conocimiento sobre <a href="https://bucklescript.github.io/docs/en/interop-overview.html">FFI</a> de BuckleScript. Salta esto si no has sentido la curiosidad de usar variantes para atar funciones de JS</em>.</p>
<p>Bastantes librerías JS usa funciones que pueden aceptar muchos tipos de argumentos. En esos casos, es muy tentador modelarlos como variantes. Por ejemplo, suponga que hay una función JS <code>miLibreria.draw</code> que toma ya sea un <code>number</code> o un <code>string</code>. Estarías tentado a atarlos así:</p>
<pre><code class="hljs css reason">/* reservado para uso interno*/
[@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"myLibrary"</span>] <span class="hljs-keyword">external</span> draw : <span class="hljs-symbol">'a</span> =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"draw"</span>;

<span class="hljs-keyword">type</span> animal =
  | <span class="hljs-type">MiFloat</span>(<span class="hljs-built_in">float</span>)
  | <span class="hljs-type">MiString</span>(<span class="hljs-built_in">string</span>);

<span class="hljs-keyword">let</span> mejorDraw = (animal) =&gt;
  switch (animal) {
  | <span class="hljs-type">MiFloat</span>(f) =&gt; draw(f)
  | <span class="hljs-type">MiString</span>(s) =&gt; draw(s)
  };
</code></pre>
<p>Podrías definitivamente hacer eso, pero ¡hay mejores maneras! Por ejemplo, simplemente dos <code>external</code> que compilen el mismo llamado JS:</p>
<pre><code class="hljs css reason">[@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"mLibreria"</span>] <span class="hljs-keyword">external</span> drawFloat : <span class="hljs-built_in">float</span> =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"draw"</span>;
[@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"miLibreria"</span>] <span class="hljs-keyword">external</span> drawString : <span class="hljs-built_in">string</span> =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"draw"</span>;
</code></pre>
<p>BuckleScript también provee <a href="https://bucklescript.github.io/docs/en/function.html#binding-to-polymorphic-function"> algunas otras manera</a> de hacer esto.</p>
<h3><a class="anchor" aria-hidden="true" name="tipos-variante-son-encontrados-por-nombre-de-campo"></a><a href="#tipos-variante-son-encontrados-por-nombre-de-campo" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tipos Variante son encontrados por Nombre de Campo</h3>
<p>Por favor, diríjase a esta <a href="/docs/es-ES/record.html#record-types-are-found-by-field-name">sección de records</a>. Variantes son lo mismo: una función que no puede aceptar un constructor arbitrario aceptado por dos diferentes variantes. Otra vez, tal característica existe, se llama variante polimorfo. Hablaremos de esto en el futuro =).</p>
<h2><a class="anchor" aria-hidden="true" name="decisiones-de-diseno"></a><a href="#decisiones-de-diseno" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Decisiones de Diseño</h2>
<p>Variantes, en sus muchas formas (variante polimorfa, variante abierta, GADT, etc), son probables que sean <em>la</em> característica de un sistema de tipo como el de Reason. La opción variante mencionada anteriormente, por ejemplo, elimina la necesidad de usar tipos nullable, una gran fuente de error en otros lenguajes. Filosoficamente hablando, un problema es compuesto de muchos posibles ramas/condiciones. Manejar de forma inadecuada esas condiciones es lo que la mayoría llamamos bugs, o errores. <strong>Un sistema tipo no elimina mágicamente los errores; te señala las condiciones sin manejar y te pide que las trates</strong>*. La habilidad de modelar &quot;esto o aquello&quot; correctamente es crucial.</p>
<p>Por ejemplo, algunas personas se preguntan como sistemas tipo pueden eliminar de forma segura data JSON muy mal formateada de propagarse en sus programas. ¡No lo hacen, no por ellos mismos! Pero si el analizador sintáctico devuelve el tipo <code>option</code>, <code>None | Some(actualData)</code>, entonces podrías tener como manejar el caso <code>None</code> explícitamente en otros sitios de llamada. Eso es todo lo que hay.</p>
<p>En cuestión de desempeño, un variante puede potencialmente aumentar tu lógica de programa. Aquí hay una pieza de JavaScript:</p>
<pre><code class="hljs css js"><span class="hljs-keyword">let</span> data = <span class="hljs-string">'dog'</span>;
<span class="hljs-keyword">if</span> (data === <span class="hljs-string">'dog'</span>) {
  ...
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data === <span class="hljs-string">'cat'</span>) {
  ...
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data === <span class="hljs-string">'bird'</span>) {
  ...
}
</code></pre>
<p>Hay una cantidad lineal de ramas comprobándose aquí (<code>O(n)</code>). Compara esto al usado en un variante Reason:</p>
<pre><code class="hljs css reason">tipo animal = Perro | <span class="hljs-type">Gato</span> | <span class="hljs-type">P</span>ájaro;
<span class="hljs-keyword">let</span> data = Perro;
switch (data) {
| <span class="hljs-type">Perro</span> =&gt; ...
| <span class="hljs-type">Gato</span> =&gt; ...
| <span class="hljs-type">P</span>ájaro =&gt; ...
}
</code></pre>
<p>El compilador ve la variante, entonces</p>
<ol>
<li>conceptualmente los convierte en <code>type animal = 0 | 1 | 2</code></li>
<li>compila <code>switch</code> a un formato de constante (<code>O(1)</code>).</li>
</ol>
<p>Te podrías preguntar por qué tipo de lenguajes funcionales son usados tan a menudo para análisis: cambiar a un gran árbol de forma eficiente y segura es el mejor escenario para variantes.</p>
<!-- TODO: playground link -->
<p>¿Sorprendido ya? Variantes tiene una conexión profunda con otros campos de matemática <a href="https://codewords.recurse.com/issues/three/algebra-and-calculus-of-algebraic-data-types">Véase aquí</a> para una exploración interesante.</p>
<p>* Siempre es más agradable diseñar el problema que recurrir a un sistema tipo que cubra las trampas; En verdad, es poco realista hacerlo para cada problema, o inclusive para entender cada problema completamente en orden de diseñar una solución. Un sistema tipo te permite hacer con seguridad cambios de gran categoría a base de códigos sin necesidad de entender todo por adelantado. Esto es genial para exploraciones guiadas. En este sentido, tipos también nos permite no necesitar un sobre diseñar un API justo para eludir las trampas de los callers. Ellos reducen las capas de abstracciones necesarias para &quot;hacer las cosas&quot;, las cuales en retorno reduce la carga cognitiva de los callers.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="record.html">← Registro</a><a class="docs-next button" href="list-and-array.html">Lista y Matriz →</a></div></div></div></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react'
              });
            </script></body></html>