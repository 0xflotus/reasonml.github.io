<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>Comparación a OCaml · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Comparación a OCaml · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/index.html"/><meta property="og:description" content="Si vienes de OCaml o eres un novato que está leyendo un tutorial de OCaml, ¡Esta guía es para ti! Pero no olvides que [reason-tools](https://github.com/reasonml/reason-tools) puede convertir la sintaxis entre OCaml y Reason al vuelo."/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/arduino-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/dummy.svg"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/docs/es-ES/quickstart-javascript.html" target="_self">Documentación</a></li><li><a href="/es-ES/try.html" target="_self">Pruebalo</a></li><li><a href="/api/index.html" target="_self">API</a></li><li><a href="/docs/es-ES/community.html" target="_self">Comunidad</a></li><li><a href="/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg"/>Español</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/ja">日本語</a></li><li><a href="/en">English</a></li><li><a href="/fr">Français</a></li><li><a href="/ko">한국어</a></li><li><a href="/pt-BR">Português (Brasil)</a></li><li><a href="/ru">Русский</a></li><li><a href="/uk">Українська</a></li><li><a href="/zh-CN">中文</a></li><li><a href="/zh-TW">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank">Ayuda a traducir</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Extra</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Intro</h3><ul><li class="navListItem"><a class="navItem" href="/docs/es-ES/what-and-why.html">Qué y para qué</a></li></ul></div><div class="navGroup navGroupActive"><h3>Configuración de Editor</h3><ul><li class="navListItem"><a class="navItem" href="/docs/es-ES/global-installation.html">Instalación global</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/editor-plugins.html">Plugins para el editor</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/extra-goodies.html">Regalos extras</a></li></ul></div><div class="navGroup navGroupActive"><h3>Fundamentos del Idioma</h3><ul><li class="navListItem"><a class="navItem" href="/docs/es-ES/overview.html">Vista global</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/let-binding.html">Let Binding</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/type.html">¡Tipo!</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/string-and-char.html">String &amp; Char</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/boolean.html">Booleano</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/integer-and-float.html">Integer y Float</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/tuple.html">Tupla</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/record.html">Registro</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/variant.html">¡Variante!</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/list-and-array.html">Lista y Matriz</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/function.html">Función</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/if-else.html">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/more-on-type.html">Más de tipo</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/destructuring.html">Desestructurando</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/pattern-matching.html">¡Coincidencia de patrones!</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/mutation.html">Mutación</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/imperative-loops.html">Lazos imperativos</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/jsx.html">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/external.html">Externo</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/exception.html">Excepción</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/object.html">Objeto</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/module.html">Módulo</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/promise.html">Promesa</a></li></ul></div><div class="navGroup navGroupActive"><h3>JavaScript</h3><ul><li class="navListItem"><a class="navItem" href="/docs/es-ES/quickstart-javascript.html">Inicio rápido</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/interop.html">Interop</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/syntax-cheatsheet.html">Hoja de Apoyo de sintaxis</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/libraries.html">Librerías</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/converting-from-js.html">Convertir de JS</a></li></ul></div><div class="navGroup navGroupActive"><h3>Nativo</h3><ul><li class="navListItem"><a class="navItem" href="/docs/es-ES/native.html">Nativo</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/quickstart-ocaml.html">Inicio rápido</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/convert-from-ocaml.html">Convertir de OCami</a></li></ul></div><div class="navGroup navGroupActive"><h3>Extra</h3><ul><li class="navListItem"><a class="navItem" href="/docs/es-ES/faq.html">Preguntas Frecuentes</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/docs/es-ES/comparison-to-ocaml.html">Comparación a OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/newcomer-examples.html">Ejemplos de novato</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/project-structure.html">Estructura del proyecto</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/es-ES" target="_blank">Translate</a><h1>Comparación a OCaml</h1></header><article><div><span><p>Si vienes de OCaml o eres un novato que está leyendo un tutorial de OCaml, ¡Esta guía es para ti! Pero no olvides que <a href="https://github.com/reasonml/reason-tools">reason-tools</a> puede convertir la sintaxis entre OCaml y Reason al vuelo.</p>
<h2><a class="anchor" aria-hidden="true" name="comentarios"></a><a href="#comentarios" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Comentarios</h2>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>(* OCaml (*nest*) *)</code></td><td><code>/* Reason /*nest*/ */</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" name="renombrar-el-operador"></a><a href="#renombrar-el-operador" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Renombrar el operador</h2>
<p>Reason tiene todo los operadores infijos de Ocaml, pero unos pocos se expresan de manera diferente. En Reason, la igualdad estructural se escribe <code>==</code>, y la igualdad referencial (física) <code>===</code>. En Reason, para obtener la desigualdad correspondiente, simplemente cambia el primer carácter por <code>!</code>. (<code>!=</code> para desigualdad estructural, y <code>!==</code> para desigualdad referencial).</p>
<table>
<thead>
<tr><th>Igualdad</th><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td>Estructural</td><td><code>x = y</code></td><td><code>x == y</code></td></tr>
<tr><td>Referencial</td><td><code>x == y</code></td><td><code>x === y</code></td></tr>
</tbody>
</table>
<table>
<thead>
<tr><th>Desigualdad</th><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td>Estructural</td><td><code>x &lt;&gt; y</code></td><td><code>x != y</code></td></tr>
<tr><td>Referencial</td><td><code>x != y</code></td><td><code>x !== y</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" name="ambito-local"></a><a href="#ambito-local" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Ámbito local</h2>
<p>El ámbito léxico de Reason es exactamente igual al de OCaml, pero los enlaces se parecen más sintácticamente a el &quot;ámbito de bloque&quot; que es más familiar para muchos desarrolladores. En Reason, esto son creados con llaves <code>{}</code>, las cuales pueden contener ambos <code>let</code> enlaces y comandos imperativos, separados por <code>;</code>. Todos los bloques son evaluados hasta la última línea y el punto y coma en esta es opcional. Las llaves<code>{}</code> son solo necesarias si tienes más de un ítem que enlazar vía <code>;</code>.</p>
<table>
  <tr>
    <th>
      <p>
        OCaml
      </p>
    </th>
<pre><code class="hljs">&lt;th&gt;
  &lt;p&gt;
    Reason
  &lt;/p&gt;
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre>
let _ =
  let message = "Hello" in
  print_string mess
  let msg2 = "Goodbye" in
  print_string msg2age;</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;
</code></pre>
<p>{
let message = &quot;Hel
print_string(messa
let msg2 = &quot;Goodbye&quot;;
print_string(msg2)
};ge);lo&quot;;</pre>
</td></p>
  </tr>
</table>
<p>La sintaxis <code>{}</code> de Reason elimina muchos de los aspectos molestos habitualmente comunicados en la sintaxis de Ocaml:</p>
<ul>
<li>Los punto y coma dobles están eliminados totalmente.</li>
<li><code>begin</code>/<code>end</code> están eliminados por completo.</li>
<li>Los infames <a href="https://github.com/ocaml/ocaml/pull/278">problemas</a> con el analizador sintáctico (parsing) imperativo desaparecen.</li>
<li>Los cuerpos de modulos y el ámbito local están unificados.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" name="ambito-local-vs-cuerpo-del-modulo"></a><a href="#ambito-local-vs-cuerpo-del-modulo" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Ámbito Local vs Cuerpo del Módulo</h2>
<p>En Reason, todo lo que puede ir entre <code>{}</code> puede estar en <a href="#local-scope">Ámbito Local</a> y en el cuerpo de los módulos. Habitualmente, hasta puedes cortar/pegar código entre ambos contextos. En OCaml, las sintaxis entre los dos contextos es muy diferente. El ámbito local requiere llevar al final <code>in</code>, pero el cuerpo de los módulos no lo necesita y las declaraciones imperativas deben ser asignadas a <code>_</code> o <code>()</code>, o si no usar doble <code>;;</code>.</p>
<table>
  <tr>
    <th>
      <p>
        Cuerpo de Módulo Ocaml
      </p>
    </th>
<pre><code class="hljs">&lt;th&gt;
  &lt;p&gt;
    Cuerpo de Módulo Reason
  &lt;/p&gt;
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre>
let ten = 10
let () = imperativeFunc ten ten
let () = imperativeFunc 0 0</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;
</code></pre>
<p>let ten = 10;
imperativeFunc(ten, ten);
imperativeFunc(0, 0);</pre>
</td></p>
  </tr>
  <tr>
    <td>
      <pre>
let ten = 10;;
imperativeFunc ten ten;;
imperativeFunc 0 0;;</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  Igual que arriba
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <th>
      <p>
        Ámbito Local en Ocaml
      </p>
    </th>
<pre><code class="hljs">&lt;th&gt;
  &lt;p&gt;
    Ámbito Local en Reason
  &lt;/p&gt;
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre>
let ten = 10 in
let _ = imperativeFunc ten ten in
imperativeFunc 0 0</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  Igual que arriba
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre>
let ten = 10 in begin
  imperativeFunc ten ten;
  imperativeFunc 0 0
end</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  Igual que arriba
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre>
let ten = 10 in (
  imperativeFunc ten ten;
  imperativeFunc 0 0
)</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  Igual que arriba
&lt;/td&gt;
</code></pre>
  </tr>
</table>
<h2><a class="anchor" aria-hidden="true" name="tupla-y-registro"></a><a href="#tupla-y-registro" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tupla y Registro</h2>
<p>En Reason, las tuplas siempre requieren paréntesis.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let tup = 4, 5</code></td><td><code>let tup = (4, 5);</code></td></tr>
<tr><td><code>let tup = ((1: int), (2:int))</code></td><td><code>let tup = (1: int, 2:int);</code></td></tr>
<tr><td><code>fun ((a: int), (b: int)) -&gt; a</code></td><td><code>((a: int, b: int)) =&gt; a;</code></td></tr>
</tbody>
</table>
<p>In Reason, record values resemble JavaScript, using <code>:</code> instead of <code>=</code>.</p>
<table>
  <tr>
    <th>
      <p>
        OCaml
      </p>
    </th>
<pre><code class="hljs">&lt;th&gt;
  &lt;p&gt;
    Reason
  &lt;/p&gt;
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre>
let myRec = {x = 0; y = 10}</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;
</code></pre>
<p>let myRec = {x: 0, y: 10};</pre>
</td></p>
  </tr>
  <tr>
    <td>
      <pre>
let myFuncs = {
  myFun = (fun x -> x + 1);
  your = (fun a b -> a + b);
}</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;
</code></pre>
<p>let myFuncs = {
myFun: (x) =&gt; x + 1,
your: (a, b) =&gt; a + b
};</pre>
</td></table></p>
<pre><code class="hljs">&lt;h2&gt;
  Listas
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let list = [1; 2; 3]&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let list = [1, 2, 3]&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let list = hd :: tl&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let list = [hd, ...tl];&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h2&gt;
  Definiciones de tipos
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      Tupla OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Tupla Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type tuple = int * int&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type tuple = (int, int);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let tup: tuple = (10, 30)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let tup: tuple = (10, 30);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      Registro OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Registro Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type r = {x: int; y: int}&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type r = {x: int, y: int};&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let myRec: r = {x = 0; y = 10}&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let myRec: r = {x: 0, y: 10};&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      Función Ocaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Función Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type func = int -&amp;gt; int&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type func = int =&amp;gt; int;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x: func = fun a -&amp;gt; a + 1&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x: func = (a) =&amp;gt; a + 1;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h2&gt;
  Funciones
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x a b = e&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = (a, b) =&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = fun a b -&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = (a, b) =&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = fun a -&amp;gt; fun b -&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = (a, b) =&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  Funciones con coincidencia de argumento único
&lt;/h3&gt;

&lt;p&gt;
  OCaml tiene una definición de función (&lt;code&gt;function |&lt;/code&gt;) que es considerada equivalente a &lt;code&gt;function a -&amp;gt; match a with &lt;/code&gt;. Reason tiene lo mismo, pero la sintaxis deja claro que en realidad es una extensión de una función de argumento único. El caso de coincidencia única es una extensión natural de la lambda simple, y el caso múltiple es una extensión natural de la lambda de caso único.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        Forma
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      lambda
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>fun pat -&gt; e</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>fun pat =&gt; e</pre>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      caso de coincidencia única
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>function | pat -&gt; e</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>fun | pat =&gt; e</pre>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      multiples casos
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>function | pat -&gt; e
| pat2 -&gt; e</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>fun | pat =&gt; e
| pat2 =&gt; e</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  Anotando argumentos
&lt;/h3&gt;

&lt;p&gt;
  Tanto en Reason como en OCaml, los argumentos son anotados con tipos (como todo lo demás), encerrándolos en paréntesis después de agregar &lt;code&gt;:typeAnnotation&lt;/code&gt;.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;reason&quot;&gt;(arg: argType) =&amp;gt; returnValue;
</code></pre>
<p></code></pre></p>
<pre><code class="hljs">&lt;pre&gt;&lt;code class=&quot;reason&quot;&gt;(arg: argType) =&amp;gt; (arg2: arg2Type) =&amp;gt; returnValue;
</code></pre>
<p></code></pre></p>
<pre><code class="hljs">&lt;pre&gt;&lt;code class=&quot;reason&quot;&gt;(arg: argType, arg2: arg2Type) =&amp;gt; returnValue;
</code></pre>
<p></code></pre></p>
<pre><code class="hljs">&lt;p&gt;
  Ambos, Reason y OCaml permiten anotar el tipo de valor de retorno, cuando se usa la forma &quot;super sugared let binding&quot;.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;(* OCaml *)
</code></pre>
<p>let myFunc (a:int) (b:int) :int * int = (a, b)
let myFunc (a:int) (b:int) :int list = [1]
let myFunc (a:int) (b:int) :int -&gt; int = fun x -&gt; x + a + b
</code></pre></p>
<pre><code class="hljs">&lt;pre&gt;&lt;code class=&quot;reason&quot;&gt;/* Reason */
</code></pre>
<p>let myFunc = (a: int, b: int) :(int, int) =&gt; (a, b);
let myFunc = (a: int, b: int) :list(int) =&gt; [1];
let myFunc = (a: int, b: int): (int =&gt; int) =&gt; (x) =&gt; x + a + b;
</code></pre></p>
<pre><code class="hljs">&lt;p&gt;
  Aunque usamos &lt;code&gt;=&amp;gt;&lt;/code&gt; para todas las funciones en Reason, hay un caso donde necesitamos agregar un paréntesis extra alrededor del tipo del valor de retorno que es, en sí misma, la función tipo.
&lt;/p&gt;

&lt;h3&gt;
  Tipado de parámetros
&lt;/h3&gt;

&lt;h4&gt;
  OCaml
&lt;/h4&gt;

&lt;p&gt;
  Las aplicaciones de tipos en OCaml (piensa en &quot;genéricos&quot;), son aplicados en orden inverso.
&lt;/p&gt;

&lt;p&gt;
  Con OCaml, hay algunas consecuencias poco intuitivas.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let x: int list = [2]
</code></pre>
<p>type listOfListOfInts = int list list</p>
<p>(* Parsed as: *)
type listOfListOfInts = (int list) list
</code></pre></p>
<pre><code class="hljs">&lt;p&gt;
  Las cosas se ponen aún más extrañas cuando constructores de tipo aceptan parámetros múltiples. Múltiples argumentos requiere paréntesis y comas para separar parámetros de tipo, pero esos parámetros no representan tuplas. La forma paréntesis/comas debe también ser usada cuando se construyen instancias de tipos como &lt;code&gt;(int, string) tuple&lt;/code&gt;.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;type ('a, 'b) tuple = 'a * 'b
</code></pre>
<p>type listOfTuplesOfStringAndInt = (string, int) tuple list</p>
<p>(* Which is parsed as: *)
type listOfTuplesOfStringAndInt = ((string, int) tuple) list</p>
<p>(* Which allows a list of (tuples of (string and int)) *)
let tuples: listOfTuplesOfStringAndInt = [(&quot;asdf&quot;, 3)]
</code></pre></p>
<pre><code class="hljs">&lt;h4&gt;
  Reason
&lt;/h4&gt;

&lt;p&gt;
  En resumen, Reason unifica casi toda la sintaxis en un estilo simple de &quot;aplicación de funciones&quot;, lo que significa que los parámetros tipados siguen el mismo patrón de separación por comas visto en toda la sintaxis. Esto se traduce en menos patrones sintácticos que aprender.
&lt;/p&gt;

&lt;p&gt;
  Por ejemplo, puedes imaginar &lt;code&gt;list&lt;/code&gt; siendo una &quot;función&quot; para tipos que aceptan un tipo y devuelve un nuevo tipo.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let x: int list = [2]
type listOfListOfInts = int list list
type ('a, 'b) tup = ('a * 'b)
type pairs = (int, int) tup list
let tuples: pairs = [(2, 3)]</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let x: list(int) = [2];
type listOfListOfInts = list(list(int));
type tup('a, 'b) = ('a, 'b);
type pairs = list(tup(int, int));
let tuples: pairs = [(2, 3)];</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h2&gt;
  Tuplas como parámetros tipados
&lt;/h2&gt;

&lt;p&gt;
  Como OCaml usa paréntesis y comas para representar argumentos múltiples en constructores de tipos, es confuso cuando uno de los argumentos de un constructor de tipos es en sí una tupla. En OCaml, es difícil recordar la diferencia entre un constructor de tipos que acepte múltiples argumentos y un constructor de tipos que acepte un sólo elemento, que pasa a ser una tupla.
&lt;/p&gt;

&lt;p&gt;
  Los siguientes ejemplos muestran la diferencia entre pasar &lt;em&gt;dos&lt;/em&gt; parámetros de tipos a &lt;code&gt;pair&lt;/code&gt;, y un &lt;em&gt;sólo &lt;/em&gt; parámetro de tipo que resulta ser una tupla.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type intPair = (int, int) pair&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type intPair = pair(int, int)&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type pairList = (int * int) list&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type pairList = list((int, int))&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    En Reason, la sintaxis que representa una tupla o tipos de tupla, siempre asemejan tuplas.
  &lt;/li&gt;
  &lt;li&gt;
    En Reason, la sintaxis que representa los registros o los tipos de registro, siempre se ven como registros.
  &lt;/li&gt;
  &lt;li&gt;
    Casi todo lo demás usa el patrón sintáctico de aplicación de función (argumentos separados por comas).
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;
  Variantes
&lt;/h2&gt;

&lt;h5&gt;
  OCaml
&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    OCaml prevé tipos de argumentos de construcción que sean especificados en forma de tupla, por lo que es confuso cuando un sólo constructor espera un sólo argumento que también &lt;em&gt;resulta ser&lt;/em&gt; un tipo tupla.
  &lt;/li&gt;
  &lt;li&gt;
    Lo que es aún más confuso es que los constructores &lt;em&gt;en realidad&lt;/em&gt; no aceptan tuplas, aunque la sintaxis se asemeja a las tuplas.
  &lt;/li&gt;
  &lt;li&gt;
    A veces, la sintaxis para crear una instancia de un constructor con múltiples argumentos solapa la sintaxis para construir una variante con un sólo argumento que resulta ser una tupla - entonces parece &lt;em&gt;exactamente&lt;/em&gt; como si &lt;em&gt;estuvieras&lt;/em&gt; suministrando una tupla cuando en realidad no lo estas haciendo.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;
  Reason
&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    Los tipos de constructores variantes se espera que sean listados como listas separadas por comas, usando paréntesis para agrupar por precedencia (así como con &lt;strong&gt;todo&lt;/strong&gt; lo demás).
  &lt;/li&gt;
  &lt;li&gt;
    Instancias de construcción de la variante (como habrás adivinado) siguen el estilo de aplicación de función (listas separadas por comas).
  &lt;/li&gt;
  &lt;li&gt;
    Tuplas &lt;strong&gt;siempre&lt;/strong&gt; &lt;em&gt;parecen&lt;/em&gt; tuplas, y cualquier cosa que parezca una tupla &lt;em&gt;es&lt;/em&gt; una tupla.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>type myVariant =
| HasNothing
| HasSingleInt of int
| HasSingleTuple of (int * int)
| HasMultipleInts of int * int
| HasMultipleTuples of (int * int) * (int * int)
</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>type myVariant =
| HasNothing
| HasSingleInt(int)
| HasSingleTuple((int, int))
| HasMultipleInts(int, int)
| HasMultipleTuples((int, int), (int, int));
</pre>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let a = HasSingleInt 10
let a = HasSingleTuple (10, 10)
let a = HasMultipleInts (10, 10)
let a = HasMultipleTuples ((10, 10), (10, 10))
</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let a = HasSingleInt(10);
let a = HasSingleTuple((10, 10));
let a = HasMultipleInts(10, 10);
let a = HasMultipleTuples((10, 10), (10, 10));
</pre>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let res x = match x with
| HasNothing -&gt; 0
| HasSingleInt x -&gt; 0
| HasSingleTuple (x, y) -&gt; 0
| HasMultipleInts (x, y) -&gt; 0
| HasMultipleTuples ((x, y), (q, r)) -&gt; 0
</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let res = (x) =&gt;
switch (x) {
| HasNothing =&gt; 0
| HasSingleInt(x) =&gt; 0
| HasSingleTuple((x, y)) =&gt; 0
| HasMultipleInts(x, y) =&gt; 0
| HasMultipleTuples((x, y), (q, r)) =&gt; 0
};
</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h2&gt;
  Coincidencia de patrón
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let res = match x with
| A (x, y) -&gt; match y with
| None -&gt; 0
| Some i -&gt; 10
| B (x, y) -&gt; 0</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let res = switch (x) {
| A((x, y)) =&gt; switch (y) {
| None =&gt; 0
| Some(i) =&gt; 10
}
| B((x, y)) =&gt; 0
};</p>
</pre>
        </td>
      </tr>
    </table>
<pre><code class="hljs">&lt;p&gt;
  ¿Puedes localizar el error en el ejemplo de OCaml? Este es uno de los errores más comunes entre los programadores OCaml. El &lt;code&gt;match&lt;/code&gt; anidado &lt;em&gt;debe&lt;/em&gt; ser escrito entre paréntesis, si no el caso &lt;code&gt;Some&lt;/code&gt; es analizado como si perteneciera a la &lt;code&gt;coincidencia&lt;/code&gt; exterior. Visualmente, en realidad es:
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let res = match x with
</code></pre>
<p>| A (x, y) -&gt; match y with
| None -&gt; 0
| Some i -&gt; 10
| B (x, y) -&gt; 0
</code></pre></p>
<pre><code class="hljs">&lt;p&gt;
  Las &lt;code&gt;{}&lt;/code&gt; obligatorias en Reason alrededor de casos &lt;code&gt;switch&lt;/code&gt; previenen este problema.
&lt;/p&gt;

&lt;h2&gt;
  Módulos y Firmas
&lt;/h2&gt;

&lt;h3&gt;
  Definición
&lt;/h3&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module type MySig = sig
type t = int
val x: int
end
module MyModule: MySig = struct
type t = int
let x = 10
end
module MyModule = struct
module NestedModule = struct
let msg = &quot;hello&quot;;
end
end
</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module type MySig = {
type t = int;
let x: int;
};
module MyModule: MySig = {
type t = int;
let x = 10;
};
module MyModule = {
module NestedModule = {
let msg = &quot;hello&quot;;
};
};
</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  Tipos Functor
&lt;/h3&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module type FType =
functor (A: ASig) -&gt;
functor (B: BSig) -&gt; Result
</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module type FType =
(A: ASig) =&gt;
(B: BSig) =&gt; Result;
</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h2&gt;
  Functores
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module F =
functor (A: ASig) -&gt;
functor (B: BSig) -&gt; struct end</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module F =
(A: ASig) =&gt;
(B: BSig) =&gt; {};</pre>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module F = functor (A: ASig) (B: BSig) -&gt; struct end</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module F = (A: ASig, B: BSig) =&gt; {};</pre>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module F (A: ASig) (B: BSig) = struct end</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module F = (A: ASig, B: BSig) =&gt; {};</pre>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module Res = F(A)(B)</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module Res = F(A, B);</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h2&gt;
  Varias mejoras
&lt;/h2&gt;

&lt;p&gt;
  OCaml no requiere paréntesis alrededor de secuencias &lt;code&gt;(a;b;c;d)&lt;/code&gt; o tuplas &lt;code&gt;(x,y)&lt;/code&gt;, de esta manera descarta un montón de otras reglas de sintaxis muy practicas. Como Reason siempre usa &lt;code&gt;{}&lt;/code&gt; para delimitar secuencias o enlaces let, y Reason siempre requiere &lt;code&gt;()&lt;/code&gt; alrededor de las tuplas, muchos constructor sintácticos son expresados más intuitivamente, sin requerir escribirlos entre paréntesis adicionales.
&lt;/p&gt;

&lt;h3&gt;
  Lambdas como campos de registro no necesitan paréntesis adicionales
&lt;/h3&gt;

&lt;p&gt;
  Esta es una mejora bienvenida porque los errores de tipos de OCaml que el usuario vería serían muy confusos al creer que el valor de retorno de la función era una tupla con una &lt;code&gt;,&lt;/code&gt; coma infija.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let myFuncs = {
myFun = (fun x -&gt; x + 1);
your = (fun a b -&gt; a + b);
}</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let myFuncs = {
myFun: (x) =&gt; x + 1,
your: (a, b) =&gt; a + b
};</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  Lambdas como resultados de coincidencias no requieren paréntesis adicionales
&lt;/h3&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let x = match prnt with
| None -&gt; fun a -&gt; blah
(* Extra () required ! *)
| Some &quot;_&quot; -&gt; (fun a -&gt; ())
| Some &quot;ml&quot; -&gt; blah
</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let x =
switch (prnt) {
| None =&gt; (a) =&gt; blah
| Some(&quot;_&quot;) =&gt; (a) =&gt; ()
| Some(&quot;ml&quot;) =&gt; blah
};</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  Lambdas y anotaciones de tipos en tuplas no requieren paréntesis suplementarios
&lt;/h3&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let tuple = ((fun x -&amp;gt; x), 20)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let tuple = ((x) =&amp;gt; x, 20);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let tuple = ((&quot;hi&quot;: string), (20: int))&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let tuple = (&quot;hi&quot;: string, 20: int);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h2&gt;
  Diferencias varias
&lt;/h2&gt;

&lt;h3&gt;
  precedencia &lt;code&gt;as&lt;/code&gt;
&lt;/h3&gt;

&lt;p&gt;
  Con Reason, &lt;code&gt;as&lt;/code&gt; tiene una mayor precedencia que el simbolo&lt;code&gt;|&lt;/code&gt;. Esto permite crear alias de &lt;code&gt;as&lt;/code&gt; para filas completas en coincidencias de patrón.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let ppp = match MyThing 20 with
| (MyThing x as ppp)
| (YourThing x as ppp) -&gt; ppp;
</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let ppp =
switch (MyThing(20)) {
| MyThing(x) as ppp
| YourThing(x) as ppp =&gt; ppp
};
</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  Actualizaciones de campos de registros mutables
&lt;/h3&gt;

&lt;p&gt;
  Porque igualdades y sus negaciones se han hecho más consistentes en Reason, el operador &lt;code&gt;=&lt;/code&gt; esta disponible para actualizar campos mutables.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;myRec.field &amp;lt;- &quot;next&quot;&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;myRec.field = &quot;next&quot;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  Operadores prefijos
&lt;/h3&gt;

&lt;p&gt;
  El carácter &lt;code&gt;!&lt;/code&gt; en Reason se utiliza para la negación &lt;code&gt;not&lt;/code&gt; booleana. El deferenciamiento utiliza el postfijo &lt;code&gt;^&lt;/code&gt;.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(foo.bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo.bar^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(foo#bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo#bar^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(!foo.bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo^.bar^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(!foo#bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = (foo^)#bar^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(!(foo.bar))&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo.bar^ ^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(!(foo#bar))&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo#bar^ ^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !!(foo.bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = !!foo.bar;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !!(foo#bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = !!foo#bar;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !~(foo.bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = !~foo.bar;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !~(foo#bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = !~foo#bar;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  Escapando Comentarios
&lt;/h3&gt;

&lt;p&gt;
  Como Reason utiliza comentarios estilo C, algunos oscuros operadores prefijo/infijo personalizados deben ser escritos de forma diferente. Las reglas para operadores prefijos/infijos son las mismas que las de el sintaxis de OCaml, pero con las siguientes excepciones:
&lt;/p&gt;

&lt;p&gt;
  Específicamente, si algún carácter excepto el primero en un operador prefijo/infijo es un asterisco o una barra inclinada, primero debe ser escapado con una barra inclinada inversa. Estos serán analizados &lt;em&gt;sin&lt;/em&gt; la barra inclinada invertida cuando sean añadidos al AST. Cuando se reimpriman, la barra inclinada invertida de escape será añadida de nuevo automáticamente.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let (/*) a b = a + b&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let (/\*) a b =&amp;gt; a + b;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = 12 /-* 23 /-* 12&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = 12 /-* 23 /-* 12;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let y = (/*) a b&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let y = a /\* b;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let (!=*) q r = q + r&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let ( !=* ) = (q, r) =&amp;gt; q + r;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let res = q (!=*) r&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let res = q(( !=* ), r);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let (!=/*) q r = q + r&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let ( !=/\* ) = (q, r) =&amp;gt; q + r;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let res = q (!=/*) r&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let res = q(( !=/\* ), r);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  Renombrando operadores
&lt;/h3&gt;

&lt;p&gt;
  Si Reason usa &lt;code&gt;==&lt;/code&gt; para representar el &lt;code&gt;=&lt;/code&gt; de OCaml, y usa el &lt;code&gt;===&lt;/code&gt; para representar el &lt;code&gt;==&lt;/code&gt; de OCaml, entonces ¿Como representa Reason el símbolo de OCaml &lt;code&gt;===&lt;/code&gt; (si este fuese definido)? ¡Reason proporciona una manera! ¡Triple &quot;Escape&quot; el símbolo igual!
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      Identificador
    &lt;/th&gt;
    
    &lt;th&gt;
      Significado
    &lt;/th&gt;
    
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&quot;===&quot;&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      Valor personalizado
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;x === y&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;x \=== y&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  REPL
&lt;/h3&gt;

&lt;p&gt;
  En el REPL de Reason &lt;a href=&quot;extra-goodies.md#repl&quot;&gt;&lt;code&gt;rtop&lt;/code&gt;&lt;/a&gt; (un &lt;a href=&quot;https://github.com/diml/utop&quot;&gt;&lt;code&gt;utop&lt;/code&gt;&lt;/a&gt; personalizado), cada entrada es remitida a través de un único punto y coma &lt;code&gt;;&lt;/code&gt;. El REPL de OCaml requiere dos punto y coma &lt;code&gt;;;&lt;/code&gt;.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;;;&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="faq.html">← Preguntas Frecuentes</a><a class="docs-next button" href="newcomer-examples.html">Ejemplos de novato →</a></div></div></div></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react'
              });
            </script></body></html>