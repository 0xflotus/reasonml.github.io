<html><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"/><title>Comparación a OCaml · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Comparación a OCaml · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/index.html"/><meta property="og:description" content="Si vienes de OCaml o eres un recién llegado leyendo un turtorial escrito en OCaml, ¡Esta guía es para ti! Pero no olvides que [herramientas-reason](https://github.com/reasonml/reason-tools) puede cubrir la sintaxis de OCaml y Reason sobre la marcha."/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/arduino-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/dummy.svg"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li><a href="/docs/es-ES/quickstart-javascript.html" target="_self">Documentación</a></li><li><a href="/es-ES/try.html" target="_self">Pruebalo</a></li><li><a href="/api/index.html" target="_self">API</a></li><li><a href="/docs/es-ES/community.html" target="_self">Comunidad</a></li><li><a href="/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg"/>Español</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/ja">日本語</a></li><li><a href="/en">English</a></li><li><a href="/fr">Français</a></li><li><a href="/ko">한국어</a></li><li><a href="/pt-BR">Português (Brasil)</a></li><li><a href="/ru">Русский</a></li><li><a href="/zh-CN">中文</a></li><li><a href="/zh-TW">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank">Ayuda a traducir</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(){
          if(languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search"/></li><li><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Extra</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Intro</h3><ul><li class="navListItem"><a class="navItem" href="/docs/es-ES/what-and-why.html">Qué y para qué</a></li></ul></div><div class="navGroup navGroupActive"><h3>Configuración de Editor</h3><ul><li class="navListItem"><a class="navItem" href="/docs/es-ES/global-installation.html">Instalación global</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/editor-plugins.html">Editor Plugins</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/extra-goodies.html">Regalos extras</a></li></ul></div><div class="navGroup navGroupActive"><h3>Fundamentos del Idioma</h3><ul><li class="navListItem"><a class="navItem" href="/docs/es-ES/overview.html">Vista global</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/let-binding.html">Let Binding</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/type.html">¡Tipo!</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/string-and-char.html">String &amp; Char</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/boolean.html">Booleano</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/integer-and-float.html">Integer y Float</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/tuple.html">Tupla</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/record.html">Registro</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/variant.html">¡Variante!</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/list-and-array.html">Lista y Matriz</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/function.html">Función</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/if-else.html">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/more-on-type.html">Más de tipo</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/destructuring.html">Desestructurando</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/pattern-matching.html">¡Coincidencia de patrones!</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/mutation.html">Mutación</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/imperative-loops.html">Lazos imperativos</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/jsx.html">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/external.html">Externo</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/exception.html">Excepción</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/object.html">Objeto</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/module.html">Módulo</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/promise.html">Promise</a></li></ul></div><div class="navGroup navGroupActive"><h3>JavaScript</h3><ul><li class="navListItem"><a class="navItem" href="/docs/es-ES/quickstart-javascript.html">Inicio rápido</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/interop.html">Interop</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/syntax-cheatsheet.html">Hoja de Apoyo de sintaxis</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/libraries.html">Librerías</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/converting-from-js.html">Convertir de JS</a></li></ul></div><div class="navGroup navGroupActive"><h3>Nativo</h3><ul><li class="navListItem"><a class="navItem" href="/docs/es-ES/native.html">Nativo</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/quickstart-ocaml.html">Inicio rápido</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/convert-from-ocaml.html">Convertir de OCami</a></li></ul></div><div class="navGroup navGroupActive"><h3>Extra</h3><ul><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/docs/es-ES/comparison-to-ocaml.html">Comparación a OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/newcomer-examples.html">Ejemplos de novato</a></li><li class="navListItem"><a class="navItem" href="/docs/es-ES/project-structure.html">Estructura del proyecto</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/es-ES" target="_blank">Translate</a><h1>Comparación a OCaml</h1></header><article><div><span><p>Si vienes de OCaml o eres un recién llegado leyendo un turtorial escrito en OCaml, ¡Esta guía es para ti! Pero no olvides que <a href="https://github.com/reasonml/reason-tools">herramientas-reason</a> puede cubrir la sintaxis de OCaml y Reason sobre la marcha.</p>
<h2><a class="anchor" aria-hidden="true" name="comentarios"></a><a href="#comentarios" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Comentarios</h2>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>(* OCaml (*nest*) *)</code></td><td><code>/* Reason /*nest*/ */</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" name="cambiar-de-nombre-el-operador"></a><a href="#cambiar-de-nombre-el-operador" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cambiar de nombre el operador</h2>
<p>Reason tiene todo los operadores de Ocaml infijos, pero un par de estos son expresados de forma diferente. En Reason, igualdad de estructura es escrita como <code>==</code>, e igualdad de referencia (física) como <code>===</code>. En Reason, para obtener la desigualdad correspondiente, simplemente cambia el primer caracter por <code>!</code>. (<code>!=</code> para desigualdad estructural, y <code>!==</code> para desigualdad de referencia).</p>
<table>
<thead>
<tr><th>Igualdad</th><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td>Estructural</td><td><code>x = y</code></td><td><code>x == y</code></td></tr>
<tr><td>Referencia</td><td><code>x == y</code></td><td><code>x === y</code></td></tr>
</tbody>
</table>
<table>
<thead>
<tr><th>Desigualdad</th><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td>Estructural</td><td><code>x &lt;&gt; y</code></td><td><code>x != y</code></td></tr>
<tr><td>Referencia</td><td><code>x != y</code></td><td><code>x !== y</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" name="ambito-local-local-scope"></a><a href="#ambito-local-local-scope" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Ámbito local (Local Scope)</h2>
<p>El ámbito léxico de Reason es exactamente igual al de OCaml, pero los bindings se parecen más sintácticamente a los &quot;ámbitos de bloque&quot; lo cual es más familiar para muchos desarrolladores. En Reason, esto están creados con llaves <code>{}</code>, los cuales contienen ambos <code>let</code> bidings y son comandos imperativos, separados por <code>;</code>. Todos los bloques evaluados hasta la última línea y el punto y coma en la última línea es opcional. Las llaves<code>{}</code> son solo necesitas si tienes más de un ítem que concatenar vía <code>;</code>.</p>
<table>
  <tr>
    <th>
      <p>
        OCaml
      </p>
    </th>
<pre><code class="hljs">&lt;th&gt;
  &lt;p&gt;
    Reason
  &lt;/p&gt;
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre>
let _ =
  let message = "Hello" in
  print_string mess
  let msg2 = "Goodbye" in
  print_string msg2age;</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;
</code></pre>
<p>{
let message = &quot;Hel
print_string(messa
let msg2 = &quot;Goodbye&quot;;
print_string(msg2)
};ge);lo&quot;;</pre>
</td></p>
  </tr>
</table>
<p>La sintáxis <code>{}</code> de Reason quitan muchos de los puntos fastidiosos en la sintaxis de Ocaml:</p>
<ul>
<li>Doble punto y coma están eliminados totalmente.</li>
<li><code>begin</code>/<code>end</code> están removidos totalmente.</li>
<li>Los infames <a href="https://github.com/ocaml/ocaml/pull/278">problemas</a> con los analizadores sintácticos (parsing) imperativos ya no están.</li>
<li>Los cuerpo modulares y el ámbito local están unificados.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" name="ambito-local-vs-modulo-de-cuerpo"></a><a href="#ambito-local-vs-modulo-de-cuerpo" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Ámbito Local vs Módulo de Cuerpo</h2>
<p>En Reason, todo puede estar entre <code>{}</code> en <a href="#local-scope">Ámbito Local</a> y los módulos de cuerpos. Generalmente, hasta puedes, inclusive, cortar/pegar códigos entre dos contextos. En OCaml, las sintaxis para dos contextos son muy diferentes. Ámbito local requiere llevar <code>in</code>, pero cuerpos modulares no lo necesitan y declaraciones imperativas deben ser asignadas a <code>_</code> o <code>()</code>, o usar doble <code>;;</code>.</p>
<table>
  <tr>
    <th>
      <p>
        OCaml Module Body
      </p>
    </th>
<pre><code class="hljs">&lt;th&gt;
  &lt;p&gt;
    Reason Module Body
  &lt;/p&gt;
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre>
let ten = 10
let () = imperativeFunc ten ten
let () = imperativeFunc 0 0</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;
</code></pre>
<p>let ten = 10;
imperativeFunc(ten, ten);
imperativeFunc(0, 0);</pre>
</td></p>
  </tr>
  <tr>
    <td>
      <pre>
let ten = 10;;
imperativeFunc ten ten;;
imperativeFunc 0 0;;</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  Igual que arriba
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <th>
      <p>
        OCaml Local Scope
      </p>
    </th>
<pre><code class="hljs">&lt;th&gt;
  &lt;p&gt;
    Reason Local Scope
  &lt;/p&gt;
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre>
let ten = 10 in
let _ = imperativeFunc ten ten in
imperativeFunc 0 0</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  igual que arriba
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre>
let ten = 10 in begin
  imperativeFunc ten ten;
  imperativeFunc 0 0
end</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  igual que arriba
&lt;/td&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre>
let ten = 10 in (
  imperativeFunc ten ten;
  imperativeFunc 0 0
)</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  igual que arriba
&lt;/td&gt;
</code></pre>
  </tr>
</table>
<h2><a class="anchor" aria-hidden="true" name="tupla-y-registro"></a><a href="#tupla-y-registro" aria-hidden="true" class="hash-link" ><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tupla y registro</h2>
<p>En Reason, tuplas siempre requieren paréntesis.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let tup = 4, 5</code></td><td><code>let tup = (4, 5);</code></td></tr>
<tr><td><code>let tup = ((1: int), (2:int))</code></td><td><code>let tup = (1: int, 2:int);</code></td></tr>
<tr><td><code>fun ((a: int), (b: int)) -&gt; a</code></td><td><code>((a: int, b: int)) =&gt; a;</code></td></tr>
</tbody>
</table>
<p>En Reason, registro de valores se parece al de JavaScript, usando <code>:</code> en vez de <code>=</code>. Debido a que las tuplas de Reason siempre requiere paréntesis que la encierren, registros pueden contener expresiones anónimas sin necesidad de paréntesis extras.</p>
<table>
  <tr>
    <th>
      <p>
        OCaml
      </p>
    </th>
<pre><code class="hljs">&lt;th&gt;
  &lt;p&gt;
    Reason
  &lt;/p&gt;
&lt;/th&gt;
</code></pre>
  </tr>
  <tr>
    <td>
      <pre>
let myRec = {x = 0; y = 10}</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;
</code></pre>
<p>let myRec = {x: 0, y: 10};</pre>
</td></p>
  </tr>
  <tr>
    <td>
      <pre>
let myFuncs = {
  myFun = (fun x -> x + 1);
  your = (fun a b -> a + b);
}</pre>
    </td>
<pre><code class="hljs">&lt;td&gt;
  &lt;pre&gt;
</code></pre>
<p>let myFuncs = {
myFun: (x) =&gt; x + 1,
your: (a, b) =&gt; a + b
};</pre>
</td></table></p>
<pre><code class="hljs">&lt;h2&gt;
  Listas
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let list = [1; 2; 3]&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let list = [1, 2, 3]&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let list = hd :: tl&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let list = [hd, ...tl];&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h2&gt;
  Tipos de definición
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml Tuple
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason Tuple
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type tuple = int * int&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type tuple = (int, int);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let tup: tuple = (10, 30)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let tup: tuple = (10, 30);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml Record
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason Record
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type r = {x: int; y: int}&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type r = {x: int, y: int};&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let myRec: r = {x = 0; y = 10}&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let myRec: r = {x: 0, y: 10};&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml Function
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason Function
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type func = int -&amp;gt; int&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type func = int =&amp;gt; int;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x: func = fun a -&amp;gt; a + 1&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x: func = (a) =&amp;gt; a + 1;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h2&gt;
  Funciones
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x a b = e&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = (a, b) =&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = fun a b -&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = (a, b) =&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = fun a -&amp;gt; fun b -&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = (a, b) =&amp;gt; e&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  Argumento único de funciones coincidentes
&lt;/h3&gt;

&lt;p&gt;
  OCaml tiene una definición de función (&lt;code&gt;function |&lt;/code&gt;) la cual es considerada equivalente a &lt;code&gt;function a -&amp;gt; match a with &lt;/code&gt;. Reason tiene lo mismo, pero la sintaxis deja claro como es en verdad una extensión de una función de argumento único. El caso de coincidencia única es una extensión natural de lambda simple, y el caso múltiple lambda es una extensión natural de lambda de caso único.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        Forma
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      lambda
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>fun pat -&gt; e</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>fun pat =&gt; e</pre>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      caso de Coincidencia única
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>function | pat -&gt; e</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>fun | pat =&gt; e</pre>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      muchos casos
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>function | pat -&gt; e
| pat2 -&gt; e</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>fun | pat =&gt; e
| pat2 =&gt; e</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  Anotación de argumentos
&lt;/h3&gt;

&lt;p&gt;
  Tanto en Reason como en OCamls, argumentos son anotados con tipos (como con todos los demás), encerrándolos en paréntesis despues de agregar &lt;code&gt;:typeAnnotation&lt;/code&gt;.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;reason&quot;&gt;(arg: argType) =&amp;gt; returnValue;
</code></pre>
<p></code></pre></p>
<pre><code class="hljs">&lt;pre&gt;&lt;code class=&quot;reason&quot;&gt;(arg: argType) =&amp;gt; (arg2: arg2Type) =&amp;gt; returnValue;
</code></pre>
<p></code></pre></p>
<pre><code class="hljs">&lt;pre&gt;&lt;code class=&quot;reason&quot;&gt;(arg: argType, arg2: arg2Type) =&amp;gt; returnValue;
</code></pre>
<p></code></pre></p>
<pre><code class="hljs">&lt;p&gt;
  Reason y OCaml permite anotar el tipo de retorno, cuando usando la forma &quot;super azucarada let binding&quot;.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;(* OCaml *)
</code></pre>
<p>let myFunc (a:int) (b:int) :int * int = (a, b)
let myFunc (a:int) (b:int) :int list = [1]
let myFunc (a:int) (b:int) :int -&gt; int = fun x -&gt; x + a + b
</code></pre></p>
<pre><code class="hljs">&lt;pre&gt;&lt;code class=&quot;reason&quot;&gt;/* Reason */
</code></pre>
<p>let myFunc = (a: int, b: int) :(int, int) =&gt; (a, b);
let myFunc = (a: int, b: int) :list(int) =&gt; [1];
let myFunc = (a: int, b: int): (int =&gt; int) =&gt; (x) =&gt; x + a + b;
</code></pre></p>
<pre><code class="hljs">&lt;p&gt;
  Porque estamos usando &lt;code&gt;=&amp;gt;&lt;/code&gt; para todas las funciones en cualquier lugar en Reason, hay un caso donde necesitamos agregar un paréntesis extra alrededor del tipo de retorno que es, en sí misma, la función tipo.
&lt;/p&gt;

&lt;h3&gt;
  Parámetros de tipo
&lt;/h3&gt;

&lt;h4&gt;
  OCaml
&lt;/h4&gt;

&lt;p&gt;
  Las aplicaciones de tipo de OCaml (piensa &quot;genérico), son aplicados en orden inverso.
&lt;/p&gt;

&lt;p&gt;
  Con OCaml, hay algunas consecuencias poco intuitivas.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let x: int list = [2]
</code></pre>
<p>type listOfListOfInts = int list list</p>
<p>(* Parsed as: *)
type listOfListOfInts = (int list) list
</code></pre></p>
<pre><code class="hljs">&lt;p&gt;
  Las cosas se ponen aún más extrañas cuando constructores de tipo aceptan parámetros múltiples. Múltiples argumentos requiere paréntesis y comas para separar parámetros de tipo, pero esos parámetros no representan tuplas. La forma paréntesis/comas debe también ser dada cuando las instancias de sipo de construcción tales como &lt;code&gt;(int, string) tupl3&lt;/code&gt;.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;type ('a, 'b) tuple = 'a * 'b
</code></pre>
<p>type listOfTuplesOfStringAndInt = (string, int) tuple list</p>
<p>(* Which is parsed as: *)
type listOfTuplesOfStringAndInt = ((string, int) tuple) list</p>
<p>(* Which allows a list of (tuples of (string and int)) *)
let tuples: listOfTuplesOfStringAndInt = [(&quot;asdf&quot;, 3)]
</code></pre></p>
<pre><code class="hljs">&lt;h4&gt;
  Reason
&lt;/h4&gt;

&lt;p&gt;
  En resumen, Reason unifica casi toda la sintaxis en simples estilos de &quot;funciones de aplicación&quot;, lo que significa que los parámetro de tipo siguen la misma lista de espacio separado vista en todos los demas lados de la sintaxis. Esto resulta en menos patrones sintácticos que aprender.
&lt;/p&gt;

&lt;p&gt;
  Por ejemplo, puedes imaginar &lt;code&gt;list&lt;/code&gt; siendo una &quot;función&quot; para tipos que aceptan un tipo y devuelve un nuevo tipo.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let x: int list = [2]
type listOfListOfInts = int list list
type ('a, 'b) tup = ('a * 'b)
type pairs = (int, int) tup list
let tuples: pairs = [(2, 3)]</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let x: list(int) = [2];
type listOfListOfInts = list(list(int));
type tup('a, 'b) = ('a, 'b);
type pairs = list(tup(int, int));
let tuples: pairs = [(2, 3)];</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h2&gt;
  Tuplas como parámetros de tipo
&lt;/h2&gt;

&lt;p&gt;
  Porque OCaml usa paréntesis y comas para representar argumentos múltiples para constructores de tipo, es confuso cuando uno de los argumentos de un constructor de tipo es en sí una tupla. En OCaml, es difícil recordar la diferencia entre un constructor de tipo que acepte múltiples argumentos y un constructor de tipo que acepte un sólo elemento, que pasa ser un tupla.
&lt;/p&gt;

&lt;p&gt;
  Los siguientes ejemplos muestran la diferencia entre pasar &lt;em&gt;dos&lt;/em&gt; parámetros de tipo a &lt;code&gt;pair&lt;/code&gt;, y un &lt;em&gt;sólo &lt;/em&gt; parámetro de tipo que también es una tupla.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type intPair = (int, int) pair&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type intPair = pair(int, int)&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;type pairList = (int * int) list&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;type pairList = list((int, int))&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;
    En Reason, la sintaxis que representa una tupla o tipos de tupla, siempre lucen como tuplas.
  &lt;/li&gt;
  &lt;li&gt;
    En Reason, la sintaxis que representa los registros o los tipos de registro, siempre lucen como registros.
  &lt;/li&gt;
  &lt;li&gt;
    Casi todo lo demás usa el patrón sintáctico de aplicación de función (argumentos separados por espacios).
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;
  Variantes
&lt;/h2&gt;

&lt;h5&gt;
  OCaml
&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    OCaml ya espera tipos de argumentos de contrucción para ser especificados en forma de tupla, por lo que es confuso cuando un sólo construcotr espera un sólo argumento que también &lt;em&gt;pasa ser&lt;/em&gt; un tipo tupla.
  &lt;/li&gt;
  &lt;li&gt;
    Lo que es aún más confuso es que los constructores &lt;em&gt;en verdad&lt;/em&gt; no aceptan tuplas, pero aún así la sintáxis se asemeja a las tuplas.
  &lt;/li&gt;
  &lt;li&gt;
    A veces, la sintáxis para iniciar un constructor con múltiples argumentos se superpone superpone la sintaxis para construir una variante con un sólo argumento que pasa ser una tupla- por lo que lucen &lt;em&gt;exactamente&lt;/em&gt; como si &lt;em&gt;estuvieras&lt;/em&gt; suministrando una tupla cuando en verdad no debes suministrar una.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;
  Reason
&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    Tipos de constructor variante son esperados estar listados como listas separadas por espacios, usando paréntesis para agrupar las precedentes (así como con &lt;strong&gt;todo&lt;/strong&gt; lo demás).
  &lt;/li&gt;
  &lt;li&gt;
    Instancias de construcción de la variante (como habrías adivinado) siguen el estilo de aplicación de la función (listas separadas por espacios).
  &lt;/li&gt;
  &lt;li&gt;
    Tuplas &lt;strong&gt;simpre&lt;/strong&gt; &lt;em&gt;lucen&lt;/em&gt; como tuplas, y cualquier cosa que luzca como una tupla &lt;em&gt;es&lt;/em&gt; una tupla.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>type myVariant =
| HasNothing
| HasSingleInt of int
| HasSingleTuple of (int * int)
| HasMultipleInts of int * int
| HasMultipleTuples of (int * int) * (int * int)
</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>type myVariant =
| HasNothing
| HasSingleInt(int)
| HasSingleTuple((int, int))
| HasMultipleInts(int, int)
| HasMultipleTuples((int, int), (int, int));
</pre>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let a = HasSingleInt 10
let a = HasSingleTuple (10, 10)
let a = HasMultipleInts (10, 10)
let a = HasMultipleTuples ((10, 10), (10, 10))
</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let a = HasSingleInt(10);
let a = HasSingleTuple((10, 10));
let a = HasMultipleInts(10, 10);
let a = HasMultipleTuples((10, 10), (10, 10));
</pre>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let res x = match x with
| HasNothing -&gt; 0
| HasSingleInt x -&gt; 0
| HasSingleTuple (x, y) -&gt; 0
| HasMultipleInts (x, y) -&gt; 0
| HasMultipleTuples ((x, y), (q, r)) -&gt; 0
</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let res = (x) =&gt;
switch (x) {
| HasNothing =&gt; 0
| HasSingleInt(x) =&gt; 0
| HasSingleTuple((x, y)) =&gt; 0
| HasMultipleInts(x, y) =&gt; 0
| HasMultipleTuples((x, y), (q, r)) =&gt; 0
};
</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h2&gt;
  Coincidencia de patrón
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let res = match x with
| A (x, y) -&gt; match y with
| None -&gt; 0
| Some i -&gt; 10
| B (x, y) -&gt; 0</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let res = switch (x) {
| A((x, y)) =&gt; switch (y) {
| None =&gt; 0
| Some(i) =&gt; 10
}
| B((x, y)) =&gt; 0
};</p>
</pre>
        </td>
      </tr>
    </table>
<pre><code class="hljs">&lt;p&gt;
  ¿Puedes detectar el error en el ejemplo de OCaml? Este es uno de los errores más comunes entre los programadores OCaml. El segundo &lt;code&gt;match&lt;/code&gt; &lt;em&gt;debe&lt;/em&gt; ser encerrado en paréntesis, de otra forma el caso &lt;code&gt;Some&lt;/code&gt; es analizado como si perteneciera al &lt;code&gt;match&lt;/code&gt; exterior. Visually, it's actually:
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ocaml&quot;&gt;let res = match x with
</code></pre>
<p>| A (x, y) -&gt; match y with
| None -&gt; 0
| Some i -&gt; 10
| B (x, y) -&gt; 0
</code></pre></p>
<pre><code class="hljs">&lt;p&gt;
  Reason's mandatory &lt;code&gt;{}&lt;/code&gt; around &lt;code&gt;switch&lt;/code&gt; cases prevents this issue.
&lt;/p&gt;

&lt;h2&gt;
  Módulos y Firmas
&lt;/h2&gt;

&lt;h3&gt;
  Definición
&lt;/h3&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module type MySig = sig
type t = int
val x: int
end
module MyModule: MySig = struct
type t = int
let x = 10
end
module MyModule = struct
module NestedModule = struct
let msg = &quot;hello&quot;;
end
end
</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module type MySig = {
type t = int;
let x: int;
};
module MyModule: MySig = {
type t = int;
let x = 10;
};
module MyModule = {
module NestedModule = {
let msg = &quot;hello&quot;;
};
};
</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  Tipos de Funtor
&lt;/h3&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module type FType =
functor (A: ASig) -&gt;
functor (B: BSig) -&gt; Result
</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module type FType =
(A: ASig) =&gt;
(B: BSig) =&gt; Result;
</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h2&gt;
  Funtores
&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module F =
functor (A: ASig) -&gt;
functor (B: BSig) -&gt; struct end</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module F =
(A: ASig) =&gt;
(B: BSig) =&gt; {};</pre>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module F = functor (A: ASig) (B: BSig) -&gt; struct end</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module F = (A: ASig, B: BSig) =&gt; {};</pre>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module F (A: ASig) (B: BSig) = struct end</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module F = (A: ASig, B: BSig) =&gt; {};</pre>
</td>
</tr></p>
<pre><code class="hljs">  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module Res = F(A)(B)</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>module Res = F(A, B);</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h2&gt;
  Varias mejoras
&lt;/h2&gt;

&lt;p&gt;
  OCaml no requiere paréntesis alrededor de las secuencias &lt;code&gt;(a;b;c;d)&lt;/code&gt; o tuplas &lt;code&gt;(x,y)&lt;/code&gt;, por lo que termina por descartar un montón de otras reglas de sintaxis muy convenientes. Debido a que Reason siempre usa &lt;code&gt;{}&lt;/code&gt; para encerrar paréntesis o dejar bidings, y Reason siempre requiere &lt;code&gt;()&lt;/code&gt; alrededor de las tuplas, muchos otros constructor sintácticos son expresados más intuitivamente, sin requerir otros encerramientos en paréntesis.
&lt;/p&gt;

&lt;h3&gt;
  Lambdas como campos de registro no necesitan extras paréntesis
&lt;/h3&gt;

&lt;p&gt;
  Este es una mejora bienvenida porque los errores tipo de OCaml que el usuario vería serían muy confusos al creer que el valor de retorno de la funciones fue una tupla con una coma &lt;code&gt;,&lt;/code&gt; infija.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let myFuncs = {
myFun = (fun x -&gt; x + 1);
your = (fun a b -&gt; a + b);
}</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let myFuncs = {
myFun: (x) =&gt; x + 1,
your: (a, b) =&gt; a + b
};</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  Lambdas como resultados de coincidencia no requieren paréntesis extras
&lt;/h3&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let x = match prnt with
| None -&gt; fun a -&gt; blah
(* Extra () required ! *)
| Some &quot;_&quot; -&gt; (fun a -&gt; ())
| Some &quot;ml&quot; -&gt; blah
</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let x =
switch (prnt) {
| None =&gt; (a) =&gt; blah
| Some(&quot;_&quot;) =&gt; (a) =&gt; ()
| Some(&quot;ml&quot;) =&gt; blah
};</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  Lambdas y tipos de anotación en tuplas no requieren paréntesis extras
&lt;/h3&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let tuple = ((fun x -&amp;gt; x), 20)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let tuple = ((x) =&amp;gt; x, 20);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let tuple = ((&quot;hi&quot;: string), (20: int))&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let tuple = (&quot;hi&quot;: string, 20: int);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h2&gt;
  Varias Diferencias
&lt;/h2&gt;

&lt;h3&gt;
  precedencia &lt;code&gt;as&lt;/code&gt;
&lt;/h3&gt;

&lt;p&gt;
  Con Reason, &lt;code&gt;as&lt;/code&gt; tiene una mayor precedencia que la barra &lt;code&gt;|&lt;/code&gt;. Esto permite crear alias de &lt;code&gt;as&lt;/code&gt; para filas completas en coincidencias de patrón.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      &lt;p&gt;
        OCaml
      &lt;/p&gt;
    &lt;/th&gt;
    
    &lt;th&gt;
      &lt;p&gt;
        Reason
      &lt;/p&gt;
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let ppp = match MyThing 20 with
| (MyThing x as ppp)
| (YourThing x as ppp) -&gt; ppp;
</pre>
</td></p>
<pre><code class="hljs">    &lt;td&gt;
      &lt;pre&gt;
</code></pre>
<p>let ppp =
switch (MyThing(20)) {
| MyThing(x) as ppp
| YourThing(x) as ppp =&gt; ppp
};
</pre>
</td>
</tr>
</table></p>
<pre><code class="hljs">&lt;h3&gt;
  Actualizaciones de campos de registros mutables
&lt;/h3&gt;

&lt;p&gt;
  Porque igualdades y sus negaciones han tenido más consistencia en Reason, el operador &lt;code&gt;=&lt;/code&gt; es disponible para actualización mutable de campo.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;myRec.field &amp;lt;- &quot;next&quot;&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;myRec.field = &quot;next&quot;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  Operadores de prefijo
&lt;/h3&gt;

&lt;p&gt;
  Reason's &lt;code&gt;!&lt;/code&gt; is used for boolean &lt;code&gt;not&lt;/code&gt;. Deferencing uses the postfix &lt;code&gt;^&lt;/code&gt;.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(foo.bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo.bar^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(foo#bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo#bar^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(!foo.bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo^.bar^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(!foo#bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = (foo^)#bar^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(!(foo.bar))&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo.bar^ ^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !(!(foo#bar))&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = foo#bar^ ^;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !!(foo.bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = !!foo.bar;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !!(foo#bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = !!foo#bar;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !~(foo.bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = !~foo.bar;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = !~(foo#bar)&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = !~foo#bar;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  Comentarios de Escape
&lt;/h3&gt;

&lt;p&gt;
  Debido a que Reason utiliza comentarios estilo C, algunos desconocidos operadores personalizables prefijo/infijo deben ser escritos de forma diferente. Las reglas para operadores prefijos/infijos son las mismas que las de el sintaxis de OCaml, pero con las siguientes excepciones:
&lt;/p&gt;

&lt;p&gt;
  Específicamente, si algún carácter excepto el primero tiene un operador prefijo/infijo es un asterísco o un barra inclinada, que primero debe ser escapado con una barra inclinada inversa. Serán analizados (parsed) &lt;em&gt;sin&lt;/em&gt; la barra inclinada invertida cuando se añade al AST. Cuando sea reimpreso, el escape de la barra inclinada invertida será añadida de nuevo automáticamente.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let (/*) a b = a + b&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let (/\*) a b =&amp;gt; a + b;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let x = 12 /-* 23 /-* 12&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let x = 12 /-* 23 /-* 12;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let y = (/*) a b&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let y = a /\* b;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let (!=*) q r = q + r&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let ( !=* ) = (q, r) =&amp;gt; q + r;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let res = q (!=*) r&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let res = q(( !=* ), r);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let (!=/*) q r = q + r&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let ( !=/\* ) = (q, r) =&amp;gt; q + r;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;let res = q (!=/*) r&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;let res = q(( !=/\* ), r);&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  Cambiar de nombre el operador
&lt;/h3&gt;

&lt;p&gt;
  Si Reason usa &lt;code&gt;==&lt;/code&gt; para simbolizar el &lt;code&gt;=&lt;/code&gt; de OCaml, y usa el &lt;code&gt;===&lt;/code&gt; para representar el de OCaml &lt;code&gt;==&lt;/code&gt;, entonces ¿Como Reason representa el símbolo de OCaml &lt;code&gt;===&lt;/code&gt; (si este fuese definido)? ¡Reason provee una forma! ¡Triple &quot;Escape&quot; el símbolo igual!
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      Identificador
    &lt;/th&gt;
    
    &lt;th&gt;
      Significado
    &lt;/th&gt;
    
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;&quot;===&quot;&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      Valor Personalizado
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;x === y&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;x \=== y&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3&gt;
  REPL
&lt;/h3&gt;

&lt;p&gt;
  El Reason rpl &lt;a href=&quot;extra-goodies.md#repl&quot;&gt;&lt;code&gt;rtop&lt;/code&gt;&lt;/a&gt; (un personalizable &lt;a href=&quot;https://github.com/diml/utop&quot;&gt;&lt;code&gt;utop&lt;/code&gt;&lt;/a&gt;), cada entrada es envíada a través de un sólo punto y coma &lt;code&gt;;&lt;/code&gt;. El repl de OCaml requiere dos punto y coma &lt;code&gt;;;&lt;/code&gt;.
&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;
      OCaml
    &lt;/th&gt;
    
    &lt;th&gt;
      Reason
    &lt;/th&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;code&gt;;;&lt;/code&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;code&gt;;&lt;/code&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="convert-from-ocaml.html">← Convertir de OCami</a><a class="docs-next button" href="newcomer-examples.html">Ejemplos de novato →</a></div></div></div></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react'
              });
            </script></body></html>